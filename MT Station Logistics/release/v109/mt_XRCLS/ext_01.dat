<?xml version="1.0" encoding="utf-8"?>
<!-- 
	MT Station Logistics
	Version 1.0.0 - 2015-01-14
	This ai script is executed by the captain to get a trade offer
-->
<aiscript name="mt_logistics.trade.gettradeoffer" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="C:\Users\andy\Dropbox (Personal)\Games\XRebirth\modwip\Resources\aiscripts.xsd">
	<!-- Returns a valid trade offer with an amount, reservation and return code - be sure to cancel the reserved amount if the trade fails -->
	<params>
		<param name="lWaypoint" default="[]"	comment="The waypoint we are needing to get a trade offer for"/>
		<param name="DebugLvl"	default="0"/>
	</params>
	<interrupts>
		<!-- Vanilla handler refs -->
		<handler ref="AttackHandler" />
		<handler ref="ScannedHandler" />
		<!-- Handlers for changing debug level -->
		<handler comment="Update the global debug level for this ship">
			<conditions>
				<event_object_signalled object="player.primaryship" param="'XRCLS_UpdateDebugLevel'"/>
			</conditions>
			<actions>
				<debug_text text="'Interrupt Fired: Updating global debug level for all ships %1'.[this.ship.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$bShipDbg"				exact="$DebugLvl"/>
				<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
				<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
				<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
				<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
			</actions>
		</handler>

		<handler comment="Update the debug level just for this ship">
			<conditions>
				<event_object_signalled object="this.ship" param="'XRCLS_UpdateShipDbgLvl'"/>
			</conditions>
			<actions>
				<set_value name="$bShipDbg"				exact="event.param2"/>
				<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
				<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
				<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
				<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
				<debug_text text="'Interrupt Fired: Updating debug level for %1 Debug Verb = %2 ShipDbg = %3 Global = %4'.[this.ship.knownname, $iDbgVerb,$bShipDbg,global.$XRCLS.$iDebugLevel]" filter="scripts_verbose" chance="$iDbgVerb"/>
			</actions>
		</handler>
	</interrupts>
	<init>
		<set_command_action commandaction="commandaction.searchingtrades" />
	</init>
	<attention min="unknown">
		<actions>
			<!-- Set the debugging output chance -->
			<!-- Setup the debugging levels -->
			<set_value name="$bShipDbg"			exact="$DebugLvl"		comment="0 or 1 to override error dbg level"/>
			<set_value name="$iDbgErr"			exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
			<set_value name="$iDbgInfo"			exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
			<set_value name="$iDbgDet"			exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
			<set_value name="$iDbgVerb"			exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
			<!-- Extract our waypoint for analysis -->
			<set_value name="$iWPCount"			exact="$lWaypoint.{1}"			comment="Index of WP in list"/>
			<set_value name="$bIsWPActive"		exact="$lWaypoint.{2}"			comment="Note that this is an integer value as Lua thinks false=0 is actually true lol"/>
			<set_value name="$oStation"			exact="$lWaypoint.{3}"			comment="Target station"/>
			<set_value name="$iWPType"			exact="$lWaypoint.{4}"			comment="WP Type (buy, sell, fly to etc.) is integer"/>
			<set_value name="$tWare"			exact="ware.{$lWaypoint.{5}}"	comment="Needed to coerce the string value back to a ware type"/>
			<set_value name="$iMinAmount"		exact="$lWaypoint.{6}"			comment="minimum amount worth setting off for"/>
			<set_value name="$iMaxAmount"		exact="$lWaypoint.{7}"			comment="Maximum stored in hold at any given time"/>
			<set_value name="$iPrice"			exact="$lWaypoint.{8}"			comment="Max or Min price depending on whether buying or selling"/>
			<set_value name="$iWPRange"			exact="$lWaypoint.{9}"			comment="Flight range of waypoint relative to home base"/>
			<!-- Set some variables used locally -->
			<set_value name="$iDesiredAmount"	exact="$iMaxAmount - this.ship.cargo.{$tWare}.count"	comment="The amount we need to fulfil our maximium load for a buy order"/>
			<set_value name="$aRetArg"			exact="'NO_TRADEOFFER'"			comment="Default assuming we get no offer"/>
			<set_value name="$lTradeOffer"		exact="'none'"					comment="Empty holder for our returned tradeoffer"/>
			<set_value name="$bIsTradeValid"	exact="false"					comment="True if we found a valid trade offer"/>
			<set_value name="$bPriceOK"			exact="true"					comment="True if ware unit price is in required price range for buy and sell"/>
			<set_value name="$iActualAmount"	exact="0"						comment="Our actual reserved amount to return"/>
			<!-- Remove any ware reservations we might still have at this station -->
			<remove_ware_reservation object="$oStation" entity="this"/>

			<!-- Buy, load or refuel waypoint -->
			<do_if value="$iWPType == 2 or $iWPType == 4 or $iWPType == 7" comment="Buy, load or refuel">
				<do_if value="$iWPType == 7" comment="Refuel waypoint">
					<set_value name="$tWare"			exact="ware.fuelcells"/>
					<set_value name="$iMaxAmount"		exact="this.ship.cargo.{ware.fuelcells}.max"/>
					<set_value name="$iDesiredAmount"	exact="$iMaxAmount - this.ship.cargo.{ware.fuelcells}.count"	comment="Fill to brim on a refuel"/>
					<set_value name="$iMinAmount"		exact="$iMaxAmount - $iMinAmount" comment="Viability check inverted for refuel?? - CHECK!!"/>
				</do_if>
				<do_if value="this.ship.cargo.{$tWare}.free lt $iDesiredAmount" comment="Cant fit desired amount in so set to freespace left">
					<set_value name="$iDesiredAmount" exact="this.ship.cargo.{$tWare}.free"/>
				</do_if>
				<!-- Check that our cargo space available is greater than the minimum amount we are going to buy -->
				<do_if value="$iMinAmount le this.ship.cargo.{$tWare}.free" comment="We have room so continue - also prevents refuelling if tank has more than $iMinAmount">
					<!-- check how many of the target ware we already have onboard -->
					<do_if value="this.ship.cargo.{$tWare}.count lt $iMaxAmount">
						<!-- Check that the amount we want is greater than the minimum trip amount -->
						<do_if value="$iDesiredAmount ge $iMinAmount">
							<!-- If we get here we need to check the station for a valid load/buy offer -->
							<find_sell_offer tradepartner="this.ship" seller="$oStation" space="$oStation.zone" result="$lSellOffers" wares="[$tWare]" multiple="true"/>
							<do_if value="$lSellOffers.count gt 0">
								<do_all exact="$lSellOffers.count" counter="$i" comment="Debugging">
									<debug_text text="'WP #%3 - Sell Offer Found: Ware %1 Amount %2'.[$lSellOffers.{$i}.ware, $lSellOffers.{$i}.offeramount, $iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
								</do_all>
								<!-- Get our trade offer -->
								<set_value name="$lTradeOffer"		exact="$lSellOffers.{1}"/>
								<!-- If this is a buy waypoint we need to check the price of the offer to ensure it meets the WP criteria -->
								<do_if value ="$iWPType == 4"												comment="Assumes we will pay any price for refuelling">
									<set_value name="$iSellPrice"	exact="$lTradeOffer.unitprice/100ct"	comment="Get unit price of offer"/>
									<do_if value="$iPrice lt $iSellPrice">
										<set_value name="$bPriceOK" exact="false"							comment="WP fails on price check"/>
									</do_if>
								</do_if>
								<!-- Price OK? -->
								<do_if value="$bPriceOK">
									<!-- Now check that there is enough ware to meet our needs at the station -->
									<do_if value="$lTradeOffer.offeramount ge $iMinAmount"							comment="TODO: Should we check for more than one offer found??">
										<do_if value="$lTradeOffer.offeramount lt $iDesiredAmount">
											<set_value name="$iActualAmount" exact="$lTradeOffer.offeramount"	comment="Buy as much as the station has"/>
										</do_if>
										<do_else>
											<set_value name="$iActualAmount" exact="$iDesiredAmount"				comment="Buy the amount we want - for refuel the final docked check should ensure we fill up"/>
										</do_else>
										<!-- Check that we have enough funds to make the purchase -->
										<set_value name="$iTradeCost" exact="$lTradeOffer.unitprice * $iActualAmount"/>
										<do_if value="$iTradeCost lt this.money">
											<!-- We have a valid sale if we got to here so let's go ahead and reserve and fly it! -->
											<debug_text text="'Waypoint %1 is valid - loading %2 %3 from %4  Price = %5 (Buyfree: %6 Sellfree %7)'.[ $iWPCount, $iActualAmount, $lTradeOffer.ware, $lTradeOffer.seller.knownname, $lTradeOffer.unitprice/100ct, $lTradeOffer.buyfree, $lTradeOffer.sellfree]" filter="scripts_verbose" chance="$iDbgVerb"/>
											<!-- CALL SCRIPT TO DO TRADE -->
											<set_value name="$bIsTradeValid" exact="true"/>
											<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_SUCCESS'"			comment="Found a valid trade"/>
										</do_if>
										<do_else>
											<debug_text text="'Waypoint %1 - Invalid: Not enough cash to make purchase Need: %2 Have %3'.[ $iWPCount, $iTradeCost, this.money/100ct]" filter="scripts_verbose" chance="$iDbgVerb"/>
											<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_NOCASH'"/>
										</do_else>
									</do_if>
									<do_else>
										<debug_text text="'Waypoint %1 not viable because there are not enough wares for sale at %2'.[$iWPCount, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
										<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_NOWARES'"/>
									</do_else>
								</do_if>
								<do_else comment="Wares too expensive">
									<debug_text text="'Waypoint %1 not viable because %2 are too expensive (%3cr each) at %4'.[$iWPCount, $lTradeOffer.ware, $iSellPrice, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
									<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_COST'"/>
								</do_else>
							</do_if>
							<do_else>
								<debug_text text="'Waypoint %1 not viable because there are no sell offers for the ware at %2'.[$iWPCount, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
								<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_NO_OFFER'"/>
							</do_else>
						</do_if>
						<do_else>
							<debug_text text="'Waypoint %1 not viable because the amount needed is too small for a viable trip'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
							<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_NOTVIABLE_AMOUNT'"/>
						</do_else>
					</do_if>
					<do_else>
						<debug_text text="'Waypoint %1 not viable because we already have enough of this ware onboard'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_DONTNEED'"/>
					</do_else>
				</do_if>
				<do_else>
					<debug_text text="'Waypoint %1 not viable due to not enough cargospace'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<set_value name="$aRetArg"			exact="'ERR_SELLOFFER_NOCARGOSPACE'"/>
				</do_else>
			</do_if>

			<!-- Unload or sell waypoint -->
			<do_elseif value="$iWPType == 3 or $iWPType == 5" comment="Unload or sell">
				<!-- Check that we have the desired ware on board first -->
				<do_if value="this.ship.cargo.{$tWare}.count ge $iMinAmount">
					<!-- We have enough so lets check our target station to see if it wants any -->
					<find_buy_offer tradepartner="this.ship" buyer="$oStation" space="$oStation.zone" wares="[$tWare]" result="$lBuyOffers" multiple="true"/>
					<do_if value="$lBuyOffers.count gt 0">
						<do_all exact="$lBuyOffers.count" counter="$i">
							<debug_text text="'WP #%3 - Buy Offer Found: Ware %1 Amount %2 Station: %4 Zone: %5'.[$lBuyOffers.{$i}.ware, $lBuyOffers.{$i}.offeramount, $iWPCount, $lBuyOffers.{$i}.buyer.knownname,  $lBuyOffers.{$i}.buyer.zone.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
						</do_all>
						<!-- Get our trade offer -->
						<set_value name="$lTradeOffer"		exact="$lBuyOffers.{1}"/>
						<!-- Check price if this is a sell waypoint -->
						<do_if value ="$iWPType == 5"												comment="None">
							<set_value name="$iBuyPrice"	exact="$lTradeOffer.unitprice/100ct"	comment="Get unit price of offer"/>
							<do_if value="$iPrice gt $iBuyPrice">
								<set_value name="$bPriceOK" exact="false"							comment="WP fails on price check"/>
							</do_if>
						</do_if>
						<!-- Price OK? -->
						<do_if value="$bPriceOK">
							<!-- Now check that there are enough wares required at the station -->
							<do_if value="$lTradeOffer.offeramount ge $iMinAmount">
								<do_if value="$lTradeOffer.offeramount lt $iMaxAmount">
									<do_if value="this.ship.cargo.{$tWare}.count gt $lTradeOffer.offeramount">
										<set_value name="$iActualAmount" exact="$lTradeOffer.offeramount" comment="Sell the amount the station wants"/>
										<debug_text text="'1. Sell Amount set to %1 cargo = %2'.[$iActualAmount,this.ship.cargo.{$tWare}.count]" filter="scripts_verbose" chance="$iDbgVerb"/>
									</do_if>
									<do_else>
										<set_value name="$iActualAmount" exact="this.ship.cargo.{$tWare}.count" comment="Sell as much as we have"/>
										<debug_text text="'2. Sell Amount set to %1 cargo = %2'.[$iActualAmount,this.ship.cargo.{$tWare}.count]" filter="scripts_verbose" chance="$iDbgVerb"/>
									</do_else>
								</do_if>
								<do_else comment="Station wants more than we are selling">
									<do_if value="this.ship.cargo.{$tWare}.count gt $iMaxAmount">
										<set_value name="$iActualAmount" exact="$iMaxAmount" comment="Sell the amount we want to sell"/>
										<debug_text text="'3. Sell Amount set to %1 cargo = %2'.[$iActualAmount,this.ship.cargo.{$tWare}.count]" filter="scripts_verbose" chance="$iDbgVerb"/>
									</do_if>
									<do_else>
										<set_value name="$iActualAmount" exact="this.ship.cargo.{$tWare}.count" comment="Sell as much as we have"/>
										<debug_text text="'4. Sell Amount set to %1 cargo = %2'.[$iActualAmount,this.ship.cargo.{$tWare}.count]" filter="scripts_verbose" chance="$iDbgVerb"/>
									</do_else>
								</do_else>
								<!-- We have a valid sale if we got to here so let's go ahead and reserve and fly it! -->
								<debug_text text="'Waypoint %1 is valid - Unloading %2 %3 to %4  Price = %5 (Buyfree: %6 Sellfree %7)'.[ $iWPCount, $iActualAmount, $lTradeOffer.ware, $lTradeOffer.buyer.knownname, $lTradeOffer.unitprice/100ct, $lTradeOffer.buyfree, $lTradeOffer.sellfree]" filter="scripts_verbose" chance="$iDbgVerb"/>
								<!-- CALL SCRIPT TO DO TRADE -->
								<set_value name="$bIsTradeValid" exact="true"/>
								<set_value name="$aRetArg"			exact="'ERR_BUYOFFER_SUCCESS'"			comment="Found a valid trade"/>
							</do_if>
							<do_else>
								<debug_text text="'Waypoint %1 not viable because there are not enough wares required at %2'.[$iWPCount, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
								<set_value name="$aRetArg"			exact="'ERR_BUYOFFER_NOTENOUGHWARES'"/>
							</do_else>
						</do_if>
						<do_else comment="Station won't pay enough">
							<debug_text text="'Waypoint %1 not viable because %2 wont pay enough'.[$iWPCount, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
							<set_value name="$aRetArg"			exact="'ERR_BUYOFFER_WONTPAY'"/>
						</do_else>
					</do_if>
					<do_else>
						<debug_text text="'Waypoint %1 not viable because there are no buy offers for the ware at %2'.[$iWPCount, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$aRetArg"			exact="'ERR_BUYOFFER_NO_OFFER'"/>
					</do_else>
				</do_if>
				<do_else>
					<debug_text text="'Waypoint %1 not viable due to not enough of ware %2 onboard. Have %3 - Wanted at least %4'.[$iWPCount, $tWare, this.ship.cargo.{$tWare}.count, $iMinAmount]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<set_value name="$aRetArg"			exact="'ERR_BUYOFFER_NOTENOUGHCARGO'"/>
				</do_else>
			</do_elseif>					
		
			<!-- Unhandled waypoint type -->
			<do_else>
				<debug_text text="'Unhandled Waypoint Type Detected!! %1'.[$iWPType]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$aRetArg"			exact="'ERR_UNHANDLED_WP'"/>
			</do_else>	
			
			<!-- Reserve our waypoint wares if trade offer is good -->
			<do_if value="$bIsTradeValid" comment="Offer good so reserve the wares">
				<set_value name="$iReserved" exact="0"/>
				<add_ware_reservation object="$oStation" entity="this" ware="$tWare" amount="$iActualAmount" result="$iReserved"/>
				<set_value name="$iActualAmount" exact="$iReserved"/>
				<do_if value="$iReserved lt $iMinAmount">
					<debug_text text="'Target Station %1 - Failed to reserve sufficient stock Wanted %2 Got Offered %3'.[$oStation.knownname, $iMinAmount, $iReserved]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<set_value name="$aRetArg"			exact="'ERR_CANTRESERVE'"/>
					<remove_ware_reservation object="$oStation" entity="this" comment="Remove the reservation"/>
					<set_value name="$lTradeOffer" exact="'none'"/>
				</do_if>
			</do_if>

			<!-- Cleanup -->
			<remove_value name="$bShipDbg"/>
			<remove_value name="$iDbgErr"/>
			<remove_value name="$iDbgInfo"/>
			<remove_value name="$iDbgDet"/>
			<remove_value name="$iDbgVerb"/>
			<remove_value name="$iWPCount"/>
			<remove_value name="$bIsWPActive"/>
			<remove_value name="$iWPType"/>
			<remove_value name="$tWare"/>
			<remove_value name="$iMinAmount"/>
			<remove_value name="$iMaxAmount"/>
			<remove_value name="$iPrice"/>
			<remove_value name="$iWPRange"/>
			<remove_value name="$iDesiredAmount"/>
			<remove_value name="$bPriceOK"/>

			<!-- Return values to parent -->
			<return>
				<retval name="aRetArg"			value="$aRetArg"/>
				<retval name="lTradeOffer"		value="$lTradeOffer"/>
				<retval name="iActualAmount"	value="$iActualAmount"/>
				<retval name="bIsTradeValid"	value="$bIsTradeValid"/>
			</return>
		</actions>
	</attention>
	<on_abort>
		<do_if value="$oStation.exists">
			<remove_ware_reservation object="$oStation" entity="this" comment="Remove the reservation"/>
			<remove_value name="$oStation"/>
		</do_if>
	</on_abort>
</aiscript><?xml version="1.0" encoding="utf-8"?>
<!-- 
	MT Station Logistics
	Version 1.0.1 - 2015-02-02
	This ai script is executed by the captain to perform a buy trade run
-->
<aiscript name="mt_logistics.trade.ship.perform_run" version="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="C:\Users\andy\Dropbox (Personal)\Games\XRebirth\modwip\Resources\aiscripts.xsd">
	<params>
		<!-- Pass in the trader list - ship, HB, cargolist, and waypoints -->
		<param name="lWaypoint"		default="[]"/>
		<param name="DebugLvl"		default="0"/>
	</params>
	<interrupts>
		<!-- Vanilla handler refs -->
		<handler ref="AttackHandler" />
		<handler ref="ScannedHandler" />
		<!-- Handlers for changing debug level -->
		<handler comment="Update the global debug level for this ship">
			<conditions>
				<event_object_signalled object="player.primaryship" param="'XRCLS_UpdateDebugLevel'"/>
			</conditions>
			<actions>
				<debug_text text="'Interrupt Fired: Updating global debug level for all ships %1'.[this.ship.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$bShipDbg"				exact="$DebugLvl"/>
				<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
				<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
				<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
				<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
			</actions>
		</handler>

		<handler comment="Update the debug level just for this ship">
			<conditions>
				<event_object_signalled object="this.ship" param="'XRCLS_UpdateShipDbgLvl'"/>
			</conditions>
			<actions>
				<set_value name="$bShipDbg"				exact="event.param2"/>
				<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
				<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
				<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
				<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
				<debug_text text="'Interrupt Fired: Updating debug level for %1 Debug Verb = %2 ShipDbg = %3 Global = %4'.[this.ship.knownname, $iDbgVerb,$bShipDbg,global.$XRCLS.$iDebugLevel]" filter="scripts_verbose" chance="$iDbgVerb"/>
			</actions>
		</handler>

	</interrupts>
	<init>
		<set_command_action commandaction="commandaction.searchingtrades" />
		<!-- TODO: Maybe do our own logging here - e.g. message to log ship, crew, range, #WPs etc -->
	</init>
	<attention min="unknown">
		<actions>
			<!-- Set debug levels -->
			<!-- Setup the debugging levels -->
			<set_value name="$bShipDbg"				exact="$DebugLvl" comment="0 or 1 to override error dbg level"/>
			<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
			<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
			<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
			<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
			<!-- Extract our waypoint for analysis -->
			<set_value name="$iWPCount"				exact="$lWaypoint.{1}"						comment="Index of WP in list"/>
			<set_value name="$bIsWPActive"			exact="$lWaypoint.{2}"						comment="Note that this is an integer value as Lua thinks false=0 is actually true lol"/>
			<set_value name="$oStation"				exact="$lWaypoint.{3}"						comment="Target station"/>
			<set_value name="$iWPType"				exact="$lWaypoint.{4}"						comment="WP Type (buy, sell, fly to etc.) is integer"/>
			<set_value name="$tWare"				exact="ware.{$lWaypoint.{5}}"				comment="Needed to coerce the string value back to a ware type"/>
			<set_value name="$iMinAmount"			exact="$lWaypoint.{6}"						comment="minimum amount worth setting off for"/>
			<set_value name="$iMaxAmount"			exact="$lWaypoint.{7}"						comment="Maximum stored in hold at any given time"/>
			<set_value name="$iPrice"				exact="$lWaypoint.{8}"						comment="Max or Min price depending on whether buying or selling"/>
			<set_value name="$iWPRange"				exact="$lWaypoint.{9}"						comment="Flight range of waypoint relative to home base"/>
			<!-- Set some variables used locally -->
			<set_value name="$iDesiredAmount"		exact="$iMaxAmount - this.ship.cargo.{$tWare}.count"	comment="The amount we need to fulfil our maximium load for a buy order"/>
			<set_value name="$aRetArg"				exact="'NO_TRADEOFFER'"						comment="Default assuming we get no offer"/>
			<set_value name="$lTradeOffer"			exact="'none'"								comment="Empty holder for our returned tradeoffer"/>
			<set_value name="$bIsTradeValid"		exact="false"								comment="True if we found a valid trade offer"/>
			<set_value name="$iActualAmount"		exact="0"									comment="Our actual reserved amount to return"/>
			<set_value name="$iUnitPrice"			exact="0"									comment="Initialise return value"/>
			<set_value name="$iCurrentCargoAmount"	exact="this.ship.cargo.{$tWare}.count"		comment="Initialise return value"/>
			<set_value name="$iNewCargoAmount"		exact="this.ship.cargo.{$tWare}.count"		comment="Initialise return value"/>
			<set_value name="$iTradedAmount"		exact="0"									comment="Initialise return value"/>

			<!-- Does our target exist? -->
			<do_if value="not $oStation.isoperational or not $oStation.exists" comment="Station Offline or Destroyed so abort">
				<debug_text text="'Target Station %1 is not operational'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$aRetArg" exact="'ERR_TARGET_INVALID'"/>
				<resume label="finished"/>
			</do_if>
			
			<!-- Are we docked but not at our target? -->
			<do_if value="@this.ship.parkedat.container != $oStation" comment="Undock if we are docked and our next station is not the one we are docked at">
				<do_if value="this.ship.parkedat.exists">
					<debug_text text="'Undocking 1st check - Moving to target station %1'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<run_script name="'move.unpark'" sinceversion="2"/>
				</do_if>	
			</do_if>

			<!-- Try to get a trade offer to see if it's worth flying -->
			<run_script name="'mt_logistics.trade.gettradeoffer'" sinceversion="1">
				<param		 name="lWaypoint"		value="$lWaypoint"/>
				<param		 name="DebugLvl"		value="$bShipDbg"/>
				<save_retval name="aRetArg"			variable="$aRetArg"/>
				<save_retval name="lTradeOffer"		variable="$lTradeOffer"/>
				<save_retval name="iActualAmount"	variable="$iActualAmount"/>
				<save_retval name="bIsTradeValid"	variable="$bIsTradeValid"/>
			</run_script>

			<!-- Check our trade offer first before travelling to make sure it's worth the trip -->
			<do_if value="not $bIsTradeValid" comment="No trade so bug out">
				<debug_text text="'%1 has no valid offers - %2'.[$oStation.knownname, $aRetArg]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<resume label="finished"/>
			</do_if>
			
			<!-- Good to go if we get here - Ware is reserved so let's make the trip -->
			<do_if value="@this.ship.parkedat.container != $oStation" comment="Only move if we need to go to a new station">
				<do_if value="this.zone != $oStation.zone" comment="Get a bit closer if we're not already in the zone">
					<do_if value="this.ship.parkedat.exists">
						<debug_text text="'Undocking - Moving to target station %1'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<run_script name="'move.unpark'" sinceversion="1"/>
					</do_if>
					<debug_text text="'Target Station %1 - Moving in range of target'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<run_script name="'move.generic'" sinceversion="1">
						<param name="destination" value="$oStation" />
						<param name="endintargetzone" value="true"		comment="Just fly to the zone and let move.park take it from there" />
						<param name="debugchance" value="$iDbgVerb"/>
					</run_script>
				</do_if>
				<do_else>
					<debug_text text="'Target Station %1 - Already in zone - moving to dock'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<resume label="move to target"/>
				</do_else>
			</do_if>
			<do_else>
				<debug_text text="'Already parked at %1 so lets make the trade'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<resume label="make trade"/>
			</do_else>

			<!-- Check station is still functioning after trip -->
			<do_if value="not $oStation.isoperational or not $oStation.exists" comment="Station Offline or Destroyed so abort">
				<set_value name="$aRetArg" exact="'ERR_TARGET_INVALID'"/>
				<remove_ware_reservation object="$oStation" entity="this"/>
				<debug_text text="'Target Station %1 is not operational after trip made'.[$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<resume label="finished"/>
			</do_if>

			<!-- Check trade offer again after trip in case it's gone -->
			<run_script name="'mt_logistics.trade.gettradeoffer'" sinceversion="1">
				<param		 name="lWaypoint"		value="$lWaypoint"/>
				<param		 name="DebugLvl"		value="$bShipDbg"/>
				<save_retval name="aRetArg"			variable="$aRetArg"/>
				<save_retval name="lTradeOffer"		variable="$lTradeOffer"/>
				<save_retval name="iActualAmount"	variable="$iActualAmount"/>
				<save_retval name="bIsTradeValid"	variable="$bIsTradeValid"/>
			</run_script>

			<do_if value="not $bIsTradeValid" comment="Offer has died so abort">
				<remove_ware_reservation object="$oStation" entity="this"/>
				<debug_text text="'Target Station %1 has no valid sell offers now we have arrived - Reason - %2'.[$oStation.knownname, $aRetArg]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<resume label="finished"/>
			</do_if>

			<!-- Good to go - lets park up -->
			<label name="move to target"/>
			<debug_text text="'Waypoint %1 - %2 - Proceeding to park at station - %3'.[$iWPCount,player.age,$oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
			<run_script name="'move.park'" result="$parkresult" sinceversion="1">
				<param name="destination" value="$oStation" />
				<param name="tradeoffer" value="$lTradeOffer" />
				<param name="amount" value="$iActualAmount" />
			</run_script>
			<do_if value="$parkresult">
				<debug_text text="player.age + ' now parked at ' + $oStation.knownname" filter="scripts_verbose" chance="$iDbgVerb"/>
			</do_if>
			<do_elseif value="this.$reevaluate_parking?">
				<remove_value name="this.$reevaluate_parking" />
				<debug_text text="player.age + ' need to re-evaluate our reason for parking at' + $oStation.knownname" filter="scripts_verbose" chance="$iDbgVerb"/>
				<resume label="move to target" />
			</do_elseif>
			<do_else>
				<debug_text text="player.age + ' critical parking error!'" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$aRetArg" exact="'ERR_CANT_PARK'"/>
				<remove_ware_reservation object="$oStation" entity="this"/>
				<resume label="finished" />
			</do_else>

			<label name="make trade"/>
			<!-- All Good so let's trade -->
			<!-- Let's check the trade order is still valid - final check now we're parked -->
			<run_script name="'mt_logistics.trade.gettradeoffer'" sinceversion="1">
				<param		 name="lWaypoint"		value="$lWaypoint"/>
				<param		 name="DebugLvl"		value="$bShipDbg"/>
				<save_retval name="aRetArg"			variable="$aRetArg"/>
				<save_retval name="lTradeOffer"		variable="$lTradeOffer"/>
				<save_retval name="iActualAmount"	variable="$iActualAmount"/>
				<save_retval name="bIsTradeValid"	variable="$bIsTradeValid"/>
			</run_script>

			<do_if value="not $bIsTradeValid">
				<debug_text text="'Waypoint %1 - We have arrived and parked up at %2 but there is no longer a trade that matches our current way point - ABORTING %3'.[$iWPCount,$oStation.knownname, $aRetArg]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<resume label="finished"/>
			</do_if>

			<!-- Final volume check for buy orders and get faction of trade partner -->
			<do_if value="$iWPType == 2 or $iWPType == 4 or $iWPType == 7" comment="Final Volume check to prevent buying more than will fit in ship">
				<do_if value="this.ship.cargo.{$tWare}.free lt $iActualAmount">
					<set_value name="$iActualAmount" exact="this.ship.cargo.{$tWare}.free"/>
				</do_if>
				<set_value name="$OtherFaction" exact="$lTradeOffer.seller.owner"/>
			</do_if>
			<do_else>
				<set_value name="$OtherFaction" exact="$lTradeOffer.buyer.owner"/>
			</do_else>

			<!-- Start Trade - Get some data first - (should be valid to get dot values here) -->
			<set_value name="$iUnitPrice" exact="$lTradeOffer.unitprice"/>
			<set_value name="$tTradeTime" exact="((( ($iActualAmount)LF * ($tWare.volume)LF  )/(  (this.ship.cargo.{$tWare}.max)LF  * ($tWare.volume)LF   ))LF)s * 360s" comment="Calculated time is %ware transferred * 5mins"/>
			<do_if value="$tTradeTime gt 360s" comment="BandB to prevent huge wait times if data gets screwed">
				<set_value name="$tTradeTime" exact="360s"/>
			</do_if>
			
			<debug_text text="'Waypoint %1 - %2 - Calculated Delivery time = %3'.[$iWPCount, player.age, $tTradeTime]"  filter="scripts_verbose" chance="$iDbgVerb"/>

			<!-- remove the reservation at the correct point -->
			<do_if value="$iWPType == 2 or $iWPType == 4 or $iWPType == 7" comment="Remove reservation before trade for buy">
				<remove_ware_reservation object="$oStation" entity="this" comment="Remove reservation before buy as per vanilla script"/>
			</do_if>

			<execute_trade commandaction="true" tradeoffer="$lTradeOffer" tradepartner="this.ship" amount="$iActualAmount" result="$traderesult" sinceversion ="1"/>

			<do_if value="$iWPType == 3 or $iWPType == 5" comment="Remove reservation after trade for sell">
				<remove_ware_reservation object="$oStation" entity="this" comment="Remove reservation after sell as per vanilla script"/>
			</do_if>

			<detach_from_masstraffic object="this.ship" wait="true" sinceversion="1">
				<interrupt_after_time time="120s + $tTradeTime" comment="Delay is volume dependant - seems to only affect OOZ park time!" />
			</detach_from_masstraffic>
			<remove_value name="$tTradeTime"/>

			<do_if value="not $traderesult">
				<debug_text text="'Waypoint %1 - Trade seems to have failed - %2'.[$iWPCount,$aRetArg]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$aRetArg" exact="'ERR_INTRADE_FAIL'"/>
				<resume label="finished" />
			</do_if>

			<set_value name="$aRetArg" exact="'TRADE_SUCCESS'"/>
			<debug_text text="'Waypoint %1 - %2 - Successfully traded chosen goods! - %3'.[$iWPCount, player.age, $aRetArg]"  filter="scripts_verbose" chance="$iDbgVerb"/>

			<label name="finished"/>
			<do_if value="$aRetArg == 'TRADE_SUCCESS'">
				<set_value name="$iNewCargoAmount" exact="this.ship.cargo.{$tWare}.count"/>
				<do_if value="$iWPType == 2 or $iWPType == 4 or $iWPType == 7">
					<set_value name="$iTradedAmount" exact="$iNewCargoAmount - $iCurrentCargoAmount"/>
				</do_if>
				<do_else>
					<set_value name="$iTradedAmount" exact="$iCurrentCargoAmount - $iNewCargoAmount"/>
				</do_else>
				<do_if value="@$traderesult and $OtherFaction != faction.player">
					<!-- Relation bonus for the player: Base bonus for the trade itself (max +1 UI value per 4 trades) and price-based bonus (max +1 UI value per 4M Credits) -->
					<set_value name="$iFactionBoost" exact="0.00016LF + (0.00064LF / (4000000Cr)LF * (($iTradedAmount)*$iUnitPrice/1Cr)LF)"/>
					<add_faction_relation faction="faction.player" otherfaction="$OtherFaction" value="$iFactionBoost" />
					<debug_text text="'Adding some faction relation bonus - Increased rep with %1 by %2'.[$OtherFaction.knownname, $iFactionBoost]"  filter="scripts_verbose" chance="$iDbgVerb"/>
				</do_if>
				<debug_text text="'Traded: %1 units of %2 at %3 each - Total = %4'.[$iTradedAmount, $tWare, $iUnitPrice/1Cr, ($iTradedAmount)*$iUnitPrice/1Cr]"  filter="scripts_verbose" chance="$iDbgVerb"/>
			</do_if>
			<do_else>
				<debug_text text="'Waypoint %1 - Trade Failed for some reason - %2'.[$iWPCount, $aRetArg]" filter="scripts_verbose" chance="$iDbgVerb"/>
			</do_else>
			
			<!-- Clean up -->
			<remove_value name="$bShipDbg"/>
			<remove_value name="$iDbgErr"/>
			<remove_value name="$iDbgInfo"/>
			<remove_value name="$iDbgDet"/>
			<remove_value name="$iDbgVerb"/>
			<remove_value name="$iWPCount"/>
			<remove_value name="$bIsWPActive"/>
			<remove_value name="$iWPType"/>
			<remove_value name="$tWare"/>
			<remove_value name="$iMinAmount"/>
			<remove_value name="$iMaxAmount"/>
			<remove_value name="$iPrice"/>
			<remove_value name="$iWPRange"/>
			<remove_value name="$iDesiredAmount"/>
			<remove_value name="$lTradeOffer"/>
			<remove_value name="$bIsTradeValid"/>
			<remove_value name="$iActualAmount"/>
			<remove_value name="$iCurrentCargoAmount"/>
			<remove_value name="$iNewCargoAmount"/>

			<!-- Return trade details here so we can add to log -->
			<return>
				<retval name="RetArg" value="$aRetArg"/>
				<retval name="UnitPrice" value="$iUnitPrice"/>
				<retval name="Volume" value="$iTradedAmount"/>
			</return>			
		</actions>
	</attention>
	<on_abort>
		<do_if value="this.ship.parkedat.exists">
			<disconnect_from_trade_location ship="this.ship"/>
		</do_if>
		<do_if value="$oStation.exists">
			<remove_ware_reservation object="$oStation" entity="this"/>
		</do_if>
		<remove_value name="$oStation"/>
	</on_abort>
</aiscript><?xml version="1.0" encoding="utf-8"?>
<!-- 
	MT Station Logistics
	Version 1.0.0 - 2015-01-10
	This is the main ai script that is run by XRCLS trade ship captains (DO and Engineer run vanilla scripts for now)
-->
<aiscript name="mt_logistics.trade.ship" version="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="C:\Users\andy\Dropbox (Personal)\Games\XRebirth\modwip\Resources\aiscripts.xsd">
	<params>
		<!-- Pass in the trader list - ship, HB, cargolist, and waypoints -->
		<param name="lTradeDetails" default="[]"/>
	</params>
	<interrupts>
		<!-- Vanilla handler refs -->
		<handler ref="AttackHandler" />
		<handler ref="ScannedHandler" />
		<!-- Handlers for updating WP list and changing debug level -->
		<handler comment="Update the global debug level for this ship">
			<conditions>
				<event_object_signalled object="player.primaryship" param="'XRCLS_UpdateDebugLevel'"/>
			</conditions>
			<actions>
				<debug_text text="'Interrupt Fired: Updating global debug level for all ships %1'.[this.ship.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<set_value name="$bShipDbg"				exact="$lTradeDetails.{13}"/>
				<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
				<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
				<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
				<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
			</actions>
		</handler>

		<handler comment="Update the debug level just for this ship">
			<conditions>
				<event_object_signalled object="this.ship" param="'XRCLS_UpdateShipDbgLvl'"/>
			</conditions>
			<actions>
				<set_value name="$bShipDbg"				exact="event.param2"/>
				<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
				<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
				<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
				<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>
				<debug_text text="'Interrupt Fired: Updating debug level for %1 Debug Verb = %2 ShipDbg = %3 Global = %4'.[this.ship.knownname, $iDbgVerb,$bShipDbg,global.$XRCLS.$iDebugLevel]" filter="scripts_verbose" chance="$iDbgDet"/>
			</actions>
		</handler>
		
		<handler comment="Update the traders parameters">
			<conditions>
				<event_object_signalled object="this.ship" param="'XRCLS_UpdateWaypoints'"/>
			</conditions>
			<actions>
				<set_value name="$lTradeDetails" exact="event.param2"/>
				<debug_text text="'Interrupt Fired:  Crew Skill: %1  Crew Level: %2  Number of Waypoints = %3'.[$iCrewSkill, $iCrewLevel, event.param2.{4}.count]" filter="scripts_verbose" chance="$iDbgVerb"/>
			</actions>
		</handler>
	</interrupts>
	<init>
		<set_command command="command.freetrade" />
		<!-- Main action for waiting times -->
		<set_command_action commandaction="commandaction.searchingtrades" />
		<!-- TODO: Maybe do our own logging here - e.g. message to log ship, crew, range, #WPs etc -->
		<set_value name="$oShip" exact="this.ship" comment="set to allow reporting if ship dies"/>
	</init>
	<attention min="unknown"> 
		<actions>
			<!-- Setup the debugging levels -->
			<set_value name="$bShipDbg"				exact="$lTradeDetails.{13}" comment="0 or 1 to override error dbg level"/>
			<set_value name="$iDbgErr"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 0)"/>
			<set_value name="$iDbgInfo"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 1)"/>
			<set_value name="$iDbgDet"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 2)"/>
			<set_value name="$iDbgVerb"				exact="100 * ((global.$XRCLS.$iDebugLevel + $bShipDbg) ge 3)"/>

			<set_value name="$tLastWageRun"			exact="player.age"/>
			<set_value name="$tStartTime"			exact="player.age"/>
			<set_value name="$tCumlTime"			exact="0s"/>
			<set_value name="$lWPTypeList"			exact="['No Action','Load','Unload','Buy','Sell','Fly To','Refuel']"/>
			<set_value name="$iNullSweepCounter"	exact="0"						comment="Counts the number of times we have a zero hit sweep of the list"/>
			<set_value name="$iAmountOwed"			exact="0ct"						comment="Holds amount of wages owed until they are paid"/>
			<set_value name="$iWageBill"			exact="0ct"						comment="Running total of wages to pay"/>
			<set_value name="$bStaffOnStrike"		exact="false"					comment="True if staff didn't get paid on last wage run"/>

			<!-- Perpetual loop - can be interrupted and aborted only -->
			<do_while value="true">
				<set_value name="$lWaypoints"			exact="$lTradeDetails.{4}"		comment="Get our list of waypoints"/>
				<set_value name="$iShipIndex"			exact="$lTradeDetails.{10}"		comment="Index of this trader in global list"/>
				<set_value name="$iWPCount"				exact="1"						comment="Counter for the waypoint loop"/>	
				<set_value name="$bIsNullSweep"			exact="true"					comment="True if we got a null sweep"/>

				<!-- Loop through all our waypoints looking for valid ones to execute -->
				<do_while value="$iWPCount le $lWaypoints.count" comment="Use a while loop with compares as our waypoint list size could change at any time">
					<!-- v1.07 added these here so that ship index gets updated on every waypoint sweep in case it changes -->
					<set_value name="$lWaypoints"			exact="$lTradeDetails.{4}"		comment="Get our list of waypoints"/>
					<set_value name="$iShipIndex"			exact="$lTradeDetails.{10}"		comment="Index of this trader in global list"/>
					<!-- Calculate our crew level after each waypoint to stop cheating -->
					<set_value name="$iCrewSkill"		exact="@this.combinedskill + @this.ship.defencenpc.combinedskill + @this.ship.engineer.combinedskill"/>
					<set_value name="$iCrewLevel"		exact="1"/>
					<set_value name="$aTradeRetArg"		exact="'NO_TRADE'"/>
					<set_value name="$iUnitPrice"		exact="0ct"/>
					<set_value name="$iVolume"			exact="0"/>
					<!-- set crew level based on crew skills -->
					<do_if value="$iCrewSkill"			min="200" max="249">
						<set_value name="$iCrewLevel"		exact="2"/>
					</do_if>
					<do_if value="$iCrewSkill ge 250">
						<set_value name="$iCrewLevel"		exact="3"/>
					</do_if>
					<!-- debug_text text="'Crew Skill: %1  Crew Level: %2  Number of Waypoints = %3'.[$iCrewSkill, $iCrewLevel, $lWaypoints.count]" filter="scripts_verbose" chance="$iDbgVerb"/ -->
					<!-- Extract our waypoint for analysis -->
					<set_value name="$lWaypoint"		exact="$lWaypoints.{$iWPCount}"/>
					<set_value name="$iWPIndex"			exact="$lWaypoints.{$iWPCount}.{1}"		comment="Index of WP in list"/>
					<set_value name="$bIsWPActive"		exact="$lWaypoints.{$iWPCount}.{2}"		comment="Note that this is an integer value as Lua thinks false=0 is actually true lol"/>
					<set_value name="$oStation"			exact="$lWaypoints.{$iWPCount}.{3}"		comment="Target station"/>
					<set_value name="$iWPType"			exact="$lWaypoints.{$iWPCount}.{4}"		comment="WP Type (buy, sell, fly to etc.) is integer"/>
					<set_value name="$iMinAmount"		exact="$lWaypoints.{$iWPCount}.{6}"		comment="minimum amount worth setting off for"/>
					<set_value name="$iMaxAmount"		exact="$lWaypoints.{$iWPCount}.{7}"		comment="Maximum stored in hold at any given time"/>
					<set_value name="$tWare"			exact="'none'"							comment="default for logging"/>
					<do_if value="$lWaypoints.{$iWPCount}.{5} != {150402,162}"					comment="'None Selected'">
						<set_value name="$tWare"			exact="ware.{$lWaypoints.{$iWPCount}.{5}}"		comment="Needed to coerce the string value back to a ware type"/>
						<set_value name="$iDesiredAmount"	exact="$iMaxAmount - this.ship.cargo.{$tWare}.count" comment="The amount we need to fulfil our maximium load"/>
					</do_if>
					<set_value name="$iPrice"			exact="$lWaypoints.{$iWPCount}.{8}"		comment="Max or Min price depending on whether buying or selling"/>
					<set_value name="$iWPRange"			exact="$lWaypoints.{$iWPCount}.{9}"		comment="Flight range of waypoint relative to home base"/>

					<set_value name="$bIsTradeValid"	exact="false"							comment="Set this to true only if we are to perform our traderun"/>
					<set_value name="$lTradeOffer"		exact="'none'"							comment="Holder for our return from get offer script"/>
					<set_value name="$iActualAmount"	exact="0"								comment="The actual amount we are going to trade"/>
					
					<set_value name="$tFlyingTime"		exact="0s"/>
					<set_value name="$iCaptainsWage"	exact="0ct"/>
					<set_value name="$iDefenceWage"		exact="0ct"/>
					<set_value name="$iEngineerWage"	exact="0ct"/>
					<set_value name="$iXPoints"			exact="0"/>

					<!-- Check our homebase account level -->
					<set_value name="$oHomebase"		exact="$lTradeDetails.{2}"/>
					<!-- debug_text text="'Manager account = %1'.[$oHomebase.controlentity.{entitytype.manager}.money/100ct]" filter="scripts_verbose" chance="$iDbgVerb"/ -->
					<!-- debug_text text="'Ship account = %1'.[this.money/100ct]" filter="scripts_verbose" chance="$iDbgVerb"/ -->

					<!-- Now analyse our waypoint - first check if the waypoint is active -->
					<do_if value="$bIsWPActive lt 1">
						<debug_text text="'Waypoint %1 set to inactive so skipping to next waypoint'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$aTradeRetArg"		exact="'WP_INACTIVE'"/>
					</do_if>
					
					<!-- Check for staff not getting paid -->
					<do_elseif value="$bStaffOnStrike">
						<debug_text text="'Waypoint %1 - staff on strike - didnt get paid for last trip'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<do_if value="$oHomebase.controlentity.{entitytype.manager}.money ge $iAmountOwed">
							<transfer_money from="$oHomebase.controlentity.{entitytype.manager}" to="player.entity" amount="$iAmountOwed"/>
							<reward_player money="- $iAmountOwed"/>
							<set_value name="$bStaffOnStrike"	exact="false"		comment="Back to work!"/>
							<set_value name="$iAmountOwed"		exact="0ct"			comment="Don't owe anything"/>
							<set_value name="$aTradeRetArg"		exact="'WAGES_PAID'"/>
						</do_if>
						<set_value name="$aTradeRetArg"		exact="'NO_WAGES'"/>
					</do_elseif>
						
					<!-- Check that WP is in range for crew skill level -->
					<do_elseif value="$iWPRange gt $iCrewLevel">
						<debug_text text="'Waypoint %1 is out of range for the current crew so skipping'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$aTradeRetArg"		exact="'ERR_RANGE'"/>
					</do_elseif>
						
					<!-- Check here for relation status of target NPC station (covers relation changes that happen after waypoint is set) -->
					<do_elseif value="$oStation.mayattack.{faction.player} == true" comment="Do not fly to stations that have become hostile after their waypoint was set">
						<debug_text text="'Waypoint %1 - Skipping: station is now hostile'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$aTradeRetArg"		exact="'ERR_HOSTILE'"/>
					</do_elseif>
					
					<!-- Now check our waypoint type and act accordingly -->
					<do_elseif value="$iWPType == 1" comment="Type 1 is no action so skip">
						<debug_text text="'Waypoint %1 set to \'no action\' so skipping to next waypoint'.[$iWPCount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$aTradeRetArg"		exact="'WP_INACTIVE'"/>
					</do_elseif>

					<!-- Check for a "fly to" Waypoint -->
					<do_elseif value="$iWPType == 6"															comment="Waypoint is a Fly To waypoint">
						<debug_text text="'Waypoint %1 set to \'Fly To\' %2'.[$iWPCount,$oStation.knownname]"	filter="scripts_verbose" chance="$iDbgVerb"/>
						<do_if value="this.ship.distanceto.[$oStation, position.[0,0,0]] lt 10km"				comment="Range check to prevent this constantly flying about">
							<debug_text text="'Close enough to %1 so no need to move'.[$oStation.knownname]"	filter="scripts_verbose" chance="$iDbgVerb"/>
							<set_value name="$aTradeRetArg"		exact="'WP_FLYTO_NOMOVE'"/>
						</do_if>
						<do_else>
							<!-- Set a trip timer here -->
							<set_value name="$tTripStartTime"		exact="player.age"/>
							<set_value name="$tFlyingTime"			exact="0"/>
							<run_script	name="'move.generic'"		sinceversion="1">
								<param name="destination"			value="$oStation"/>
								<param name="debugchance"			value="$iDbgVerb"/>
							</run_script>
							<set_value name="$tTripEndTime"			exact="player.age"/>
							<set_value name="$tFlyingTime"			exact="$tTripEndTime - $tTripStartTime"/>
							<remove_value name="$tTripStartTime"/>
							<remove_value name="$tTripEndTime"/>
							<debug_text text="'We\'ve arrived at %1 Trip Time was %2'.[$oStation.knownname, $tFlyingTime/1min]" filter="scripts_verbose" chance="$iDbgVerb"/>
							<set_value name="$aTradeRetArg"		exact="'WP_FLYTO'"/>
						</do_else>
					</do_elseif>

					<!-- Check for a Load, Unload, buy, sell or refuel Waypoint -->
					<do_elseif value="$iWPType == 2 or $iWPType == 3 or $iWPType == 4 or $iWPType == 5 or $iWPType == 7" comment="Waypoint is a Load waypoint">
						<debug_text text="'Waypoint %1 set to \'%2\' at %3'.[$iWPCount, $lWPTypeList.{$iWPType}, $oStation.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<debug_text text="'Free space available: %1 - min amount %3 - max amount %4  ware = %2 '.[this.ship.cargo.{$tWare}.free , $tWare, $iMinAmount, $iMaxAmount]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<!-- Perform our trade run -->
						<debug_text text="'Waypoint %1 - Performing Trade'.[$iWPCount]"				filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$bIsTradeValid"		exact="false"						comment="Reset this variable for next waypoint just in case"/>
						<!-- set_value name="$bIsNullSweep"			exact="false"						comment="Got a trade so no need to wait"/ -->
						<set_value name="$tTripStartTime"		exact="player.age"/>
						<set_value name="$tFlyingTime"			exact="0"							comment="Trip timer"/>
						<run_script name="'mt_logistics.trade.ship.perform_run'"					sinceversion="1">
							<param		 name="lWaypoint"		value="$lWaypoint"					comment="Pass waypoint to buy script for offer checking"/>
							<param		 name="DebugLvl"		value="$iDbgVerb"/>
							<save_retval name="RetArg"			variable="$aTradeRetArg"			comment="The result of our trade on return"/>
							<save_retval name="UnitPrice"		variable="$iUnitPrice"				comment="The unit price we traded at"/>
							<save_retval name="Volume"			variable="$iVolume"					comment="The actual volume we ended up trading"/>
						</run_script>
						<!-- Set null sweep counter if trade was a fail -->
						<do_if value="$aTradeRetArg == 'TRADE_SUCCESS'">
							<set_value name="$bIsNullSweep" exact="false"/>
						</do_if>
						<set_value name="$tTripEndTime"			exact="player.age"/>
						<set_value name="$tFlyingTime"			exact="$tTripEndTime - $tTripStartTime"/>
						<remove_value name="$tTripStartTime"/>
						<remove_value name="$tTripEndTime"/>
						<debug_text text="'Waypoint %1 - Completed Trade Script - %2 Round Trip Time %3'.[$iWPCount, $aTradeRetArg, $tFlyingTime/1min]" filter="scripts_verbose" chance="$iDbgVerb"/>
					</do_elseif>

					<!-- Unhandled waypoint type detected-->
					<do_else>
						<debug_text text="'Unhandled Waypoint Type Detected!! %1 - %2'.[$iWPCount,$iWPType]" filter="scripts_verbose" chance="$iDbgVerb"/>
					</do_else>

					<!-- Get cumulative time -->
					<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{2}"	exact="player.age - $tStartTime" operation="add"/>
					<set_value name="$tStartTime"										exact="player.age"/>

					<!-- Salary and XP calculations -->
					<do_if value="$tFlyingTime gt 0s">
						<set_value name="$iSalary"		exact="0ct"						comment="Salary calc"/>
						<set_value name="$iXPoints"		exact="0L"						comment="XP Calc"/>
						<!-- Increment crew salary and XP here based on fly time, volume and commission -->
						<do_if value="$iWPType != 6" comment="Only calculate volume if ware is valid">
							<set_value name="$iCubicMetres" exact="($iVolume * $tWare.volume)LF"/>
						</do_if>
						<do_else>
							<set_value name="$iCubicMetres" exact="0LF"/>
						</do_else>
						<do_if value="$iCrewLevel == 1" comment="Salary and xp for L1 crew">
							<!-- L1 crew gets basic time based salary and time+volume based xp -->
							<set_value name="$iFlightTime" exact="($tFlyingTime/60s)L"/>
							<set_value name="$iSalary" exact="($iFlightTime)Cr*20ct" comment="Salary calc"/>
							<set_value name="$iCommission" exact="0ct"/>
							<set_value name="$iTotalSalary" exact="$iSalary + $iCommission"/>
							<set_value name="$iXPVol" exact="$iCubicMetres / 10.0"/>
							<set_value name="$iXPoints" exact="(($iTotalSalary)L + ($iXPVol)L)/20L" comment="XP Calc"/>
						</do_if>
						<do_if value="$iCrewLevel == 2" comment="Salary and xp for L2 crew">
							<!-- L2 crew gets intermediate salary and time+volume+commission based xp -->
							<set_value name="$iFlightTime" exact="($tFlyingTime/60s)L"/>
							<set_value name="$iSalary" exact="($iFlightTime)Cr*50ct" comment="Salary calc"/>
							<set_value name="$iCommission" exact="0ct"/>
							<set_value name="$iTotalSalary" exact="$iSalary + $iCommission"/>
							<set_value name="$iXPVol" exact="$iCubicMetres / 10.0"/>
							<set_value name="$iXPoints" exact="(($iTotalSalary)L + ($iXPVol)L)/20L" comment="XP Calc"/>
						</do_if>
						<do_if value="$iCrewLevel == 3" comment="Salary and xp for L3 crew">
							<!-- L3 crew gets top salary + 0.5% commission on sales to NPC stations and time+volume+commission based xp -->
							<set_value name="$iFlightTime" exact="($tFlyingTime/60s)L"/>
							<set_value name="$iSalary" exact="($iFlightTime)Cr*100ct" comment="Salary calc"/>
							<do_if value="$iWPType == 5" comment="Sale to NPC station">
								<set_value name="$iCommission" exact="(($iVolume)ct * ($iUnitPrice - $tWare.minprice))/100ct"/>
								<debug_text text="'Waypoint %1 - Crew earned %2 commission volume = %3 unitprice = %4 minprice = %5'.[$iWPCount, $iCommission, $iVolume, $iUnitPrice, $tWare.minprice]" filter="scripts_verbose" chance="$iDbgVerb"/>
								<do_if value="$iCommission lt 0ct">
									<set_value name="$iCommission" exact="0ct"/>
								</do_if>
							</do_if>
							<do_else>
								<set_value name="$iCommission" exact="0ct"/>
							</do_else>
							<set_value name="$iTotalSalary" exact="$iSalary + $iCommission"/>
							<set_value name="$iXPVol" exact="$iCubicMetres / 10.0"/>
							<set_value name="$iXPoints" exact="(($iTotalSalary)L + ($iXPVol)L)/20L" comment="XP Calc"/>
						</do_if>
						<debug_text text="'Waypoint %1 - Crew earned %2 basic %4 commission each and gained %3 XP each Volume %5 UnitPr %6 XP Vol: %7'.[$iWPCount, $iSalary/1Cr, $iXPoints, $iCommission/1Cr, $iVolume, $iUnitPrice, $iXPVol]" filter="scripts_verbose" chance="$iDbgVerb"/>

						<!-- Individual salary apportionments -->
						<!-- Captain - always gets 100% of salary -->
						<do_if value="true">
							<!-- set_value name="$iWageBill" exact="0ct"/ -->
							<set_value name="$iCaptainsWage" exact="$iTotalSalary"/>
							<set_value name="this.$XRCLS.{2}" exact="$tFlyingTime" operation="add"/>
							<set_value name="this.$XRCLS.{3}" exact="$iCaptainsWage" operation="add"/>
							<set_value name="this.$XRCLS.{4}" exact="$iXPoints" operation="add"/>
							<set_value name="this.$XRCLS.{5}" exact="$iXPoints" operation="add" comment="Experience available to spend on training"/>
							<set_value name="$iWageBill" exact="$iCaptainsWage" operation="add"/>
						</do_if>
								
						<!-- DO gets 75% salary -->
						<do_if value="@this.ship.defencenpc.exists" comment="Set values if DO is onboard">
							<set_value name="$iDefenceWage" exact="(($iTotalSalary)f * 0.75)/1ct"/>
							<set_value name="this.ship.defencenpc.$XRCLS.{2}" exact="$tFlyingTime" operation="add"/>
							<set_value name="this.ship.defencenpc.$XRCLS.{3}" exact="$iDefenceWage" operation="add"/>
							<set_value name="this.ship.defencenpc.$XRCLS.{4}" exact="$iXPoints" operation="add"/>
							<set_value name="this.ship.defencenpc.$XRCLS.{5}" exact="$iXPoints" operation="add" comment="Experience available to spend on training"/>
							<set_value name="$iWageBill" exact="$iDefenceWage" operation="add"/>
						</do_if>
						<do_else>
							<set_value name="$iDefenceWage" exact="0ct"/>
						</do_else>
						
						<!-- Engineer gets 50% salary -->
						<do_if value="@this.ship.engineer.exists" comment="Set values if DO is onboard">
							<set_value name="$iEngineerWage" exact="(($iTotalSalary)f * 0.5)/1ct"/>
							<set_value name="this.ship.engineer.$XRCLS.{2}" exact="$tFlyingTime" operation="add"/>
							<set_value name="this.ship.engineer.$XRCLS.{3}" exact="$iEngineerWage" operation="add"/>
							<set_value name="this.ship.engineer.$XRCLS.{4}" exact="$iXPoints" operation="add"/>
							<set_value name="this.ship.engineer.$XRCLS.{5}" exact="$iXPoints" operation="add" comment="Experience available to spend on training"/>
							<set_value name="$iWageBill" exact="$iEngineerWage" operation="add"/>
						</do_if>
						<do_else>
							<set_value name="$iEngineerWage" exact="0ct"/>
						</do_else>

						<!-- Set ship stats -->
					
						<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{1}" exact="$tFlyingTime" operation="add"/>
						<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{3}" exact="$iCubicMetres" operation="add"/>
						<do_if value="$iWPType == 2 or $iWPType == 4">
							<!-- Workaround to solve issues with coercion after release -->
							<set_value name="$iTrade" exact="(global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{4})LF"/>
							<set_value name="$iTrade" exact="($iVolume * $iUnitPrice)LF" operation="add"/>
							<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{4}" exact="$iTrade" operation="set"/>
						</do_if>
						<do_else>
							<set_value name="$iTrade" exact="(global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{4})LF"/>
							<set_value name="$iTrade" exact="0LF" operation="add"/>
							<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{4}" exact="$iTrade" operation="set"/>							
						</do_else>
						<debug_text text="'Waypoint %1 - Captain: %2 ,  DO: %3 ,  Engineer:  %4  Total Wage Bill: %5'.[$iWPCount, $iCaptainsWage/1Cr, $iDefenceWage/1Cr, $iEngineerWage/1Cr, $iWageBill/1Cr]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<debug_text text="'Waypoint %1 - Captain cuml: %2 ,  DO cuml: %3 ,  Engineer cuml:  %4'.[$iWPCount, this.$XRCLS.{3}/1Cr, this.ship.defencenpc.$XRCLS.{3}/1Cr, this.ship.engineer.$XRCLS.{3}/1Cr ]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<debug_text text="'Waypoint %1 - Captain XP: %2 ,  DO XP: %3 ,  Engineer XP:  %4'.[$iWPCount, this.$XRCLS.{4}, this.ship.defencenpc.$XRCLS.{4}, this.ship.engineer.$XRCLS.{4}]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<debug_text text="'Waypoint %1 - Ship Stats:  Flying Time %2 - Total Time %3 - Volume %4 - turnover %5'.[$iWPCount, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{1}, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{2}, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{3}, $iTrade]" filter="scripts_verbose" chance="$iDbgVerb"/>
						<remove_value name="$iTrade"/>

						<!-- Log if trade was successful -->
						<do_if value="$aTradeRetArg == 'TRADE_SUCCESS'">
							<!-- [player.age, id(wp-complete = 1), traderetarg, ship, hb, wptype, trade-station, ware, amount, unitprice, captsal, dosal, engsal, XP, flighttime] -->
							<set_value name="$lCapLogMsg" exact="[player.age, 1, $aTradeRetArg, this.ship, $oHomebase, $iWPType, $oStation, $tWare, $iVolume, $iUnitPrice, 
																$iCaptainsWage, $iDefenceWage, $iEngineerWage, $iXPoints, $tFlyingTime, '', $iWPCount]"/>
							<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{7}.{1}" exact="$lCapLogMsg" operation="insert"/>
							<!-- Remove excess trade log entries keep to 100 long -->
							<do_if value="global.$XRCLS.$lTradeShips.{$iShipIndex}.{7}.count gt 100">
								<remove_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{7}.{101}"/>
							</do_if>
						</do_if>
					</do_if>

					<!-- Conditional on Tracking variable in ships log + add 50 entry limit -->
					<set_value name="$bTrack" exact="global.$XRCLS.$lTradeShips.{$iShipIndex}.{14} gt 0"/>
					<set_value name="$lLogEntry" exact="[]"/>
					<!-- do_if value="$bTrack" -->
						<set_value name="$idx" exact="1" operation="add"/>
						<set_value name="$lLogEntry" exact="[player.age, 2, $aTradeRetArg, this.ship, $oHomebase, $iWPType, $oStation, $tWare, $iVolume, $iUnitPrice, 
															$iCaptainsWage, $iDefenceWage, $iEngineerWage, $iXPoints, $tFlyingTime, $idx, $iWPCount]"/>
						<set_value name="this.$XRCLS.{6}.{1}" exact="$lLogEntry" operation="insert" comment="Track log entry"/>
						<do_if value="this.$XRCLS.{6}.count gt 50">
							<remove_value name="this.$XRCLS.{6}.{51}" comment="Keep the list at 50 entries long"/>
						</do_if>
					<!-- /do_if -->
					<remove_value name="$bTrack"/>
					<remove_value name="$lLogEntry"/>

					<debug_text text="'Waypoint %1 - Captain XP: %2 ,  DO XP: %3 ,  Engineer XP:  %4'.[$iWPCount, this.$XRCLS.{4}, this.ship.defencenpc.$XRCLS.{4}, this.ship.engineer.$XRCLS.{4}]" filter="scripts_verbose" chance="$iDbgVerb"/>
					<debug_text text="'Waypoint %1 - Ship Stats:  Flying Time %2 - Total Time %3 - Volume %4 - turnover %5'.[$iWPCount, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{1}, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{2}, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{3}, global.$XRCLS.$lTradeShips.{$iShipIndex}.{9}.{4}]" filter="scripts_verbose" chance="$iDbgVerb"/>

					<!-- Increment our waypoint counter -->
					<set_value name="$iWPCount" operation="add" comment="Increment by 1"/>
					<set_value name="$lWaypoints" exact="$lTradeDetails.{4}" comment="Get our list of waypoints again in case it's been updated"/>
					
					<!-- debug level switchable delay -->
					<do_if value="$bShipDbg gt 3">
						<set_value name="$iWPDelay" exact="5s"/>
					</do_if>
					<do_else>
						<set_value name="$iWPDelay" exact="25s - (3s * (this.skill.navigation)s)"/>
					</do_else>
					<wait exact="$iWPDelay" sinceversion="1" comment="Set this wait time based on crew skills"/>
				</do_while>

				<do_if value="$bShipDbg gt 3">
					<set_value name="$iWPDelay" exact="10s"/>
				</do_if>
				<do_else>
					<set_value name="$iWPDelay" exact="110s - (15s * (this.skill.navigation)s)"/>
				</do_else>
				<wait exact="$iWPDelay" sinceversion="1" comment="Set this wait time based on crew skills"/>

				<!-- Pay wages - Subtract total from station account here and deal with not being able to pay -->
				<!-- Add delay here so that wages are only paid every 30 minutes -->
				<do_if value="$oHomebase.controlentity.{entitytype.manager}.money ge $iWageBill and not $bStaffOnStrike">
					<set_value name="$bStaffOnStrike" exact="false"/>
					<do_if value="(player.age - $tLastWageRun) gt 1800s" comment="Pay wages every 30 mins">
						<do_if value="$iWageBill gt 0ct">
							<debug_text text="'Paying wages for this sweep %1'.[$iWageBill/1Cr]" filter="scripts_verbose" chance="$iDbgVerb"/>
							<transfer_money from="$oHomebase.controlentity.{entitytype.manager}" to="player.entity" amount="$iWageBill"/>
							<reward_player money="- $iWageBill" comment="Workaround as cant find another way to reduce station budget"/>
							<set_value name="$iWageBill" exact="0ct"/>
							<set_value name="$tLastWageRun" exact="player.age"/>
						</do_if>
						<do_else comment="Nothing to pay this time">
							<debug_text text="'Wage bill for this period is zero'" filter="scripts_verbose" chance="$iDbgVerb"/>
						</do_else>
					</do_if>
					<do_else comment="Not time to pay wages yet">
						<debug_text text="'Wage bill %1 is not yet due. Due in %2 minutes'.[$iWageBill/1Cr, (1800s - (player.age - $tLastWageRun))/1min]" filter="scripts_verbose" chance="$iDbgVerb"/>
					</do_else>
				</do_if>
				<do_else comment="Can't pay staff so they go on stop">
					<set_value name="$bStaffOnStrike" exact="true"/>
					<set_value name="$iAmountOwed" exact="$iWageBill"/>
					<set_value name="$iWageBill" exact="0ct"/>
				</do_else>

				<debug_text text="'Is Null Sweep? %1 Null Sweep Counter = %2'.[$bIsNullSweep, $iNullSweepCounter]" filter="scripts_verbose" chance="$iDbgVerb"/>
				<do_if value="$bIsNullSweep">
					<set_value name="$iNullSweepCounter" exact="1" operation="add"/>
					<set_value name="$bIsNullSweep" exact="false" comment="Reset for next sweep"/>
					<debug_text text="'We got a null WP sweep'" filter="scripts_verbose" chance="$iDbgVerb"/>
					<!-- Make sure we undock first so that we don't hog a docking slot - only do this on a null sweep so we don't undock if two trades at the same station -->
					<do_if value="this.ship.parkedat.exists" comment="If we are parked">
						<debug_text text="'We got a null WP sweep so undock'" filter="scripts_verbose" chance="$iDbgVerb"/>
						<run_script name="'move.unpark'" sinceversion="1"/>					
					</do_if>
					<do_if value="$iNullSweepCount ge 5">
						<debug_text text="'Longer wait due to 5 null sweeps of the waypoint list'" filter="scripts_verbose" chance="$iDbgVerb"/>
						<set_value name="$iNullSweepCounter" exact="0"/>
						<!-- debug level switchable delay -->
						<do_if value="$bShipDbg gt 3">
							<set_value name="$iWPDelay" exact="10s"/>
						</do_if>
						<do_else>
							<set_value name="$iWPDelay" exact="300s - (50s * (this.skill.navigation)s)"/>
						</do_else>
						<wait exact="$iWPDelay" sinceversion="1" comment="Set this wait time based on crew skills"/>
						<!-- Fly back to homebase here to avoid possibility of hanging about in dangerous space for too long -->
						<set_value name="$aTradeRetArg"		exact="'WP_NULLSWEEP_FLYING'"/>
						<set_value name="$bTrack" exact="global.$XRCLS.$lTradeShips.{$iShipIndex}.{14} gt 0"/>
						<set_value name="$lLogEntry" exact="[]"/>
						<!-- do_if value="$bTrack" -->
							<set_value name="$idx" exact="1" operation="add"/>
							<set_value name="$lLogEntry" exact="[player.age, 2, $aTradeRetArg, this.ship, $oHomebase, $iWPType, $oStation, $tWare, $iVolume, $iUnitPrice, 
															$iCaptainsWage, $iDefenceWage, $iEngineerWage, $iXPoints, $tFlyingTime, $idx, $iWPCount]"/>
							<set_value name="this.$XRCLS.{6}.{1}" exact="$lLogEntry" operation="insert" comment="Track log entry"/>
							<do_if value="this.$XRCLS.{6}.count gt 50">
								<remove_value name="this.$XRCLS.{6}.{51}" comment="Keep the list at 50 entries long"/>
							</do_if>
						<!-- /do_if -->
						<remove_value name="$bTrack"/>
						<remove_value name="$lLogEntry"/>
						<debug_text text="'Null sweep timeout - flying back to homebase'" filter="scripts_verbose" chance="$iDbgVerb"/>
						<do_if value="this.ship.distanceto.[$oHomebase, position.[0,0,0]] lt 10km" comment="Range check to prevent this constantly flying about">
							<debug_text text="'Close enough to Homebase %1 so no need to move'.[$oHomebase.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
							<set_value name="$aTradeRetArg"		exact="'WP_NULLSWEEP_NOFLY'"/>
						</do_if>
						<do_else>
							<run_script name="'move.generic'" sinceversion="1">
								<param name="destination" value="$oHomebase"/>
								<param name="debugchance" value="$iDbgVerb"/>
							</run_script>
							<debug_text text="'We\'ve arrived at Homebase %1'.[$oHomebase.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
							<set_value name="$aTradeRetArg"		exact="'WP_NULLSWEEP_FLY'"/>
						</do_else>
						<!-- Conditional on Tracking variable in ships log + add 50 entry limit -->
						<set_value name="$bTrack" exact="global.$XRCLS.$lTradeShips.{$iShipIndex}.{14} gt 0"/>
						<set_value name="$lLogEntry" exact="[]"/>
						<!-- do_if value="$bTrack" -->
							<set_value name="$idx" exact="1" operation="add"/>
							<set_value name="$lLogEntry" exact="[player.age, 2, $aTradeRetArg, this.ship, $oHomebase, $iWPType, $oStation, $tWare, $iVolume, $iUnitPrice, 
															$iCaptainsWage, $iDefenceWage, $iEngineerWage, $iXPoints, $tFlyingTime, $idx, $iWPCount]"/>
							<set_value name="this.$XRCLS.{6}.{1}" exact="$lLogEntry" operation="insert" comment="Track log entry"/>
							<do_if value="this.$XRCLS.{6}.count gt 50">
								<remove_value name="this.$XRCLS.{6}.{51}" comment="Keep the list at 50 entries long"/>
							</do_if>
						<!-- /do_if -->
						<remove_value name="$bTrack"/>
						<remove_value name="$lLogEntry"/>
					</do_if>
				</do_if>
				<do_else comment="No null sweep so carry on">
					<set_value name="$iNullSweepCounter" exact="0"/>
				</do_else>
			<!-- Ends main loop -->
			</do_while>
		</actions>
	</attention>

	<on_abort>
		<!-- TODO: Check do we need to clean up our variables here?? -->
		<debug_text text="'Stopped running script for ship %1'.[$oShip.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
		<set_value name="this.$XRCLS.{6}" exact="[]" operation="set" comment="Track log entry delete"/>
		<do_if value="this.ship.exists and this.ship.isoperational" comment="Reporting hook">
			<set_value name="$aTradeRetArg" exact="{150402,451}"/>
			<set_value name="$lCapLogMsg" exact="[player.age, 1, $aTradeRetArg, this.ship, $oHomebase, $iWPType, $oStation, $tWare, $iVolume, $iUnitPrice, 
															$iCaptainsWage, $iDefenceWage, $iEngineerWage, $iXPoints, $tFlyingTime, '', $iWPCount]"/>
			<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{7}.{1}" exact="$lCapLogMsg" operation="insert"/>
		</do_if>
		<do_else>
			<debug_text text="'Ship is dead %1'.[$oShip.knownname]" filter="scripts_verbose" chance="$iDbgVerb"/>
			<set_value name="$aTradeRetArg" exact="{150402,452}"/>
			<set_value name="$lCapLogMsg" exact="[player.age, 1, $aTradeRetArg, this.ship, $oHomebase, $iWPType, $oStation, $tWare, $iVolume, $iUnitPrice, 
															$iCaptainsWage, $iDefenceWage, $iEngineerWage, $iXPoints, $tFlyingTime, '', $iWPCount]"/>
			<set_value name="global.$XRCLS.$lTradeShips.{$iShipIndex}.{7}.{1}" exact="$lCapLogMsg" operation="insert"/>
		</do_else>
	</on_abort>
</aiscript>
<?xml version="1.0" encoding="utf-8"?>
<diff>
	<add sel="/aiscript/attention/actions/do_all/set_value[@name='$subordinate']" pos="after">
		<!-- Stops the newly appointed manager assigning CLS ships to normal station duty -->
		<debug_text  text="'MT Logistics trade.station.player vanilla script patch - subordinate %1'.[$subordinate.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />
		<do_if value="@$subordinate.pilot.$XRCLS and @$subordinate.pilot.$XRCLS.{1} == true">
			<debug_text  text="'Manager Ignoring Ship - %1 as it is a CLS Ship'.[$subordinate.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />
			<continue />
		</do_if>
	</add>
</diff>
<?xml version="1.0" encoding="utf-8"?>
<!-- MT Station Logistics -->
<!-- Version 1.03 - 2015-01-30 -->
<!-- This MD script handles the main functions and admin of the mod -->
<!--  mdscript name="XRCLS" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd" -->
<mdscript name="XRCLS" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="C:\Users\andy\Dropbox (Personal)\Games\XRebirth\modwip\Resources\md.xsd">
	<cues>
		<!-- Initialise the mod on game start and on a new game -->
		<cue name="Initialise" instantiate="false" namespace="this">
			<conditions>
				<check_any>
					<!-- Will fire once on every game load, but not on new game -->
					<event_player_created />
					<!-- Will fire as long as game is less than 20 seconds old -->
					<event_cue_signalled cue="md.Setup.GameStart" />
				</check_any>
			</conditions>
			<actions>
				<!-- Set the mod name "MT Station Logitics" -->
				<set_value name="$sName" exact="{150402,1}" />

				<!-- Version number -->
				<set_value name="$iMajVer" exact="1" />
				<set_value name="$iMinVer" exact="0" />
				<set_value name="$iBugfixVer" exact="9" />
        
				<!-- Create a mod config descriptors container if it doesn't exist -->
				<do_if value="not global.$XRCLS?">
					<create_cue_actor name="$dConfig" cue="md.XRCLS.DescriptorsContainer" />
					<set_value name="global.$XRCLS" exact="$dConfig" />
				</do_if>
				<do_else>
					<!-- It does exist so load it -->
					<set_value name="$dConfig" exact="global.$XRCLS" />
				</do_else>
				
				<!-- Mod debug level -->
				<!-- Set the global debug level here (0 - Error; 1 - Info; 2 - Fine; 3 - Finest) -->
				<set_value name="$dConfig.$iDebugLevel" exact="0" />
				<debug_text text="{150402,9994}.[$sName,$dConfig.$iDebugLevel]" filter="scripts_verbose" chance="100 * ($dConfig.$iDebugLevel ge 1)" />
			
				<!-- Signal the initialisation cue -->
				<signal_cue_instantly cue="md.XRCLS.GenericInit" param="[$sName,$dConfig,$iMajVer,$iMinVer,$iBugfixVer]" />

				<!-- Initialise various lists used in the mod -->
				<do_if value="not global.$XRCLS.$lTradeShips?">
					<set_value name="global.$XRCLS.$lTradeShips" exact="[]"/>			<!-- Add a new empty trader fleet list -->
				</do_if>

				<do_if value="not global.$XRCLS.$lAdminLog?">
					<set_value name="global.$XRCLS.$lAdminLog" exact="[]"/>				<!-- Add a new empty admin log list -->
				</do_if>

				<!-- THESE TO BE DEPRACATED -->
				<do_if value="not global.$XRCLS.$lActiveTradeShips?">					<!-- Add a check for first time initialisation of the trader list -->
					<set_value name="global.$XRCLS.$lActiveTradeShips" exact="[]"/>		<!-- Add a new empty trader fleet list -->
				</do_if>
				<do_if value="not global.$XRCLS.$lInactiveTradeShips?">					<!-- Add a check for first time initialisation of the inactive trader list -->
					<set_value name="global.$XRCLS.$lInactiveTradeShips" exact="[]"/>	<!-- Add a new empty inactive trader fleet list -->
				</do_if>
				<!-- THESE TO BE DEPRACATED -->


				<do_if value="not global.$XRCLS.$lConfiguredNPCs?">						<!-- Check if we have a list of configured NPCs set up -->
					<set_value name="global.$XRCLS.$lConfiguredNPCs" exact="[]"/>		<!-- Add one if not -->
				</do_if>
				<do_if value="not global.$XRCLS.$lExpandStates?">
					<set_value name="global.$XRCLS.$lExpandStates" exact="[[],[]]"/>			<!-- Add a check for first time initialisation of the menu expand states -->
					<set_value name="global.$XRCLS.$lExpandStates.{1}" exact="[0, 0, [null, null]]"/>	<!-- Add a new closed list for the ship select menu -->
					<set_value name="global.$XRCLS.$lExpandStates.{2}" exact="[null, null]"/>			<!-- Add a new closed list for the Reports menu -->
				</do_if>

				<!-- DEPRACATE: Log to be in trader variable. set up list for trader logging -->
				<do_if value="not global.$XRCLS.$lTraderLog?">
					<set_value name="global.$XRCLS.$lTraderLog" exact="[]"/>
				</do_if>
				<!-- DEPRACATE -->
				
				<!-- Finally, we reset the cue so that it will trigger again on next game load -->
				<reset_cue cue="this" />
			</actions>
		</cue>	

		<!--	Generic mod initialisation cue.
				It expects parameters in the following form:
				event.param.{1} - name of the mod
				event.param.{2} - the config container of the mod
				event.param.{3} - major version number
				event.param.{4} - minor version number
				event.param.{5} - bugfix version number
		-->
		<cue name="GenericInit" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled />
			</conditions>
			<actions>
				<set_value name="$sName" exact="event.param.{1}" />
				<set_value name="$dConfig" exact="event.param.{2}" />

				<!-- Library version number -->
				<set_value name="$iMajVer" exact="event.param.{3}" />
				<set_value name="$iMinVer" exact="event.param.{4}" />
				<set_value name="$iBugfixVer" exact="event.param.{5}" />
				<set_value name="$sVersion" exact="'%1.%2.%3'.[$iMajVer, $iMinVer, $iBugfixVer]" />

				<set_value name="$sInstallMsg" exact="@event.param.{6}" />
				<set_value name="$sUpgradeMsg" exact="@event.param.{7}" />

				<!-- Check for version -->
				<do_if value="not $dConfig.$iMajVer?">
					<!-- Write first time installation message to logbook -->
					<write_to_logbook category="general" text="{150402,9997}.[$sName,$sVersion,'']" />
          
					<!-- If an additional installation message was provided, we notify the user -->
					<set_value name="$sCustomMsg" exact="''" />
					<do_if value="$sInstallMsg != null">
						<set_value name="$sCustomMsg" exact="{150402,9992}" />
						<write_to_logbook category="general" text="$sInstallMsg" />
					</do_if>
	
					<!-- Display the message in the center of the screen -->
					<set_value name="$sMsg" exact="{150402,9997}.[$sName,$sVersion,$sCustomMsg]" />
					<show_help force="true" custom="$sMsg" duration="5s" />
				</do_if>

				<!-- Trigger update actions here -->
				<do_elseif value="$dConfig.$iMajVer lt $iMajVer or $dConfig.$iMinVer lt $iMinVer or $dConfig.$iBugfixVer lt $iBugfixVer">
					<!-- Write upgrade message to logbook -->
					<write_to_logbook category="general" text="{150402,9998}.[$sName,$dConfig.$sVersion,$sVersion,'']" />

					<!-- v1.03 - Update the  expand state list  to patch previous games to v1.03 -->		
					<do_if value="$dConfig.$iMajVer lt 2 and $dConfig.$iMinVer lt 1 and $dConfig.$iBugfixVer lt 3">
 						<set_value name="global.$XRCLS.$lExpandStates" exact="[[],[]]"/>			<!-- Add a check for first time initialisation of the menu expand states -->
						<set_value name="global.$XRCLS.$lExpandStates.{1}" exact="[0, 0, [null, null]]"/>	<!-- Add a new closed list for the ship select menu -->
						<set_value name="global.$XRCLS.$lExpandStates.{2}" exact="[null, null]"/>			<!-- Add a new closed list for the Reports menu -->
					</do_if>

					<!-- v1.07 fix length of ship log messages -->
					<do_if value="$dConfig.$iMajVer lt 2 and $dConfig.$iMinVer lt 1 and $dConfig.$iBugfixVer lt 7">
						<do_all exact="global.$XRCLS.$lTradeShips.count" counter="$i">
							<do_while value="global.$XRCLS.$lTradeShips.{$i}.{7}.count gt 100">
								<remove_value name="global.$XRCLS.$lTradeShips.{$i}.{7}.{global.$XRCLS.$lTradeShips.{$i}.{7}.count}"/>
								<!-- debug_text text="'Removed value %1 at index %2'.[$i, global.$XRCLS.$lTradeShips.{$i}.{7}.count]"/ -->
							</do_while>
						</do_all>
					</do_if>


						<!-- If an additional update message was provided, notify the user -->
					<set_value name="$sCustomMsg" exact="''" />
					<do_if value="$sUpgradeMsg != null">
						<set_value name="$sCustomMsg" exact="{150402,9992}" />
						<write_to_logbook category="general" text="$sUpgradeMsg" />
					</do_if>
          
					<!-- Display the message in the center of the screen -->
					<set_value name="$sMsg" exact="{150402,9998}.[$sName,$dConfig.$sVersion,$sVersion,$sCustomMsg]" />
					<show_help force="true" custom="$sMsg" duration="10s" />
				</do_elseif>
				<do_elseif value="$dConfig.$iMajVer gt $iMajVer or $dConfig.$iMinVer gt $iMinVer or $dConfig.$iBugfixVer gt $iBugfixVer">
					<!-- Show warning for downgrade -->
					<show_help force="true" custom="{150402,9996}.[$sName,$dConfig.$sVersion,$sVersion]" duration="5s" />
					<write_to_logbook category="general" text="{150402,9996}.[$sName,$dConfig.$sVersion,$sVersion]" />
				</do_elseif>

				<!-- Save the version to the config container -->
				<set_value name="$dConfig.$iMajVer" exact="$iMajVer" />
				<set_value name="$dConfig.$iMinVer" exact="$iMinVer" />
				<set_value name="$dConfig.$iBugfixVer" exact="$iBugfixVer" />
				<set_value name="$dConfig.$sVersion" exact="$sVersion" />
				
				<!-- Turn this on and off using debug level < 1 -->
				<write_to_logbook category="general" text="{150402,9993}.[$sName,$dConfig.$sVersion]" chance="100 * ($dConfig.$iDebugLevel ge 1)" />
				<show_help force="true" custom="{150402,9993}.[$sName,$dConfig.$sVersion]" duration="5s" chance="100 * ($dConfig.$iDebugLevel ge 1)" />
        
				<!-- Reset the cue for clean-up -->
				<reset_cue cue="this" />
			</actions>
		</cue>

		<!-- 	Generic cue to handle un-installation of mods. -->
		<cue name="GenericUninst" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled />
			</conditions>
			<actions>
				<set_value name="$sName" exact="event.param.{1}" />
				<set_value name="$dConfig" exact="event.param.{2}" />
				<set_value name="$iMajVer" exact="$dConfig.$iMajVer" />
				<set_value name="$iMinVer" exact="$dConfig.$iMinVer" />
				<set_value name="$iBugfixVer" exact="$dConfig.$iBugfixVer" />
				<set_value name="$sVersion" exact="'%1.%2.%3'.[$iMajVer,$iMinVer,$iBugfixVer]" />

				<set_value name="$sUninstallMsg" exact="@event.param.{3}" />
        
				<!-- Write uninstallation message to logbook -->
				<write_to_logbook category="general" text="{150402,9995}.[$sName,$sVersion,'']" />

				<!-- If an additional installation message was provided, we notify the user -->
				<set_value name="$sCustomMsg" exact="''" />
				<do_if value="$sUninstallMsg != null">
					<set_value name="$sCustomMsg" exact="{150402,9992}" />
					<write_to_logbook category="general" text="$sUninstallMsg" />
				</do_if>

				<!-- Lastly, we display the message in the center of the screen -->
				<debug_text filter="scripts_verbose" text="'Uninstalling MT Mod Library - version %1...'.[$sVersion]" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)" />
				<set_value name="$sMsg" exact="{150402,9995}.[$sName,$sVersion,$sCustomMsg]" />
				<show_help force="true" custom="$sMsg" duration="10s" />
			</actions>
		</cue>

		<!-- 	Cue to uninstall the Mod -->
		<cue name="Uninstall" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled />
			</conditions>
			<actions>
				<signal_cue_instantly cue="md.XRCLS.GenericUninst" param="[{150402,1},global.$XRCLS]" />
				<!-- stop all trading ships -->
				<do_all exact="global.$XRCLS.$lTradeShips.count" counter="$i">
					<do_if value="global.$XRCLS.$lTradeShips.{$i}.{8} gt 0">
						<signal_cue_instantly cue="md.Manage_MT_Logistics.StopCLStrader" param="global.$XRCLS.$lTradeShips.{$i}"/>
						<debug_text text="'Stopping ship %1'.[global.$XRCLS.$lTradeShips.{$i}.{1}.knownname]" filter="error" chance="100 * (global.$XRCLS.$iDebugLevel ge 0)" />
					</do_if>
				</do_all>
				<!-- Remove stuff from NPCs -->
				<do_all exact="global.$XRCLS.$lConfiguredNPCs.count" counter="$i">
					<set_value name="$eEntity" exact="global.$XRCLS.$lConfiguredNPCs.{$i}"/>
					<remove_value name="$eEntity.$XRCLS"/>
					<debug_text text="'Removing variable from %1'.[$eEntity.knownname]" filter="error" chance="100 * (global.$XRCLS.$iDebugLevel ge 0)" />
				</do_all>
				<remove_cue_actor actor="global.$XRCLS" cue="md.XRCLS.DescriptorsContainer" />
				<remove_value name="global.$XRCLS" />
			</actions>
		</cue>

		<!--	Cue to create descriptors for a given entity. Descriptors are represented
				by creating a virtual actor and using its blackboard to store the values. -->
		<cue name="DescriptorsFactory" instantiate="true" namespace="this">
			<conditions>
				<event_object_signalled object="player.primaryship" param="'XRCLS_CreateDescriptor'" />
			</conditions>
			<actions>
				<set_value name="$oEntity" exact="event.param2" />
				<debug_text text="'Creating descriptors for entity \'%1\'...'.[$oEntity.knownname]" filter="error" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />

				<create_cue_actor name="$dDesc" cue="DescriptorsContainer" />

				<!-- Set the result -->
				<set_value name="$oEntity.$dXRCLS_CreateDescriptorResult" exact="$dDesc" />
			</actions>
		</cue>
	
		<!--	Cue to dispose a given descriptor/virtual actor. -->
		<cue name="DescriptorsDisposer" instantiate="true" namespace="this">
			<conditions>
				<event_object_signalled object="player.primaryship" param="'XRCLS_DisposeDescriptor'" />
			</conditions>
			<actions>
				<set_value name="$dDesc" exact="event.param2" />
				<debug_text text="'Disposing descriptor/virtual actor \'%1\'...'.[$dDesc.knownname]" filter="error" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />
				<remove_cue_actor cue="DescriptorsContainer" actor="$dDesc" />
			</actions>
		</cue>

		<!-- 	This cue is responsible for storing all created descriptors globally. -->
		<cue name="DescriptorsContainer" instantiate="false" namespace="static">
			<conditions>
				<check_any>
					<!-- Will fire once on every game load, but not on new game -->
					<event_player_created />
					<!-- Will fire as long as game is less than 20 seconds old -->
					<event_cue_signalled cue="md.Setup.GameStart" />
				</check_any>
			</conditions>
		</cue>
	
	</cues>
</mdscript>
<?xml version="1.0" encoding="utf-8"?>
<!-- MT Station Logistics -->
<!-- Version 1.0 - 2015-01-10 -->
<!-- This MD script handles interaction with player ships assigned to CLS duty -->
<!-- mdscript name="Manage_MT_Logistics" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd" -->
<mdscript name="Manage_MT_Logistics" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="C:\Users\andy\Dropbox (Personal)\Games\XRebirth\modwip\Resources\md.xsd">
	<cues>
		<!-- This cue starts a ship trading -->
		<cue name="StartCLStrader" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled/>
			</conditions>
			<actions>
				<set_value name="$lTradeDetails" exact="event.param"/>
				<set_value name="$oShip" exact="$lTradeDetails.{1}"/>
				<set_value name="$oHomebase" exact="$lTradeDetails.{2}"/>
				<debug_text text="'Fired cue to start trading with ship %1'.[$oShip.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				<!-- Get station commander and set our ship to be assigned to the homebase station -->
				<set_value name="$oManager" exact="$oHomebase.controlentity.{entitytype.manager}"/>

				<set_value name="$eCaptain" exact="$oShip.pilot"/>
				<!-- Mark our Captain as a current XRCLS captain so that a new station manager knows to ignore the ship -->
				<!-- We mark the npc so that we can save their individual progress for promotion etc -->
				<do_if value="@$eCaptain">
					<do_if value="not $eCaptain.$XRCLS?">														<!-- Check if Captain is already configured -->
						<set_value name="$eCaptain.$XRCLS" exact="[true, 0s, 0ct, 0L, 0L,[]]"/>				<!-- Not configured so add a new configuration record -->
						<!-- [active(boolean), hours logged(int), salary(int), experience(int), xp not spent, log(list) -->
						<!-- Now add our captain to our list of configured NPCs -->
						<append_to_list name="global.$XRCLS.$lConfiguredNPCs" exact="$eCaptain"/>
					</do_if>
					<do_else>																					<!-- Already configured so just set to active -->
						<set_value name="$eCaptain.$XRCLS.{1}" exact="true" operation="set"/>
					</do_else>
				</do_if>

				<set_value name="$eDefenceOfficer" exact="$oShip.defencenpc"/>
				<!-- Mark our Defence Officer as a current XRCLS DO -->
				<!-- We mark the npc so that we can save their individual progress for promotion etc -->
				<do_if value="@$eDefenceOfficer">
					<do_if value="not $eDefenceOfficer.$XRCLS?">												<!-- Check if DO is already configured -->
						<set_value name="$eDefenceOfficer.$XRCLS" exact="[true, 0s, 0ct, 0L, 0L,[]]"/>		<!-- Not configured so add a new configuration record -->
						<!-- [active(boolean), hours logged(int), salary(int), experience(int), xp not spent, log(list) -->
						<!-- Now add our DO to our list of configured NPCs -->
						<append_to_list name="global.$XRCLS.$lConfiguredNPCs" exact="$eDefenceOfficer"/>
					</do_if>
					<do_else>																					<!-- Already configured so just set to active -->
						<set_value name="$eDefenceOfficer.$XRCLS.{1}" exact="true" operation="set"/>
					</do_else>
				</do_if>

				<set_value name="$eEngineer" exact="$oShip.engineer"/>
				<!-- Mark our engineer as a current XRCLS engineer -->
				<!-- We mark the npc so that we can save their individual progress for promotion etc -->
				<do_if value="@$eEngineer">
					<do_if value="not $eEngineer.$XRCLS?">
						<!-- Check if Engineer is already configured -->
						<set_value name="$eEngineer.$XRCLS" exact="[true, 0s, 0ct, 0L, 0L,[]]"/>
						<!-- Not configured so add a new configuration record -->
						<!-- [active(boolean), hours logged(int), salary(int), experience(int), xp not spent, log(list) -->
						<!-- Now add our Engineer to our list of configured NPCs -->
						<append_to_list name="global.$XRCLS.$lConfiguredNPCs" exact="$eEngineer"/>
					</do_if>
					<do_else>
						<!-- Already configured so just set to active -->
						<set_value name="$eEngineer.$XRCLS.{1}" exact="true" operation="set"/>
					</do_else>
				</do_if>

				<debug_text text ="'NPC List = %1'.[global.$XRCLS.$lConfiguredNPCs]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />
				<set_object_commander object="$oShip" commander="$oHomebase" type="entitytype.manager"/>
				<share_actor_account actor="$oShip.pilot" otherobject="$oManager" transferto="$oManager"/>
				<!-- Start our trading script here -->
				<start_script name="'mt_logistics.trade.ship'" object="$eCaptain">
					<param name="lTradeDetails" value="$lTradeDetails"/>
				</start_script> 
			</actions>
		</cue>

		<!-- This cue stops a ship trading -->
		<cue name="StopCLStrader" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled/>
			</conditions>
			<actions>
				<set_value name="$oShip" exact="event.param.{1}"/>
				<debug_text text="'Fired cue to stop trading with ship %1'.[$oShip.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				<!-- Set captain to inactive -->
				<set_value name="$eCaptain" exact="$oShip.pilot"/>
				<set_value name="$eDefenceOfficer" exact="$oShip.defencenpc"/>
				<set_value name="$eEngineer" exact="$oShip.engineer"/>
				<do_if value="@$eCaptain">
					<set_value name="$eCaptain.$XRCLS.{1}" exact="false" operation="set"/>
				</do_if>
				<do_if value="@$eDefenceOfficer">
					<set_value name="$eDefenceOfficer.$XRCLS.{1}" exact="false" operation="set"/>
				</do_if>
				<do_if value="@$eEngineer">
					<set_value name="$eEngineer.$XRCLS.{1}" exact="false" operation="set"/>
				</do_if>
				<!-- Remove ship from station command -->
				<remove_object_commander object="$oShip"/>
				<remove_actor_account actor="$oShip.pilot"/>
				<debug_text text ="'NPC List = %1'.[global.$XRCLS.$lConfiguredNPCs]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />
				<!-- Stop Running the script here -->
				<abort_scripts entity="$oShip.pilot"/>
			</actions>
		</cue>

		<!-- This cue updates a ship that is already trading -->
		<cue name="UpdateCLStrader" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled/>
			</conditions>
			<actions>
				<set_value name="$lNewTradeDetails" exact="event.param"/>
				<set_value name="$oShip" exact="event.param.{1}"/>
				<signal_objects object="$oShip" param="'XRCLS_UpdateWaypoints'" param2="$lNewTradeDetails"/>
				<debug_text text="'Fired cue to update ship %1'.[$oShip.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
			</actions>
		</cue>

	</cues>
</mdscript>
<?xml version="1.0" encoding="utf-8"?>
<!-- MT Station Logistics -->
<!-- Version 1.0 - 2014-12-06 -->
<!-- This MD script handles all the side bar menu and detailmonitor driven calls -->
<!-- mdscript name="Menu_MT_Logistics" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd" -->
<mdscript name="Menu_MT_Logistics" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="C:\Users\andy\Dropbox (Personal)\Games\XRebirth\modwip\Resources\md.xsd">
    <cues>
		<!-- Reports menu handler -->
		<cue name="SectionHandler_ReportsMenu" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_next_section sectionprefix="gMT_ReportMenu_"/>
					<event_conversation_returned_to_section sectionprefix="gMT_ReportMenu_"/>
				</check_any>
			</conditions>
			<actions>
				<debug_text text="'MTL - Report Menu: param = %1 - param2 = %2 Expand states = %3'.[event.param, event.param2, event.param2.{4}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				<!-- Return to admin screen -->
				<do_if value="event.param == 'gMT_ReportMenu_back'">
					<!-- Save report menu expand states -->
					<set_value name="global.$XRCLS.$lExpandStates.{2}" exact="event.param2.{4}"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Admin" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_if>

				<!-- Return from ship log screen -->
				<do_elseif value="event.param == 'gMT_ReportMenu_return'">
					<set_value name="$iShipIdx" exact="event.param2.{7}.{10}"/>
					<set_value name="global.$XRCLS.$lTradeShips.{$iShipIdx}.{14}" exact="0"/>
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<debug_text text="'MTL - Report Menu: XRCLS Crew: %1'.[global.$XRCLS.$lConfiguredNPCs]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Reports" param="[event.param2.{4}.{1}, event.param2.{4}.{2}, [], event.param2.{4}, $aReturn.{1}, global.$XRCLS.$lConfiguredNPCs, []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$iShipIdx"/>
				</do_elseif>

				<!-- Return from crew report screens -->
				<do_elseif value="event.param == 'gMT_ReportMenu_returncrew'">
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<debug_text text="'MTL - Report Menu: XRCLS Crew: %1'.[global.$XRCLS.$lConfiguredNPCs]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Reports" param="[event.param2.{4}.{1}, event.param2.{4}.{2}, [], event.param2.{4}, $aReturn.{1}, global.$XRCLS.$lConfiguredNPCs, []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Return admin log report screens -->
				<do_elseif value="event.param == 'gMT_ReportMenu_returnadmin'">
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<debug_text text="'MTL - Report Menu: XRCLS Admin: %1'.[global.$XRCLS.$lConfiguredNPCs]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Reports" param="[event.param2.{4}.{1}, event.param2.{4}.{2}, [], event.param2.{4}, $aReturn.{1}, global.$XRCLS.$lConfiguredNPCs, []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Toggle ship debug level -->
				<do_elseif value="event.param == 'gMT_ReportMenu_toggleDbg'">
					<set_value name="$oShip" exact="event.param2.{7}.{1}"/>
					<set_value name="$iShipIdx" exact="event.param2.{7}.{10}"/>
					<set_value name="$iNewDbg" exact="event.param2.{3}"/>
					<set_value name="global.$XRCLS.$lTradeShips.{$iShipIdx}.{13}" exact="$iNewDbg"/>
					<debug_text text="'MTL - Report Menu: Debug level: %1'.[global.$XRCLS.$lTradeShips.{$iShipIdx}.{13}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<signal_objects object="$oShip" param="'XRCLS_UpdateShipDbgLvl'" param2="$iNewDbg"/>
					<open_conversation_menu menu="gMT_Station_Logistics_ShipLog" param="[event.param2.{4}.{1}, event.param2.{4}.{2}, [], event.param2.{4}, [], [], global.$XRCLS.$lTradeShips.{$iShipIdx}]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$iShipIdx"/>
					<remove_value name="$iNewDbg"/>
				</do_elseif>

				<!-- Toggle ship tracking level -->
				<do_elseif value="event.param == 'gMT_ReportMenu_toggleTracking'">
					<set_value name="$oShip" exact="event.param2.{7}.{1}"/>
					<set_value name="$iShipIdx" exact="event.param2.{7}.{10}"/>
					<set_value name="$iNewTrk" exact="event.param2.{3}"/>
					<set_value name="global.$XRCLS.$lTradeShips.{$iShipIdx}.{14}" exact="$iNewTrk"/>
					<debug_text text="'MTL - Report Menu: Debug level: %1'.[global.$XRCLS.$lTradeShips.{$iShipIdx}.{14}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<signal_objects object="$oShip" param="'XRCLS_UpdateShipTrkLvl'" param2="$iNewTrk"/>
					<open_conversation_menu menu="gMT_Station_Logistics_ShipLog" param="[event.param2.{4}.{1}, event.param2.{4}.{2}, [], event.param2.{4}, [], [], global.$XRCLS.$lTradeShips.{$iShipIdx}]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$iShipIdx"/>
					<remove_value name="$iNewTrk"/>
				</do_elseif>

				<!-- Update the tracking display -->
				<do_elseif value="event.param == 'gMT_ReportMenu_updateTracking'">
					<set_value name="$iShipIdx" exact="event.param2.{7}.{10}"/>
					<debug_text text="'MTL - Report Menu: Debug level: %1'.[global.$XRCLS.$lTradeShips.{$iShipIdx}.{14}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<open_conversation_menu menu="gMT_Station_Logistics_ShipLog" param="[event.param2.{4}.{1}, event.param2.{4}.{2}, [], event.param2.{4}, [], [], global.$XRCLS.$lTradeShips.{$iShipIdx}]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$iShipIdx"/>
				</do_elseif>

				<!-- Show ship report screen -->
				<do_elseif value="event.param == 'gMT_ReportMenu_shiplog'">
					<set_value name="$lAdminLog" exact="global.$XRCLS.$lAdminLog"/>
					<set_value name="$lParam2" exact="event.param2"/>
					<append_to_list name="$lParam2" exact="$lAdminLog"/>
					<open_conversation_menu menu="gMT_Station_Logistics_ShipLog" param="$lParam2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Show admin log report screen -->
				<do_elseif value="event.param == 'gMT_ReportMenu_adminlog'">
					<set_value name="$lAdminLog" exact="global.$XRCLS.$lAdminLog"/>
					<set_value name="$lParam2" exact="event.param2"/>
					<append_to_list name="$lParam2" exact="$lAdminLog"/>
					<open_conversation_menu menu="gMT_Station_Logistics_AdminLog" param="$lParam2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Train a crew member -->
				<do_elseif value="event.param == 'gMT_ReportMenu_train'">
					<set_value name="$oEntity" exact="event.param2.{3}.{2}"/>
					<set_value name="$tSkillType" exact="skilltype.{event.param2.{5}.{7}}"/>
					<set_value name="$iMoney" exact="(event.param2.{5}.{3})ct"/>
					<set_value name="$iXP" exact="event.param2.{5}.{4}"/>
					<!-- Add the skill -->
					<add_skill entity="$oEntity" type="$tSkillType" exact="1"/>
					<!-- Reduce player cash -->
					<reward_player money="- $iMoney"/>
					<!-- reduce available entity XP to spend -->
					<set_value name="$oEntity.$XRCLS.{5}" exact="$iXP" operation="subtract"/>
					<!-- Return to skills menu -->
					<open_conversation_menu menu="gMT_Station_Logistics_CrewLog" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<!-- Clean up-->
					<remove_value name="$oEntity"/>
					<remove_value name="$tSkillType"/>
					<remove_value name="$iMoney"/>
					<remove_value name="$iXP"/>
				</do_elseif>

				<!-- Rename a crew member -->
				<do_elseif value="event.param == 'gMT_ReportMenu_rename'">
					<open_conversation_menu menu="gMT_Station_Logistics_Rename" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Return from Rename a crew member -->
				<do_elseif value="event.param == 'gMT_ReportMenu_rename_return'">
					<open_conversation_menu menu="gMT_Station_Logistics_CrewLog" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Test increase XP -->
				<do_elseif value="event.param == 'gMT_ReportMenu_testxp'">
					<set_value name="$oEntity" exact="event.param2.{3}.{2}"/>
					<set_value name="$tSkillType" exact="skilltype.{event.param2.{5}.{7}}"/>
					<set_value name="$iMoney" exact="event.param2.{5}.{3}"/>
					<set_value name="$iXP" exact="event.param2.{5}.{4}"/>
					<set_value name="$oEntity.$XRCLS.{4}" exact="1000000" operation="add"/>
					<set_value name="$oEntity.$XRCLS.{5}" exact="1000000" operation="add"/>

					<!-- Return to skills menu -->
					<open_conversation_menu menu="gMT_Station_Logistics_CrewLog" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<!-- Clean up-->
					<remove_value name="$oEntity"/>
					<remove_value name="$tSkillType"/>
					<remove_value name="$iMoney"/>
					<remove_value name="$iXP"/>
				</do_elseif>

				<!-- Crew training/log screen -->
				<do_elseif value="event.param == 'gMT_ReportMenu_crewskills'">
					<open_conversation_menu menu="gMT_Station_Logistics_CrewLog" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>
				
				<!-- Unhandled return event -->
				<do_else>
					<!-- Unhandled section value -->
					<debug_text text="'ERROR: Unhandled Reports menu event: %1'.[event.param]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
				</do_else>

			</actions>			
		</cue>
		
		<!-- Waypoint List menu handler cue -->
		<cue name="SectionHandler_WaypointListMenu" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_returned_to_section sectionprefix="gMT_WPListMenu_"/>
					<event_conversation_next_section sectionprefix="gMT_WPListMenu_"/>
				</check_any>
				<check_value value="global.$XRCLS?" />
			</conditions>
			<actions>
				<debug_text text="'MTL Waypoint List menu: event.param2 = %1'.[event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>

				<!-- Call up the edit waypoint screen -->
				<do_if value="event.param == 'gMT_WPListMenu_editwaypoint'">
					<!-- Save temp parameter? -->
					<set_value name="global.$lTempparam2" exact="event.param2"/>
					<!-- get a list of station products if a station is selected -->
					<set_value name ="$lSelectedStation" exact="event.param2.{7}.{3}"/>
					<set_value name="$lWareList" exact="[]"/>
					<do_if value="@$lSelectedStation.exists">
						<set_value name="$lWareList" exact="[$lSelectedStation.resources.list, $lSelectedStation.products.list, $lSelectedStation.tradewares.list]"/>
					</do_if>
					<debug_text text="'Add/edit a waypoint ep2(4): %1 ep2(5) %2  ep2(6) = %3'.[event.param2.{4}, event.param2.{5}, event.param2.{6}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<!-- debug_text text="'Add/edit a waypoint Toprow = %1 Selrow = %2'.[event.param2.{1}, event.param2.{2}]" filter="scripts_verbose" chance="100"/  -->
					<open_conversation_menu menu="gMT_Station_Logistics_EditWaypoint" param="[0, 0, [], event.param2.{4}, [], event.param2.{6}, event.param2.{7}, $lWareList]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_if>
				
				<!-- deal with return from waypoint edit screen -->
				<do_elseif value="event.param == 'gMT_WPListMenu_return'">
					<!-- Get our return parameters back -->
					<set_value name="$lRet" exact="global.$lTempparam2"/>
					<remove_value name="global.$XRCLS.$tempparam"/>
					<set_value name="$iTopRow" exact="$lRet.{1}"/>
					<set_value name="$iSelRow" exact="$lRet.{2}"/>
					<set_value name="$lRet.{4}.{4}" exact="event.param2.{4}.{4}"/>
					<!-- debug_text text="'Add/edit a waypoint return Toprow = %1 Selrow = %2'.[$iTopRow, $iSelRow]" filter="scripts_verbose" chance="100"/ -->
					<debug_text text="'Done adding/editing waypoint %1'.[$lRet.{4}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<open_conversation_menu menu="gMT_Station_Logistics_ListWaypoints" param="[$iTopRow, $iSelRow, [], $lRet.{4}, [], event.param2.{6}, event.param2.{7}]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$lRet"/>
					<remove_value name="$iTopRow"/>
					<remove_value name="$iSelRow"/>
				</do_elseif>
				
				<!-- Unhandled parameter value -->
				<do_else>
					<debug_text text="'Unhandled Waypoint List menu choice... %1'.[event.param]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				</do_else>
				
			</actions>
		</cue>
		
		<!-- Ship select and configure menu screen handler cue -->
		<cue name="SectionHandler_ShipMenu" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_returned_to_section sectionprefix="gMT_ShipMenu_"/>
					<event_conversation_next_section sectionprefix="gMT_ShipMenu_"/>
				</check_any>
				<check_value value="global.$XRCLS?"/>
			</conditions>
			<actions>
				<!-- Set up some variables -->
				<do_if value="event.param != 'gMT_ShipMenu_back' and event.param != 'gMT_ShipMenu_gothomebase' and event.param != 'gMT_ShipMenu_configreturn' and not @global.$bMapCall">
					<debug_text text="'MTL Ship Menu: Param = %1 - Param2 = %2 Expand state = %3'.[event.param, event.param2, event.param2.{4}.{3}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="global.$bMapCall" exact="false"/>
					<set_value name="$iTopRow" exact="event.param2.{1}"/>
					<set_value name="$iSelRow" exact="event.param2.{2}"/>
					<set_value name="$lExpand" exact="event.param2.{4}.{3}"/>
					<set_value name="$tAction" exact="event.param2.{4}.{4}"/>
					<set_value name="$lTrader" exact="event.param2.{6}"/>
					<set_value name="$oShip" exact="$lTrader.{1}"/>
					<set_value name="$iShip" exact="$lTrader.{10}"/>
				</do_if>
				
				<!-- Add a brand new, never used before ship -->
				<do_if value="event.param == 'gMT_ShipMenu_addship' and not @global.$bMapCall">
					<do_if value="$tAction == 'addship'">
						<debug_text text="'MTL Ship Menu: Ship Data = %1'.[$lTrader]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						<debug_text text="'The new ship selected was:  %1'.[$oShip.knownname]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						<debug_text text="'Trader = %1'.[$lTrader]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						<append_to_list name="global.$XRCLS.$lTradeShips" exact="$lTrader"/>
						<!-- append_to_list name="global.$XRCLS.$lAdminLog" exact="[player.age,'New Trade Ship Added to fleet %1'.[$lTrader.{1}.knownname]]"/ -->
						<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 500}.[$lTrader.{1}.knownname]], null, null]"/>
					</do_if>
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<!-- Open the select ship menu -->
					<debug_text text="'Ship Menu: Expand state = %1'.[$lExpand]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [], [$iTopRow, $iSelRow, $lExpand],  $aReturn.{1}, [], []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$aReturn"/>
				</do_if>

				<!-- Remove the selected ship if requested -->
				<do_elseif value="event.param == 'gMT_ShipMenu_removeship' and not @global.$bMapCall">
					<do_if value="$tAction == 'removeship'">
						<set_value name="$oShipRemove" exact="global.$XRCLS.$lTradeShips.{$iShip}.{1}" comment="for debug text only"/>
						<remove_value name="global.$XRCLS.$lTradeShips.{$iShip}"/>
						<!-- append_to_list name="global.$XRCLS.$lAdminLog" exact="[player.age,'Removed ship from fleet %1'.[$lTrader.{1}.knownname]]"/ -->
						<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 501}.[$lTrader.{1}.knownname]], null, null]"/>
						<debug_text text="'Removed ship: %1 - Global Active: %2'.[$oShipRemove.knownname, global.$XRCLS.$lTradeShips]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					</do_if>
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<!-- Open the select ship menu -->
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [], [$iTopRow, $iSelRow, $lExpand], $aReturn.{1}, [], []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$aReturn"/>
					<remove_value name="$oShipRemove"/>
				</do_elseif>

				<!-- Start a ship trading -->
				<do_elseif value="event.param == 'gMT_ShipMenu_startship' and not @global.$bMapCall">
					<do_if value="event.param2.{4}.{4} == 'startship'">
						<debug_text text="'MTL Ship Menu: Started ship: %1  Ship Index = %2'.[$oShip.knownname, $iShip]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						<set_value name="global.$XRCLS.$lTradeShips.{$iShip}.{8}" exact="1" comment="Now Trading"/>
						<!-- append_to_list name="global.$XRCLS.$lTradeShips.{$iShip}.{7}" exact="[player.age,'Started Trading with ship %1'.[$oShip.knownname]]"/ -->
						<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 502}.[$oShip.knownname]], null, null]"/>
						<!-- Need to trigger our trader script here to start the ship doing something -->
						<signal_cue_instantly cue="md.Manage_MT_Logistics.StartCLStrader" param="global.$XRCLS.$lTradeShips.{$iShip}"/>
					</do_if>
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<!-- Open the select ship menu -->
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [], event.param2.{4}, $aReturn.{1}, event.param2.{6}]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$aReturn"/>
					<remove_value name="$oShipReadd"/>
				</do_elseif>
				
				<!-- Stop a ship from trading -->
				<do_elseif value="event.param == 'gMT_ShipMenu_stopship' and not @global.$bMapCall">
					<do_if value="event.param2.{4}.{4} == 'stopship'">
						<debug_text text="'MTL Ship Menu: Stopped ship: %1  Ship Index %2'.[$oShip.knownname, $iShip]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						<set_value name="global.$XRCLS.$lTradeShips.{$iShip}.{8}" exact="0" comment="Now not Trading"/>
						<!-- append_to_list name="global.$XRCLS.$lTradeShips.{$iShip}.{7}" exact="[player.age,'Stopped Trading with ship %1'.[global.$XRCLS.$lTradeShips.{$iShip}.{1}.knownname]]"/ -->
						<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 503}.[global.$XRCLS.$lTradeShips.{$iShip}.{1}.knownname]], null, null]"/>
						<!-- Stop any XRCLS scripts from running -->
						<signal_cue_instantly cue="md.Manage_MT_Logistics.StopCLStrader" param="global.$XRCLS.$lTradeShips.{$iShip}"/>
					</do_if>
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<!-- Open the select ship menu -->
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [], event.param2.{4}, $aReturn.{1}, event.param2.{6}]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$aReturn"/>
				</do_elseif>
				
				<!-- Configure the ship's waypoints (new screen) -->
				<do_elseif value="event.param == 'gMT_ShipMenu_config' and not @global.$bMapCall">
					<!-- Save our current return value -->
					<set_value name="global.$lTempParam2" exact="event.param2"/>
					<!-- Now get our ship details -->
					<set_value name="$lTrader" exact="event.param2.{6}"/>
					<open_conversation_menu menu="gMT_Station_Logistics_ListWaypoints" param="[0, 0, [], [$iTopRow, $iSelRow, $lExpand, 'fromshipmenu'], [], $lTrader, []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>
				
				<!-- Deal with return from config menu -->
				<do_elseif value="event.param == 'gMT_ShipMenu_configreturn' and not @global.$bMapCall">
					<!-- save our return parameters and restore old value -->
					<debug_text text="'Config return EP2 = %1'.[event.param2]"  filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="$lTrader" exact="event.param2.{6}"/>
					<set_value name="$lRet" exact="global.$lTempParam2"/>
					<remove_value name="global.$lTempParam2"/>
					<set_value name="$iTopRow" exact="$lRet.{1}"/>
					<set_value name="$iSelRow" exact="$lRet.{2}"/>
					<set_value name="$lExpand" exact="$lRet.{4}.{3}"/>
					<set_value name="$tAction" exact="event.param2.{4}.{4}"/>
					<set_value name="$oShip" exact="$lTrader.{1}"/>
					<set_value name="$iShipStatus" exact="$lTrader.{8}"/>
					<set_value name="$iShip" exact="$lTrader.{10}"/>

					<debug_text text="'Ltrader = %1  Action = %2  iShip = %3 Status %4 Debug lvl = %5 Tracking = %6'.[$lTrader, $tAction, $iShip, $iShipStatus, $lTrader.{13}, $lTrader.{14}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>

					<do_if value="$tAction == 'updateship'" comment="Only need to do stuff if our waypoint list changed">
						<do_if value="$iShipStatus gt 0" comment="Our ship is actively trading/mining">
							<do_if value="$lTrader.{4}.count lt 2" comment="Ship is active but has less than 2 waypoints so stop it">
								<set_value name="$lTrader.{8}" exact="0" comment="Make ship Inactive"/>
								<!-- append_to_list name="$lTrader.{7}" exact="[player.age,'Updated Waypoints for ship %1 - ship now has less than two waypoints so stopping'.[$lTrader.{1}.knownname]]"/ -->
								<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 504}.[$lTrader.{1}.knownname]], null, null]"/>
								<!-- Signal the ship to stop trading -->
								<signal_cue_instantly cue="md.Manage_MT_Logistics.StopCLStrader" param="$lTrader"/>
							</do_if>
							<do_else comment="All ok so just update">
								<!-- append_to_list name="$lTrader.{7}" exact="[player.age,'Updated Waypoints for ship %1'.[$lTrader.{1}.knownname]]"/ -->
								<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 505}.[$lTrader.{1}.knownname]], null, null]"/>
								<!-- Signal the ship to update its waypoints -->
								<signal_cue_instantly cue="md.Manage_MT_Logistics.UpdateCLStrader" param="$lTrader"/>
							</do_else>
						</do_if>
						<do_else comment="Ship is not actively trading">
							<!-- append_to_list name="$lTrader.{7}" exact="[player.age,'Updated Waypoints for ship %1'.[$lTrader.{1}.knownname]]"/ -->
							<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 505}.[$lTrader.{1}.knownname]], null, null]"/>
						</do_else>
					</do_if>
					
					<!-- Save trader in the global list -->
					<set_value name="global.$XRCLS.$lTradeShips.{$iShip}" exact="$lTrader"/>
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [], [$iTopRow, $iSelRow, $lExpand], $aReturn.{1}, [], []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<debug_text text="'Returned from waypoint list......'" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<remove_value name="$aReturn"/>
					<remove_value name="$lRet"/>
					<remove_value name="$lTrader"/>
					<remove_value name="$tAction"/>
					<remove_value name="$iShip"/>
					<remove_value name="$oShip"/>
				</do_elseif>

				<!-- Get a player station from the map to use as homebase -->
				<do_elseif value="event.param == 'gMT_ShipMenu_gethomebase' and not @global.$bMapCall">
					<!-- Need to save stuff here? -->
					<set_value name="global.$lTempParam2" exact="event.param2"/>
					<set_value name="global.$bMapCall" exact="true"/>
					<set_value name="$oShip" exact="event.param2.{6}.{1}"/>
					<debug_text text="'MTL Map Call: event.param2 = %1  Passed expand state = %2'.[event.param2, event.param2.{4}.{3}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<!-- open_conversation_menu menu="MapMenu" param="[0, 0, 'zone', player.primaryship.zone, null, null, 'selectplayerobject', ['gMT_ShipMenu_gothomebase', null, false, false, false, true]]"/ -->
					<open_conversation_menu menu="MapMenu" param="[0, 0, 'zone', $oShip.zone, null, null, 'selectplayerobject', ['gMT_ShipMenu_gothomebase', event.object.ship, null, false, false, false, true, null, null, null, null, null, null, null, true]]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>
				
				<!-- Deal with the homebase selected -->
				<do_elseif value="event.param == 'gMT_ShipMenu_gothomebase'">
					<debug_text text="'IN MAP RETURN SECTION.......event.param2 = %1'.[event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="$lRet" exact="global.$lTempParam2"/>
					<set_value name="global.$bMapCall" exact="false"/>
					<remove_value name="global.$lTempParam2"/>
					<set_value name="$iTopRow" exact="$lRet.{1}"/>
					<set_value name="$iSelRow" exact="$lRet.{2}"/>
					<set_value name="$lExpand" exact="$lRet.{4}.{3}"/>
					<set_value name="$tAction" exact="$lRet.{4}.{4}"/>
					<set_value name="$lTrader" exact="$lRet.{6}"/>
					<set_value name="$oShip" exact="$lTrader.{1}"/>
					<set_value name="$iShip" exact="$lTrader.{10}"/>

					<do_if value="event.param2.{4}.{4}?" comment="no homebase selected - Edit our homebase value back into our list">
						<set_value name="$oHome" exact="$lTrader.{2}"/>
					</do_if>
					<do_else>
						<set_value name="$oHome" exact="event.param2.{3}"/>						
						<set_value name="global.$XRCLS.$lTradeShips.{$iShip}.{2}" exact="$oHome"/>
						<!-- append_to_list name="global.$XRCLS.$lTradeShips.{$iShip}.{7}" exact="[player.age,'Added/Updated Homebase for ship %1 to %2'.[$lTrader.{1}.knownname, $oHome.knownname]]"/ -->
						<signal_cue_instantly cue="WriteLog" param="[true, 'admin', [player.age,{150402, 506}.[$lTrader.{1}.knownname, $oHome.knownname]], null, null]"/>
					</do_else>
	
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [],  [$iTopRow, $iSelRow, $lExpand, $tAction], $aReturn.{1}, [], []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<debug_text text="'Got a new homebase...... %1'.[@$oHome.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<remove_value name="$aReturn"/>
					<remove_value name="$oHome"/>
					<remove_value name="$lRet"/>
					<remove_value name="$iTopRow"/>
					<remove_value name="$iSelRow"/>
					<remove_value name="$lExpand"/>
					<remove_value name="$tAction"/>
					<remove_value name="$lTrader"/>
					<remove_value name="$oShip"/>
					<remove_value name="$iShip"/>
				</do_elseif>

				<!-- Return to the admin menu -->
				<do_elseif value="event.param == 'gMT_ShipMenu_back' and not @global.$bMapCall">
					<debug_text text="'MT Ship Menu: Fired the gMT_ShipMenu_back section'" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<!-- Save ship menu expand states -->
					<set_value name="global.$XRCLS.$lExpandStates.{1}" exact="event.param2.{4}"/>
					<!-- Save row info -->
					<open_conversation_menu menu="gMT_Station_Logistics_Admin" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Deal with cancel from map screen -->
				<do_elseif value="global.$bMapCall">
					<debug_text text="'IN MAP CANCEL SECTION.......event.param2 = %1'.[event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="$lRet" exact="global.$lTempParam2"/>
					<set_value name="global.$bMapCall" exact="false"/>
					<remove_value name="global.$lTempParam2"/>
					<set_value name="$iTopRow" exact="$lRet.{1}"/>
					<set_value name="$iSelRow" exact="$lRet.{2}"/>
					<set_value name="$lExpand" exact="$lRet.{4}.{3}"/>
					<set_value name="$tAction" exact="'mapcancel'"/>
					<!-- Sort the ship list out and re-call the ship select menu -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" param="[$iTopRow, $iSelRow, [],  [$iTopRow, $iSelRow, $lExpand, $tAction], $aReturn.{1}, [], []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$aReturn"/>
					<remove_value name="$lRet"/>
					<remove_value name="$iTopRow"/>
					<remove_value name="$iSelRow"/>
					<remove_value name="$lExpand"/>
					<remove_value name="$tAction"/>
				</do_elseif>

				<!-- Unhandled return action -->
				<do_else>
					<debug_text text="'ERROR: Unhandled Ships menu event: %1'.[event.param]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
				</do_else>

				<!-- Clean up some variables -->
				<do_if value="event.param != 'gMT_ShipMenu_back' and event.param != 'gMT_ShipMenu_configreturn' and event.param != 'gMT_ShipMenu_gothomebase' ">
					<remove_value name="$iTopRow"/>
					<remove_value name="$iSelRow"/>
					<remove_value name="$lExpand"/>
					<remove_value name="$tAction"/>
					<remove_value name="$lTrader"/>
					<remove_value name="$oShip"/>
					<remove_value name="$iShip"/>
				</do_if>
				
			</actions>
		</cue>
		
		<!-- Mod Configure menu handler cue -->
		<cue name="SectionHandler_ConfigureMenu" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_next_section sectionprefix="gMT_ConfigMenu_"/>
					<event_conversation_returned_to_section sectionprefix="gMT_ConfigMenu_"/>
				</check_any>
				<check_value value="global.$XRCLS?" />
			</conditions>
			<actions>
				<debug_text text="'MTL - Config Menu: param = %1 - param2 = %2'.[event.param, event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				<!-- Uninstall was selected -->
				<do_if value="event.param == 'gMT_ConfigMenu_uninstall'">
					<debug_text text="'MTL - Config Menu: Uninstall selected....'" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<signal_cue_instantly cue="md.XRCLS.Uninstall" />
				</do_if>

				<!-- Reset all the XCRLS stuff to null-->
				<do_elseif value="event.param == 'gMT_ConfigMenu_reset'">
					<debug_text text="'Reseting all XRCLS lists to null, removing NPC data!!'" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="global.$XRCLS.$lTradeShips" exact="[]"/>
					<set_value name="global.$XRCLS.$lAdminLog" exact="[]"/>
					<set_value name="global.$XRCLS.$lActiveTradeShips" exact="[]"/>
					<set_value name="global.$XRCLS.$lInactiveTradeShips" exact="[]"/>
					<do_all exact="global.$XRCLS.$lConfiguredNPCs.count" counter="$i">
						<set_value name ="$eEntity" exact="global.$XRCLS.$lConfiguredNPCs.{$i}"/>
						<remove_value name="$eEntity.$XRCLS"/>
						<debug_text text="'Entity Removed %1'.[$eEntity.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					</do_all>
					<set_value name="global.$XRCLS.$lConfiguredNPCs" exact="[]"/>
					<set_value name="global.$XRCLS.$lExpandStates" exact="[[],[]]"/>
					<set_value name="global.$XRCLS.$lExpandStates.{1}" exact ="[0, 0, [0, 0]]" operation="set"/>
					<set_value name="global.$XRCLS.$lExpandStates.{2}" exact ="[0, 0, [0, 0, 0]]" operation="set"/>
					<set_value name="global.$XRCLS.$lTraderLog" exact="[]"/>
				</do_elseif>

				<!-- Update the debug level -->
				<do_elseif value="event.param == 'gMT_ConfigMenu_debug-error' or event.param == 'gMT_ConfigMenu_debug-info' or event.param == 'gMT_ConfigMenu_debug-detail' or event.param == 'gMT_ConfigMenu_debug-verbose'">
					<debug_text text="'Changed debug level selected.... %1  %2'.[event.param,event.param2.{3}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="global.$XRCLS.$iDebugLevel" exact="event.param2.{3}" />
					<signal_objects object="player.primaryship" param="'XRCLS_UpdateDebugLevel'"/>
				</do_elseif>

				<!-- unhandled config menu condition -->
				<do_else>
					<debug_text text="'ERROR: Unhandled Config menu event: %1'.[event.param]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
				</do_else>

				<!-- Open the admin main screen -->
				<open_conversation_menu menu="gMT_Station_Logistics_Admin" param="event.param2"/>
				<add_conversation_view view="closeupdetailmonitor"/>
			</actions>
		</cue>

		<!-- Admin menu handler cue -->
		<cue name="SectionHandler_AdminMenu" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_next_section sectionprefix="gMT_Admin_"/>
					<event_conversation_returned_to_section sectionprefix="gMT_Admin_"/>
				</check_any>
				<check_value value="global.$XRCLS?" />
			</conditions>
			<actions>
				<debug_text text="'MTL - Admin Menu: param = %1 - param2 = %2'.[event.param, event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				<!-- Add, edit or remove ships -->
				<do_if value="event.param == 'gMT_Admin_Ship_menu'">
					<!-- Go through our list and update all the crew scores -->
					<signal_cue_instantly cue="UpdateCrewScores"/>
					<!-- Call cue to sanitise ship lists -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<debug_text text="'Got values back %1'.[$aReturn.{1}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<!-- Open the select ship menu -->
					<open_conversation_menu menu="gMT_Station_Logistics_Select_Ship" 
											param="[global.$XRCLS.$lExpandStates.{1}.{1}, 
											global.$XRCLS.$lExpandStates.{1}.{2}, [], global.$XRCLS.$lExpandStates.{1}, $aReturn.{1}, [], []  ]"/>
					<add_conversation_view view="closeupdetailmonitor"/> 
					<remove_value name="$aReturn"/>
					<remove_value name="$iTopRow"/>
					<remove_value name="$iSelRow"/>
				</do_if>
				
				<!-- Open the reports menu screen -->
				<do_elseif value="event.param == 'gMT_Admin_Report_menu'">
					<!-- Call cue to sanitise ship lists -->
					<signal_cue_instantly cue="GetShipLists" param="[this]"/>
					<debug_text text="'Got values back %1'.[$aReturn.{1}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<debug_text text="'MTL - Admin Menu: XRCLS Crew: %1'.[global.$XRCLS.$lConfiguredNPCs]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<!-- open_conversation_menu menu="gMT_Station_Logistics_Configure" param="event.param2"/ -->
					<open_conversation_menu menu="gMT_Station_Logistics_Reports" param="[0, 0, [], global.$XRCLS.$lExpandStates.{2}, $aReturn.{1}, 
																										global.$XRCLS.$lConfiguredNPCs, []]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<remove_value name="$aReturn"/>
				</do_elseif>

				<!-- Configure the mod -->
				<do_elseif value="event.param == 'gMT_Admin_Config_menu'">
					<!-- debug_text text="'Global debug level set to %1'.[global.$XRCLS.$iDebugLevel]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/ -->
					<open_conversation_menu menu="gMT_Station_Logistics_Configure" param="[ 0, 0, [], [event.param2.{1}, event.param2.{2}, global.$XRCLS.$iDebugLevel] ]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>

				<!-- Handle return from config menu -->
				<do_elseif value="event.param == 'gMT_Admin_Config_return'">
					<open_conversation_menu menu="gMT_Station_Logistics_Admin" param="event.param2"/>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_elseif>
				
				<!-- Close the window -->
				<do_elseif value="event.param == 'gMT_Admin_close'">
					<add_conversation_view/>
				</do_elseif>
				
				<!-- Unhandled menu event -->
				<do_else>
					<debug_text text="'ERROR: Unhandled Admin Menu Choice %1'.[event.param]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
				</do_else>
			</actions>
		</cue>

		<!-- Main menu handler cue -->
		<cue name="MenuHandler_MT_Logistics" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_next_section sectionprefix="gMT_Logistics" />
					<event_conversation_returned_to_section sectionprefix="gMT_Logistics" />
				</check_any>
				<check_value value="global.$XRCLS?" />
			</conditions>
			<actions>
				<debug_text text="'MTL - Sidebar Menu: param = %1 - param2 = %2'.[event.param, event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
				<open_conversation_menu menu="gMT_Station_Logistics_Admin" param="event.param2"/>
				<add_conversation_view view="closeupdetailmonitor"/>
				<!-- debug_text text="'Main Menu cue is finished'"/ -->
			</actions>
		</cue>

		<!-- Map Handler cue -->
		<cue name="MapHandler_MT" instantiate="true" namespace="this">
			<conditions>
				<check_any>
					<event_conversation_next_section sectionprefix="gMT_Map_"/>
					<event_conversation_returned_to_section sectionprefix="gMT_Map_"/>
				</check_any>
				<check_value value="global.$XRCLS?"/>
			</conditions>
			<actions>
				<do_if value="event.param == 'gMT_Map_GetStation'">
					<!-- Save our parameters temporarily for return -->
					<set_value name="global.$XRCLS.$mapparam" exact="event.param2"/>
					<set_value name="$oHomebase" exact="event.param2.{6}.{2}"/>
					<!-- Open the map menu with correct selection options -->
					<do_if value="event.param2.{8} == 'npc'">
						<!-- open_conversation_menu menu="MapMenu" param="[0, 0, 'zone', player.primaryship.zone, null, null, 'selectobject', ['gMT_Map_StationSelected', null, false, true]]"/ -->
						<open_conversation_menu menu="MapMenu" param="[0, 0, 'zone', $oHomebase.zone, null, null, 'selectobject', ['gMT_Map_StationSelected', null, false, true]]"/>
					</do_if>
					<do_elseif value="event.param2.{8} == 'player'">
						<!-- open_conversation_menu menu="MapMenu" param="[0, 0, 'zone', player.primaryship.zone, null, null, 'selectplayerobject', ['gMT_Map_StationSelected', null, false, false, false, true]]"/ -->
						<open_conversation_menu menu="MapMenu" param="[0, 0, 'zone', $oHomebase.zone, null, null, 'selectplayerobject', ['gMT_Map_StationSelected', event.object.ship, null, false, false, false, true, null, null, null, null, null, null, null, true]]"/>
					</do_elseif>
					<add_conversation_view view="closeupdetailmonitor"/>
				</do_if>
				
				<do_elseif value="event.param == 'gMT_Map_StationSelected'">
					<!-- Restore our previously saved parameter info -->
						<debug_text text="'event.param2 = %1'.[event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						<set_value name="$lTrader" exact="global.$XRCLS.$mapparam.{6}"/>
						<set_value name="$tAction" exact="global.$XRCLS.$mapparam.{4}.{4}"/>
						<set_value name="$lWaypoint" exact="global.$XRCLS.$mapparam.{7}"/>
						<set_value name="$oOldStation" exact="global.$XRCLS.$mapparam.{7}.{3}"/>
						<remove_value name="global.$XRCLS.$mapparam"/>
						<debug_text text="'Old station = %1'.[$oOldStation]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>

						<do_if value="@event.param2.{4}.{4} == 'addwaypoint'">
							<set_value name="$oSelectedStation" exact="$oOldStation"/>
						</do_if>
						<do_else>
							<set_value name="$oSelectedStation" exact="event.param2.{3}"/>
						</do_else>
					
						<debug_text text="'Station selected value on map return = %1'.[$oSelectedStation]"/>
						<!-- Get ware list for station -->
						<set_value name="$lWareList" exact="[$oSelectedStation.resources.list, $oSelectedStation.products.list, $oSelectedStation.tradewares.list]"/>
						<debug_text text="'MT CLS - Selected Station: %1  Ware List = %2'.[$oSelectedStation.name, $lWareList]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
						<!-- Go back to our waypoint editor map with the station info -->
						<open_conversation_menu menu="gMT_Station_Logistics_EditWaypoint" param="[0, 0, [], [0,0,[0,0],$tAction], [], $lTrader, $lWaypoint, $lWareList, $oSelectedStation]"/>
						<add_conversation_view view="closeupdetailmonitor"/>
						<debug_text text="'MT CLS - Selected Station: %1'.[$oSelectedStation.name]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
						<!-- Cleanup -->
						<remove_value name="$lTrader"/>
						<remove_value name="$tAction"/>
						<remove_value name="$lWaypoint"/>
						<remove_value name="$oSelectedStation"/>
						<remove_value name="$oOldStation"/>
				</do_elseif>

				<do_elseif value="event.param == 'gMT_Map_HomebaseSelected'">
					<debug_text text="'event.param2 = %1'.[event.param2]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="$tAction" exact="event.param2.{4}.{4}"/>
					<set_value name="$lTrader" exact="event.param2.{6}"/>
					<set_value name="$lWaypoint" exact="event.param2.{7}"/>
					<set_value name="$oHomebase" exact="$lTrader.{2}"/>
					<debug_text text="'Station selected value on map return = %1'.[$oHomebase]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
					<set_value name="$lWaypoint.{3}" exact="$oHomebase"/>
					<!-- Get ware list for station -->
					<set_value name="$lWareList" exact="[$oHomebase.resources.list, $oHomebase.products.list, $oHomebase.tradewares.list]"/>
					<debug_text text="'MT CLS - Selected Station: %1  Ware List = %2'.[$oHomebase.knownname, $lWareList]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
					<!-- Go back to our waypoint editor with the station info -->
					<open_conversation_menu menu="gMT_Station_Logistics_EditWaypoint" param="[0, 0, [], event.param2.{4}, [], $lTrader, $lWaypoint, $lWareList]"/>
					<add_conversation_view view="closeupdetailmonitor"/>
					<debug_text text="'MT CLS - Selected Station: %1'.[$oHomebase.knownname]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
					<!-- Cleanup -->
					<remove_value name="$lTrader"/>
					<remove_value name="$tAction"/>
					<remove_value name="$lWaypoint"/>
					<remove_value name="$oHomebase"/>
				</do_elseif>
				
				<!-- Unhandled map value -->
				<do_else>
					<debug_text text="'ERROR: Unhandled Map menu event:  ' + event.param" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 1)"/>
				</do_else>
			</actions>
		</cue>

		<!-- Cue to re-calculate all the crew scores -->
		<cue name="UpdateCrewScores" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled/>
			</conditions>
			<actions>
				<set_value name="$lTraders" exact="global.$XRCLS.$lTradeShips"/>				<!-- Get all the traders into a local list -->
				<do_all exact="$lTraders.count" counter="$i">
					<set_value name="$oShip" exact="$lTraders.{$i}.{1}"/>
					<set_value name="$iCrewSkill" exact="@$oShip.pilot.combinedskill + @$oShip.defencenpc.combinedskill + @$oShip.engineer.combinedskill"/>
					<set_value name="$iCrewLevel" exact="1"/>
					<do_if value="$iCrewSkill" min="200" max="249">
						<set_value name="$iCrewLevel" exact="2"/>
					</do_if>
					<do_if value="$iCrewSkill ge 250">
						<set_value name="$iCrewLevel" exact="3"/>
					</do_if>
					<set_value name="$lTraders.{$i}.{5}" exact="$iCrewLevel"/>
					<set_value name="$lTraders.{$i}.{6}" exact="$iCrewSkill"/>
				</do_all>
				<set_value name="global.$XRCLS.$lTradeShips" exact="$lTraders"/>
				<remove_value name="$iCrewSkill"/>
				<remove_value name="$iCrewLevel"/>
				<remove_value name="$lTraders"/>
				<remove_value name="$oShip"/>
			</actions>
		</cue>
		
		<!-- Synchronise list of ships -->
		<cue name="GetShipLists" instantiate="true" namespace="this">
			<conditions>
				<event_cue_signalled/>
			</conditions>
			<actions>
				<set_value name="$oCue" exact="event.param.{1}"/>
				<set_value name="$lTradeShips" exact="global.$XRCLS.$lTradeShips"/>							<!-- Get all the traders into a local list -->
				<set_value name="$lNewList" exact="[]"/>
				<!-- Set the index for the ship component -->
				<do_all exact="$lTradeShips.count" counter="$iTraderIndex">								<!-- now get a list of ships to pass into the menu -->
					<set_value name="$lTrader" exact="$lTradeShips.{$iTraderIndex}"/>
					<set_value name="$oShip" exact="$lTrader.{1}"/>
					<do_if value="@$oShip.exists and @$oShip.isoperational">
						<set_value name="$iCrewSkill" exact="@$oShip.pilot.combinedskill + @$oShip.defencenpc.combinedskill + @$oShip.engineer.combinedskill"/>
						<set_value name="$iCrewLevel" exact="1"/>
						<do_if value="$iCrewSkill" min="200" max="249">
							<set_value name="$iCrewLevel" exact="2"/>
						</do_if>
						<do_if value="$iCrewSkill ge 250">
							<set_value name="$iCrewLevel" exact="3"/>
						</do_if>
						<set_value name="$lTrader.{5}" exact="$iCrewLevel"/>
						<set_value name="$lTrader.{6}" exact="$iCrewSkill"/>
						<set_value name="$lTrader.{10}" exact="$iTraderIndex"/>
						<set_value name="$lTrader.{11}" exact="$lTrader.{4}.count" comment="Number of waypoints"/>
						<append_to_list name ="$lNewList" exact="$lTrader"/>
					</do_if>
				</do_all>
				
				<!-- Update the saved list -->
				<set_value name="global.$XRCLS.$lTradeShips" exact="$lNewList"/>
				<debug_text text="'Global Ship List: %1'.[global.$XRCLS.$lTradeShips ]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)" />
				
				<set_value name="$oCue.$aReturn" exact="[$lNewList]"/>
				<!-- clean up -->
				<remove_value name="$lTradeShips"/>
				<remove_value name="$lTrader"/>
				<remove_value name="$lNewList"/>
				<remove_value name="$iTraderIndex"/>
				<remove_value name="$oShip"/>
				<remove_value name="$iCrewSkill"/>
				<remove_value name="$iCrewLevel"/>
			</actions>
		</cue>

		<!-- Debug - Write log contents and show in debug log if requested -->
		<!-- Param.{1} - true if write to debug log Param.{2} - log to write  Param.{3} - log entry Param.{4} - ship index if ship log  Param.{5} - ship object if ship log -->
		<cue name="WriteLog" instantiate="true" namespace ="this">
			<conditions>
				<event_cue_signalled/>
			</conditions>
			<actions>
				<set_value name="$bWriteToDebug" exact="event.param.{1}"/>
				<set_value name="$sLog" exact="event.param.{2}"/>
				<set_value name="$lEntry" exact="event.param.{3}"/>
				<set_value name="$iShip" exact="event.param.{4}"/>
				<set_value name="$oShip" exact="event.param.{5}"/>
								
				<!-- Update the admin log -->
				<do_if  value="$sLog == 'admin'" comment="Write to Admin log">
					<set_value name="global.$XRCLS.$lAdminLog.{1}" exact="$lEntry" operation="insert"/>
					<do_if value="$bWriteToDebug">
						<do_all exact="global.$XRCLS.$lAdminLog.count" counter="$i">
							<debug_text text="'++++ MT LOGISTICS ADMIN LOG +++++ %1'.[global.$XRCLS.$lAdminLog.{$i}]" filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						</do_all>
					</do_if>
					<!-- Trim log to sensible size - 250 entries -->
					<do_if value="global.$XRCLS.$lAdminLog.count gt 250">
						<remove_value name="global.$XRCLS.$lAdminLog.{251}"/>
					</do_if>
				</do_if>
				<!-- Update the ship log-->
				<do_elseif value="$sLog == 'ship'" comment="Write to ship log">
					<set_value name="global.$XRCLS.$lTradeShips.{$iShip}.{7}.{1}" exact="$lEntry" operation="insert"/>
					<do_if value="$bWriteToDebug">
						<do_all exact="global.$XRCLS.$lTradeShips.{$iShip}.{7}.count" counter="$i">
							<debug_text text="'++++ MT LOGISTICS SHIP LOG +++++ %1 Data %2'.[$oShip.knownname, global.$XRCLS.$lTradeShips.{$iShip}.{7}.{$i}]"  filter="scripts_verbose" chance="100 * (global.$XRCLS.$iDebugLevel ge 3)"/>
						</do_all>
					</do_if>
				</do_elseif>
				<do_else comment="Unhandled params">
				</do_else>

				<remove_value name="$bWriteToDebug"/>
				<remove_value name="$sLog"/>
				<remove_value name="$lEntry"/>
				<remove_value name="$iShip"/>
				<remove_value name="$oShip"/>
					
			</actions>
		</cue>
	
	</cues>
</mdscript>
<!--
 
	French Translation text file for MT Station Logistics mod.
	
	Author: Ronkhar
  
	Last Change:
	Version: V1.0.7
	Date: 04th February 2015
  
	X Rebirth version: 3.00+
-->
<language>
	<page id="150402" title="MT_Station_Logistics" descr="Texts for MT Station Logistics mod." voice="no">
		<!--  Sidebar Menu 1-20  -->
		<t id="1">Logistique de station MT</t>
		<t id="2">Gestion des vaisseaux de logistique</t>
		<!--  DetailMonitor Admin menu 21-25  -->
		<t id="21">Logistique de station MT - Panneau d'administration</t>
		<t id="22">Choisissez une option de la liste ci-dessous et cliquez sur Sélectionner</t>
		<!--  DetailMonitor Admin Menu - Buttons  -->
		<!--  Select {1001,3102} - vanilla  -->
		<!--  Back {1001,2669} - vanilla  -->
		<!--  DetailMonitor Admin menu - Options 26-40  -->
		<t id="26">Administration des vaisseaux de logistique</t>
		<t id="27">Rapports</t>
		<t id="28">Configuration</t>
		<t id="29">Membres d'équipage sans assignation</t>
		<t id="30">Équipage de logistique à bord d'un vaisseau incompatible</t>
		<!--  DetailMonitor Reports Menu 41-80  -->
		<t id="41">Logistique de station MT - Panneau des rapports</t>
		<t id="42">Obtenir des informations à propos de vos vaisseaux et équipages</t>
		<t id="44">Pas de rang</t>
		<t id="45">Entraîner</t>
		<t id="46">Rapport</t>
		<t id="47">Le membre d'équipage a des états de service. Expérience disponible</t>
		<t id="48">Le membre d'équipage n'a pas d'états de service</t>

		<!--  Captain's Ranks  -->
		<t id="49"/>
		<t id="50">Enseigne</t>
		<t id="51">Lieutenant</t>
		<t id="52">Capitaine</t>
		<t id="53">Contre-amiral</t>
		<t id="54">Vice-amiral</t>
		<t id="55">Vice-amiral d'escadre</t>
		<t id="56">Amiral</t>
		<t id="57"/>
		<t id="58"/>
		<t id="59"/>

		<!--  Defence Officer Ranks  -->
		<t id="60">Soldat</t>
		<t id="61">Caporal</t>
		<t id="62">Caporal-chef</t>
		<t id="63">Sergent</t>
		<t id="64">Sergent-chef</t>
		<t id="65">Adjudant</t>
		<t id="66">Adjudant-chef</t>
		<t id="67"/>
		<t id="68"/>
		<t id="69"/>

		<!--  Engineer Ranks  -->
		<t id="70">Mousse</t>
		<t id="71">Matelot</t>
		<t id="72">Quartier-Maître</t>
		<t id="73">Second maître</t>
		<t id="74">Maître</t>
		<t id="75">Premier maître</t>
		<t id="76">Maître principal</t>
		<t id="77"/>
		<t id="78"/>
		<t id="79"/>
		<t id="80"/>
		
		<!--  DetailMonitor Configuration Menu 81-100  -->
		<t id="81">Logistique de station MT - Panneau de configuration</t>
		<t id="82">Choisissez une option ci-dessous</t>
		<t id="83">Mettre le niveau de debug à 1 - Erreurs</t>
		<t id="84">Mettre le niveau de debug à 2 - Information</t>
		<t id="85">Mettre le niveau de debug à 3 - Détaillé</t>
		<t id="86">Mettre le niveau de debug à 4 - Verbeux</t>
		<t id="87">Désinstaller Logistique de station MT</t>
		<t id="88">Remise à zéro de toutes les données du mod</t>
		
		<!--  DetailMonitor Ship Menu 101-160  -->
		<t id="101">Administrer les vaisseaux de logistique</t>
		<t id="102">Vaisseaux de logistique configurés</t>
		<t id="103">Base</t>
		<t id="104">Score</t>
		<t id="105">Active</t>
		<t id="106">Étapes</t>
		<t id="107">Vaisseaux disponibles, à configurer</t>
		<t id="108">Retirer</t>
		<t id="109">Arrêter</t>
		<t id="110">Configurer</t>
		<t id="111">Actif ?</t>
		<t id="112">Non</t>
		<t id="113">Minage en cours</t>
		
		<!--  DetailMonitor Waypoint list menu 161-220  -->
		<t id="161">Gestion des étapes</t>
		<t id="162">Aucune</t>
		<t id="163">Type d'étape</t>
		<t id="164">Min</t>
		<!--  Max = vanilla {1001,19}  -->
		<!--  Ware = vanilla {1001,45}  -->
		<!--  Range = vanilla {1001,1302}  -->
		<t id="165">Actif ?</t>
		<t id="166">Aucune station sélectionnée</t>
		<t id="167">Pas d'action</t>
		<t id="168">Charger</t>
		<t id="169">Décharger</t>
		<t id="170">Voler jusqu'à</t>
		<!--  Buy = vanilla {1001,2916}  -->
		<!--  Sell = vanilla {1001,2917}  -->
		<!--  Refuel = vanilla {1002,2027}  -->
		<t id="171">Verrouillé</t>
		<t id="172">Ajouter un nouveau point de navigation</t>
		<t id="173">Vaisseau sélectionné</t>
		<t id="174">Base</t>
		
		<!--  DetailMonitor Waypoint Edit Menu 221-300  -->
		<t id="221">Éditer l'étape</t>
		<t id="222">Ajouter une étape</t>
		<t id="223">!!L'OBJET CHOISI DOIT ÊTRE UNE STATION!!</t>
		<t id="224">!!LA STATION DOIT AVOIR UN AGENT COMMERCIAL!!</t>
		<t id="225">!!LA STATION CHOISIE EST HOSTILE - CHOISISSEZ-EN UNE AUTRE!!</t>
		<t id="226">!!LA STATION CHOISIE EST HORS DE PORTÉE POUR L'ÉQUIPAGE ACTUEL!!</t>
		<t id="227">!!!ATTENTION ! LA STATION CHOISIE NE STOCKE AUCUNE MARCHANDISE QUE CE VAISSEAU PUISSE TRANSPORTER !!!</t>
		<t id="228">Description</t>
		<t id="229">Action</t>
		<!--  Station - vanilla {1001,3}  -->
		<t id="230">Base</t>
		<t id="231">PNJ</t>
		<t id="232">Type d'étape</t>
		<t id="233">Type de marchandise</t>
		<t id="234">Si carburant inférieur à</t>
		<t id="235">Quantité minimale</t>
		<t id="236">de la soute</t>
		<t id="237">Quantité maximale</t>
		<t id="238">Prix maximal à l'achat</t>
		<t id="239">Prix minimal à la vente</t>
		<t id="240">Médian</t>
		<t id="241">L'étape est-elle active ?</t>
		<!--  Yes - Vanilla {1001,2617}  -->
		<!--  No - Vanilla {1001,2618}  -->
		<t id="242">Changer</t>
		<t id="243">Portée de l'étape</t>
		<t id="244">Sauvegarder</t>
		<t id="245">Remonter</t>
		<t id="246">Descendre</t>
		<t id="247">Couper</t>
		<t id="248">Coller</t>
		<t id="249">Mémoire-tampon</t>
		<t id="250">Mémoire-tampon vide</t>
		<t id="251">Station de l'étape</t>
		<!--  Crew log/training screen 301-400  -->
		<t id="301">Logistique de station MT - Panneau des équipages</t>
		<t id="302">Entraîner votre membre d'équipage</t>
		<t id="303">Temps de vol</t>
		<t id="304">Salaire obtenu</t>
		<t id="305">Points d'expérience disponibles (à dépenser)</t>
		<t id="306">1re étoile - 25K exp 2me étoile - 50K exp 3me étoile - 100K exp 4me étoile - 200K exp 5me étoile - 400K exp</t>
		<t id="307"/>
		<t id="308"/>
		<t id="309"/>
		<!--  Ship Log screen 401-500  -->
		<t id="401">Logistique de station MT - Historique des vaisseaux</t>
		<t id="402">Get data from your Logistics Trader ships</t>
		<t id="403">Temps total écoulé</t>
		<t id="404">Turnover</t>
		<t id="405">Volume déplacé</t>
		<t id="406">Taux d'activité</t>
		<t id="407">Surveiller</t>
		<t id="408">(DBG) Verbose</t>
		<t id="409">Historique administratif</t>
		<t id="410">Historique d'activité</t>
		<t id="411">Niveau de surveillance du vaisseau</t>
		<t id="412">Pas d'historique connu</t>
		<t id="413">Historique</t>
		<t id="414">Étape</t>
		<t id="415"/>
		<t id="416"/>
		<t id="417"/>
		<t id="418"/>
		<t id="419"/>
		<t id="420">Erreur : signaler à l'auteur</t>
		<t id="421">Étape ignorée : statut inactif</t>
		<t id="422">Étape ignorée : les salaires n'ont pas été versés !</t>
		<t id="423">Salaires versés : le travail peut reprendre</t>
		<t id="424">Étape ignorée : hors de portée pour l'équipage actuel</t>
		<t id="425">Étape ignorée : la destination est hostile</t>
		<t id="426">L'étape est un simple 'voler jusqu'à'. Le vaisseau en est déjà suffisamment proche</t>
		<t id="427">Destination atteinte avec succès</t>
		<t id="428">Balayage nul : le vaisseau est à sa base donc il ne bougera pas</t>
		<t id="429">Balayage nul : le vaisseau est rentré à sa base</t>
		<t id="430">Étape ignorée : pas assez de cash pour acheter les marchandises</t>
		<t id="431">Étape ignorée : pas assez de marchandises à récupérer</t>
		<t id="432">Étape ignorée : les marchandises sont trop chères</t>
		<t id="433">Étape ignorée : aucune marchandise à récupérer</t>
		<t id="434">Étape ignorée : les quantités sont insuffisantes pour rendre le voyage rentable</t>
		<t id="435">Étape ignorée : la soute contient déjà suffisamment de cette marchandise</t>
		<t id="436">Étape ignorée : la soute est pleine</t>
		<t id="437">Étape ignorée : la cible n'accepte pas suffisamment de marchandises</t>
		<t id="438">Étape ignorée : la cible ne paie pas assez cher nos marchandises</t>
		<t id="439">Étape ignorée : la cible n'achète pas nos marchandises</t>
		<t id="440">Étape ignorée : pas assez de marchandises à bord</t>
		<t id="441">Étape ignorée : nous ne pouvons pas réserver assez de marchandises</t>
		<t id="442">Étape ignorée : la cible a été détruite ou mise hors-service</t>
		<t id="443">Étape annulée : nous ne pouvons nous arrimer à la cible</t>
		<t id="444">Un problème a eu lieu lors de l'échange</t>
		<t id="445">Retour à la base en cours</t>
		<t id="446"/>
		<t id="447"/>
		<t id="448"/>
		<t id="449"/>
		<t id="450"/>
		<t id="451">Le vaisseau a arrêté de commercer : arrêté par le joueur</t>
		<t id="452">Le vaisseau a été détruit</t>

		<!--  Admin log screen  -->
		<t id="460">Logistique de station MT - Historique administratif</t>
		<t id="461">Voici les événements relatifs aux vaisseaux de logistique</t>
		<t id="462">Pas d'historique administratif</t>
		<t id="463">Message</t>
		<t id="464"/>
		<t id="465"/>
		<t id="466"/>
		<t id="467"/>
		<t id="468"/>
		<t id="469"/>
		<t id="470"/>

		<!--  Admin log screen 500-530  -->
		<t id="500">Ajout à la flotte : %1</t>
		<t id="501">Retrait de la flotte : %1</t>
		<t id="502">Début de la logistique pour le vaisseau %1</t>
		<t id="503">Arrêt de la logistique pour le vaisseau %1</t>
		<t id="504">Problème : Le vaisseau %1 a moins de deux étapes. Il est donc à l'arrêt.</t>
		<t id="505">Mise à jour des étapes pour le vaisseau %1</t>
		<t id="506">Mise à jour de la base pour le vaisseau %1 : %2</t>
		<t id="507"/>
		<t id="508"/>
		<t id="509"/>
		<t id="510"/>
		
		<t id="10000">Administration</t>
		<t id="10001">Administrer les vaisseaux de logistique</t>
		<t id="10005">Rapports</t>
		<t id="10006">Obtenir les rapports d'avancement des stations et des vaisseaux</t>
		<t id="10008">Configurer la Logistique de station MT</t>
		<t id="10009"/>
		<t id="10010"/>
		<t id="10011"/>
		<t id="10023">Éditer le commercant</t>
		<t id="10026">Choisissez une station pour laquelle le commerçant travaillera</t>
		<t id="10035">Configurer la Logistique de station MT</t>
		<t id="10036">Éditer l'étape sélectionnée</t>

		
		<!--  9000 - 9999: Administration  -->
		<t id="9000">Désinstaller</t>
		<t id="9001">Niveau de debug</t>
		<t id="9002">Erreur</t>
		<t id="9003">Information</t>
		<t id="9004">Détaillé</t>
		<t id="9005">Verbeux</t>
		<t id="9992">\nPour plus d'informations, consultez l'historique</t>
		<t id="9993">version %1 active: V%2</t>
		<t id="9994">Émission du signal d'initialisation %1 au niveau de debug %2...</t>
		<t id="9995">%1 V%2 a été désinstallé avec succès.\nVeuillez sauvegarder votre jeu, fermer X-Rebirth, supprimer le dossier %1 dans le dossier extensions, vous désinscrire du mod dans le workshop Steam, charger le partie, sauvegarder la partie.%3</t>
		<t id="9996">Attention !\nVous redescendez votre version de %1 : V%2 -> V%3</t>
		<t id="9997">Installation de %1 V%2...%3</t>
		<t id="9998">Mise à jour de %1 détectée : V%2 -> V%3%4\nVeuillez sauvegarder et recharger votre partie.</t>
		<t id="9999">Mise à jour de la configuration de %1 trouvée.... Succès de la mise à jour !</t>
	</page>
</language>﻿<?xml version="1.0" encoding="UTF-8"?>
<!-- 
	Base (English) text file for MT Station Logistics mod.
	
	Author: wysiwyg
  
	Last Change:
	Version: V0.0.1
	Date: 06th December 2014
  
	X Rebirth version: 3.00+
-->
<language>
	<page id="150402" title="MT_Station_Logistics" descr="Texts for MT Station Logistics mod." voice="no">
		<!-- Sidebar Menu 1-20 -->
		<t id="1">MT Station Logistics</t>
		<t id="2">Set-up and manage Station Logistics Traders</t>

		<!-- DetailMonitor Admin menu 21-25 -->
		<t id="21">MT Station Logistics - Administration</t>
		<t id="22">Select an option from the list below and click select</t>
		<!-- DetailMonitor Admin Menu - Buttons -->
		<!-- Select {1001,3102} - vanilla -->
		<!-- Back {1001,2669} - vanilla -->
		<!-- DetailMonitor Admin menu - Options 26-40 -->
		<t id="26">Administer Trade Ships</t>
		<t id="27">Reports</t>
		<t id="28">Configure</t>
		<t id="29">Unassigned Crew Members</t>
		<t id="30">CLS crew currently serving on non-cls vessel</t>
		
		<!-- DetailMonitor Reports Menu 41-80 -->
		<t id="41">MT Station Logistics - Reports Menu</t>
		<t id="42">Get data about ships and crew</t>
		<t id="44">No Rank</t>
		<t id="45">Train</t>
		<t id="46">Report</t>
		<t id="47">Crew member has a service record - eXPerience Points available to spend</t>
		<t id="48">Crew member does not have a service record</t>
		<!-- Captain's Ranks -->
		<t id="49"></t>
		<t id="50">Captain</t>
		<t id="51">Major</t>
		<t id="52">Lieutenant Colonel</t>
		<t id="53">Colonel</t>
		<t id="54">Commander</t>
		<t id="55">Rear Admiral</t>
		<t id="56">Admiral</t>
		<t id="57"></t>
		<t id="58"></t>
		<t id="59"></t>
		<!-- Defence Officer Ranks -->
		<t id="60">Private</t>
		<t id="61">Private 1st Class</t>
		<t id="62">Corporal</t>
		<t id="63">Crew Sergeant</t>
		<t id="64">Sergeant 1st Class</t>
		<t id="65">Gunnery Sergeant</t>
		<t id="66">Sergeant Major</t>
		<t id="67"></t>
		<t id="68"></t>
		<t id="69"></t>
		<!-- Engineer Ranks -->
		<t id="70">Crewman Apprentice</t>
		<t id="71">Crewman</t>
		<t id="72">Specialist</t>
		<t id="73">Petty Officer 2nd Class</t>
		<t id="74">Petty Officer 1st Class</t>
		<t id="75">Chief Petty Officer</t>
		<t id="76">Master Chief Petty Officer</t>
		<t id="77"></t>
		<t id="78"></t>
		<t id="79"></t>
		<t id="80"></t>

		<!-- DetailMonitor Configuration Menu 81-100 -->
		<t id="81">MT Station Logistics - Configuration</t>
		<t id="82">Select an option below</t>
		<t id="83">Set debug level 1 - Error</t>
		<t id="84">Set debug level 2 - Information</t>
		<t id="85">Set debug level 3 - Detailed</t>
		<t id="86">Set debug level 4 - Verbose</t>
		<t id="87">Uninstall MT Station Logistics</t>
		<t id="88">Reset all XRCLS data</t>

		<!-- DetailMonitor Ship Menu 101-160 -->
		<t id="101">Administer Station Logistics Ships</t>
		<t id="102">Configured Logistics Ships</t>
		<t id="103">Homebase</t>
		<t id="104">Score</t>
		<t id="105">Active</t>
		<t id="106">#WP</t>
		<t id="107">Un-configured ships available</t>
		<t id="108">Remove</t>
		<t id="109">Stop</t>
		<t id="110">Configure</t>
		<t id="111">Active?</t>
		<t id="112">None</t>
		<t id="113">Mining</t>
		
		<!-- DetailMonitor Waypoint list menu 161-220 -->
		<t id="161">Waypoint Management</t>
		<t id="162">None Selected</t>
		<t id="163">WP Type</t>
		<t id="164">Min</t>
		<!-- Max = vanilla {1001,19} -->
		<!-- Ware = vanilla {1001,45} -->
		<!-- Range = vanilla {1001,1302} -->
		<t id="165">Active?</t>
		<t id="166">No Station Selected</t>
		<t id="167">No Action</t>
		<t id="168">Load</t>
		<t id="169">Unload</t>
		<t id="170">Fly to</t>
		<!-- Buy = vanilla {1001,2916} -->
		<!-- Sell = vanilla {1001,2917} -->
		<!-- Refuel = vanilla {1002,2027} -->
		<t id="171">Locked</t>
		<t id="172">Add New Waypoint</t>
		<t id="173">Selected Ship</t>
		<t id="174">Homebase Station</t>


		<!-- DetailMonitor Waypoint Edit Menu 221-300 -->
		<t id="221">Edit Waypoint</t>
		<t id="222">Add Waypoint</t>
		<t id="223">!!OBJECT SELECTED MUST BE A STATION!!</t>
		<t id="224">!!STATION MUST HAVE A TRADE AGENT ONBOARD!!</t>
		<t id="225">!!STATION SELECTED IS HOSTILE - PLEASE CHOOSE ANOTHER!!</t>
		<t id="226">!!STATION SELECTED IS OUT OF RANGE FOR THE CURRENT CREW!!</t>
		<t id="227">!!! WARNING!  THE STATION SELECTED DOES NOT DEAL IN ANY WARES THAT THE SHIP CAN CARRY !!!</t>
		<t id="228">Description</t>
		<t id="229">Action</t>
		<!-- Station - vanilla {1001,3} -->
		<t id="230">Home</t>
		<t id="231">NPC</t>
		<t id="232">Waypoint Type</t>
		<t id="233">Ware Type</t>
		<t id="234">If fuel left less than</t>
		<t id="235">Minimum Amount</t>
		<t id="236">Cargo Space</t>
		<t id="237">Maximum Amount</t>
		<t id="238">Maximum buy Price</t>
		<t id="239">Minimum sell Price</t>
		<t id="240">Avg</t>
		<t id="241">Is Waypoint Active?</t>
		<!-- Yes - Vanilla {1001,2617} -->
		<!-- No - Vanilla {1001,2618} -->
		<t id="242">Change</t>
		<t id="243">Waypoint Range</t>
		<t id="244">Save</t>
		<t id="245">Move Up</t>
		<t id="246">Move Down</t>
		<t id="247">Cut</t>
		<t id="248">Paste</t>
		<t id="249">Paste Buffer</t>
		<t id="250">Paste Buffer empty</t>
		<t id="251">Waypoint Station</t>
		
		<!-- Crew log/training screen 301-400 -->
		<t id="301">MT Station Logistics - Crew Details</t>
		<t id="302">Train your crew member</t>
		<t id="303">Flying Time</t>
		<t id="304">Salary Earned</t>
		<t id="305">Experience points left to spend</t>
		<t id="306">1st star - 25K xp   2nd star - 50K xp   3rd star - 100K xp   4th star - 200K xp   5th star - 400K xp</t>
		<t id="307"></t>
		<t id="308"></t>
		<t id="309"></t>

		<!-- Ship Log screen 401-500 -->
		<t id="401">MT Station Logistics - Ship Log</t>
		<t id="402">Get data from your Logistics Trader ships</t>
		<t id="403">Total Time</t>
		<t id="404">Turnover</t>
		<t id="405">Volume Traded</t>
		<t id="406">% Time Active</t>
		<t id="407">Track</t>
		<t id="408">(DBG) Verbose</t>
		<t id="409">Admin Log</t>
		<t id="410">Activity Log</t>
		<t id="411">Debug Level for this ship</t>
		<t id="412">No Log Entries to show</t>
		<t id="413">Tracking Log</t>
		<t id="414">Waypoint</t>
		<t id="415"></t>
		<t id="416"></t>
		<t id="417"></t>
		<t id="418"></t>
		<t id="419"></t>

		<t id="420">Error - report to author</t>
		<t id="421">Skipping waypoint due to waypoint set to inactive</t>
		<t id="422">Skipping waypoint due to wages not being paid!!</t>
		<t id="423">Wages paid - resuming duties</t>
		<t id="424">Skipping waypoint due to waypoint being out of range for the current crew</t>
		<t id="425">Skipping waypoint due to destination being hostile</t>
		<t id="426">Waypoint is fly to. Already close enough so not moving</t>
		<t id="427">Successfully flew to destination</t>
		<t id="428">Null sweep: already safely at home so not moving</t>
		<t id="429">Null sweep: flew home to safety</t>
		<t id="430">Skipping due to not enough cash to pay for wares</t>
		<t id="431">Skipping due to not enough wares for purchase at destination</t>
		<t id="432">Skipping because the wares are too expensive at the destination</t>
		<t id="433">Skipping due to no wares for sale at the destination</t>
		<t id="434">Skipping because the amount is too low to be worth the trip</t>
		<t id="435">Skipping because we already have enough of that ware on board</t>
		<t id="436">Skipping because we don't have enough room in the hold</t>
		<t id="437">Skipping because the destination does not want enough wares</t>
		<t id="438">Skipping because the destination won't pay enough for the wares</t>
		<t id="439">Skipping due to no buy offers at the destination</t>
		<t id="440">Skipping because we don't have enough wares on board to meet the sale</t>
		<t id="441">Skipping due to not being able to reserve enough wares</t>
		<t id="442">Skipping as it seems that the target has been destroyed or is not functional</t>
		<t id="443">Aborted because we couldn't park at the destination</t>
		<t id="444">Something went wrong during the trade - Egosoft - I'm looking at you!!!</t>
		<t id="445">Flying back to homebase</t>
		<t id="446"></t>
		<t id="447"></t>
		<t id="448"></t>
		<t id="449"></t>
		<t id="450"></t>

		<t id="451">Ship ceased trading - stopped by player</t>
		<t id="452">The ship has been destroyed</t>

		<!-- Admin log screen -->
		<t id="460">MT Station Logistics - Admin Log</t>
		<t id="461">See all actions on logistics ships</t>
		<t id="462">No Admin Log messages</t>
		<t id="463">Message</t>
		<t id="464"></t>
		<t id="465"></t>
		<t id="466"></t>
		<t id="467"></t>
		<t id="468"></t>
		<t id="469"></t>
		<t id="470"></t>

		<!-- Admin log screen 500-530 -->
		<t id="500">New Trade Ship Added to fleet %1</t>
		<t id="501">Removed ship from fleet %1</t>
		<t id="502">Started Trading with ship %1</t>
		<t id="503">Stopped Trading with ship %1</t>
		<t id="504">Updated Waypoints for ship %1 - ship now has less than two waypoints so stopping</t>
		<t id="505">Updated Waypoints for ship %1</t>
		<t id="506">Updated Homebase for ship %1 to %2</t>
		<t id="507"></t>
		<t id="508"></t>
		<t id="509"></t>
		<t id="510"></t>



		<t id="10000">Administration</t>
		<t id="10001">Administer logistics traders</t>
		<t id="10005">Reports</t>
		<t id="10006">Get progress reports from stations and traders</t>
		<t id="10008">Configure MT Station Logistics</t>
		<t id="10009"></t>
		<t id="10010"></t>
		<t id="10011"></t>
			  
		<t id="10023">Edit Trader</t>
		<t id="10026">Select a station that the trader will work for</t>
		<t id="10035">Configure MT Station Logistics</t>
		<t id="10036">Edit selected waypoint</t>

		<!-- 9000 - 9999: Administration -->
		<t id="9000">Uninstall</t>
		<t id="9001">Debug Level</t>
		<t id="9002">Error</t>
		<t id="9003">Information</t>
		<t id="9004">Detailed</t>
		<t id="9005">Verbose</t>
		  
		<t id="9992">\nAdditional information is available in your logbook.</t>
		<t id="9993">Active %1 version: V%2</t>
		<t id="9994">Running %1 initialization cue at debug level %2...</t>
		<t id="9995">Successfully un-installed %1 V%2.\nPlease save your game, close X-Rebirth, delete the %1 folder from your extensions folder and un-subscribe from the mod in the workshop, then load and save your game.%3</t>
		<t id="9996">Warning!\nYou are downgrading your %1 version: V%2 -> V%3</t>
		<t id="9997">Installing %1 V%2...%3</t>
		<t id="9998">Detected %1 update: V%2 -> V%3%4\nPlease save your game and load it again.</t>
		<t id="9999">Updated %1 configuration found....Update successful!</t>
    </page>
</language><?xml version="1.0" encoding="utf-8"?>
<addon name="foo" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../ui/core/addon.xsd">
	<environment type="detailmonitor">
		<file name="ui\addons\moni\MT_Station_Logistics_Admin_Menu.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_Reports_Menu.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_Config_Menu.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_Select_Ship.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_ListWaypoints.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_EditWaypoint.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_CrewLog.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_ShipLog.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_AdminLog.lua"/>
		<file name="ui\addons\moni\MT_Station_Logistics_Rename.lua"/>
		<file name="ui\addons\moni\lib\LibMT.lua"/>
		<dependency name="ego_detailmonitorHelper"/>
	</environment>
	<environment type="fullscreen">
		<file name="ui\addons\menu\mainmenu_mt_station_logistics.lua"/>
		<dependency name="ego_fullscreenHelper"/>
	</environment>
</addon>
--[[	MT Station Logistics
		Version:		1.00
		Last Update:	2014-12-06
		This file adds side bar menu entries for the station logistics mod
		and sub-menu entries for each function
--]]

-- This is the parent menu entry for the table above
local menuAddon = 
{
	entry1 =
	{	
		section = "gMT_Logistics",
		icon = "mm_ic_trading",
		name = ReadText( 150402, 1 ),	-- name = "MT Station Logistics",
		condition = true,
		info = ReadText( 150402, 2 ),	-- info = "Set-up and manage Station Traders",
--		list = submenulist
		sectionparam = { 0, 0, {}, {}, {}, {} }
	}
}

-- this function iterates through the top level menu entries until it finds the trade menu
local function createSetupAddMTStationLogistics(menu)
    for _, subMenu in ipairs(menu.setup.top) do
        if subMenu.icon == "mm_ic_trading" then
			table.insert(subMenu.list, menuAddon.entry1)
        end
    end
end

-- This function creates the setup wrapper that adds the menu to the core game menu
local function createSetupWrapper()
    menuAddon.origCreateSetup()
	createSetupAddMTStationLogistics(menuAddon.menu)
end

-- initialise the menu addition
local function init()
	if Menus then
		for _, menu in ipairs(Menus) do
            if menu.name == "MainMenu" then
                menuAddon.menu = menu
                menuAddon.origCreateSetup = menu.createSetup
                menu.createSetup = createSetupWrapper
                break
            end
		end
	end
end

-- call the init() function
init()
--[[	This file is part of the X Rebirth MT script library mod.
		It is based on MadJoker's LibMT suite
		Author: Wysiwyg
  
		Last Change:
		Version: V0.0.1
		Date: 2014-12-12
  
		X Rebirth version: 3.00
--]]

-- catch early menu registration
local registerFuncs = {}
if LibMT then
	registerFuncs = LibMT.registerFuncs
end

-- Define the base table
LibMT = {
	menus = {},
	name = "LibMT",
	param = {nil, nil},
	rowDataMap = {}
}

-- Debugging switch for entire project - set to nil to turn OFF
-- LibMT.DEBUG = true
LibMT.DEBUG = nil

-- Predefined colours helper
LibMT.colours = {
	white = { r = 255, g = 255, b = 255, a = 100 },
	red = {	 g = 0, a = 100, b = 0,r = 255 },
	green = { r = 0, g = 255, b = 0, a = 100 },
	blue = { r = 0, g = 0, b = 255, a = 100 },
	transparent = { r = 0, g = 0, b = 0, a = 0 }
}

-- Hotkeys Helper
LibMT.hotkeys = {
	"INPUT_STATE_DETAILMONITOR_B",
	"INPUT_STATE_DETAILMONITOR_X",
	"INPUT_STATE_DETAILMONITOR_LB",
	"INPUT_STATE_DETAILMONITOR_RB",
	"INPUT_STATE_DETAILMONITOR_A",
	"INPUT_STATE_DETAILMONITOR_0",
	"INPUT_STATE_DETAILMONITOR_BACK",
	"INPUT_STATE_DETAILMONITOR_Y",
}

-- library initialisation function
local function init()
	for _, func in ipairs(registerFuncs) do
		func()
	end
	registerFuncs = nil
	
	Menus = Menus or {}
	table.insert(Menus, LibMT)
	
	if Helper then
		Helper.registerMenu( LibMT )
	end
end

function LibMT:Row(cells, rowData, bgColour, isFixed, nrOfChildRows)	
	return {
		cells = cells or { Helper.getEmptyCellDescriptor() },
		data = rowData,
		bgColour = bgColour,
		isFixed = isFixed,
		nrOfChildRows = nrOfChildRows or 0
	}
end

function LibMT:Cell(element, script, colspan)
	return self:CreateCell(element, nil, script, colspan)
end

function LibMT:ButtonCell(element, script, colspan, selectable, colour, fontSize, isBold)
	local canSelect = true
	if selectable ~= nil then
		canSelect = selectable
	end
	local button = element
	if type(element) == "string" then
		button = LibMT:CreateDefaultCenterButton(element, canSelect, colour, fontSize, isBold)
	end
	return self:CreateCell(button, "button", script, colspan)
end

function LibMT:EditBoxCell(element, script, colspan)
	return self:CreateCell(element, "editBox", script, colspan)
end

function LibMT:CreateCell(element, type, script, colspan)
	return {
		element = element or Helper.getEmptyCellDescriptor(),
		type = type or "text",
		script = script,
		colspan = colspan or 1
	}
end

function LibMT:BarButton(label, script, availabilityProvider, hotkey)
	return {
		label = label,
		script = script or function () end,
		availabilityProvider = availabilityProvider or function () return true end,
		hotkey = hotkey
	}
end




function LibMT:AddRows( menu, parentRowIdx, count, skipRefresh)
	local wasExpanded = LibMT:IsExpanded(menu,parentRowIdx)
	LibMT:CollapseRow(menu, parentRowIdx, true)
	
	for i = 1, count do
		self:AddRow(menu, parentRowIdx, true)
	end
	
	if wasExpanded then
		LibMT:ExpandRow(menu, parentRowIdx, true)
	end
	
	if not skipRefresh then
		menu.display()
	end
end

function LibMT:AddRow(menu, parentRowIdx, skipRefresh)
--	local state = self.stack:peek()
	
	local wasExpanded = LibMT:IsExpanded(menu, parentRowIdx)
	LibMT:CollapseRow(menu, parentRowIdx, true)
	
	-- we have to add a row expand state for the new row
	self:AddRowExpandState(menu, parentRowIdx)
	
	if wasExpanded then
		LibMT:ExpandRow(menu, parentRowIdx, true)
	end
	
	if not skipRefresh then
		menu.display()
	end
end

function LibMT:RemoveRows(menu, rowIdx, count, skipRefresh)
	for i = 1, count do
		self:RemoveRow(menu, rowIdx, true)
	end
	
	if not skipRefresh then
		menu.display()
	end
end

function LibMT:RemoveRow(menu, rowIdx, skipRefresh)
	-- we collapse the removed row first
	self:CollapseRow(menu, rowIdx, true)
	
	-- then, we remove the expand state
	self:DeleteRowExpandState(menu, rowIdx)

	-- we then have to adjust the selected row index if it was below the removed row
	if menu.selectedRow and menu.selectedRow.idx > rowIdx then
		menu.selectedRow.idx = menu.selectedRow.idx - 1
	end
	
	if not skipRefresh then
		menu.display()
	end
end

function LibMT:ToggleRow(menu, rowIdx, skipRefresh, isToggle)
	if LibMT:IsExpanded(menu, rowIdx) then
		LibMT:CollapseRow(menu, rowIdx, skipRefresh, isToggle)
	else
		LibMT:ExpandRow(menu, rowIdx, skipRefresh, isToggle)
	end
end

function LibMT:ExpandRow(menu, rowIdx, skipRefresh, isToggle)
	menu.expandStates = menu.expandStates or {}
	
	assert(rowIdx <= #menu.rows, "Row index (" .. rowIdx .. ") is larger than number of rows (" .. #menu.rows .. ")")
	
	local currentIdx, rowsLeft, nrOfExpandedRows = LibMT:ExpandRowHelper(menu, menu.expandStates, 0, 99999, rowIdx)
	
	assert(currentIdx == rowIdx, "Error during row expansion: mismatch in returned current row index (" .. currentIdx .. ") and target row index (" .. rowIdx .. ")")
	assert(rowsLeft == 0, "Error during row expansion: number of rows left > 0")
	
	-- we have to adjust the selected row index if it was below the expanded row if we do a toggle row
	if isToggle then
		if menu.selectedRow and menu.selectedRow.idx > rowIdx then
			menu.selectedRow.idx = menu.selectedRow.idx + nrOfExpandedRows
		end
	end
	
	menu.toprow = GetTopRow(menu.defaulttable)
	menu.selrow = menu.selectedRow.idx

	if not skipRefresh then
		menu.display()
	end
end

function LibMT:ExpandRowHelper(menu, rowStates, currentIdx, nrOfChildRows, rowsLeft)
--	local state = self.stack:peek()
	for i = 1, nrOfChildRows do
		rowsLeft = rowsLeft - 1
		currentIdx = currentIdx + 1
		local row = menu.rows[currentIdx]
		
		if not rowStates[i] then
			rowStates[i] = {
				expanded = false,
				childStates = {},
				nrOfChildRows = row.nrOfChildRows,
				rowsTotal = row.nrOfChildRows
			}
		end
	
		-- if the target index reached 0, we expand the row
		if rowsLeft == 0 then
			-- how many rows are we expanding? 0 if the row was already expanded
			local nrOfExpandedRows = (rowStates[i].expanded and 0) or rowStates[i].rowsTotal
			rowStates[i].expanded = true
			return currentIdx, rowsLeft, nrOfExpandedRows
		end
		
		-- if this row is expanded, we have to go through the child rows as well
		if rowStates[i].expanded then
			local nrOfExpandedRows = 0
			currentIdx, rowsLeft, nrOfExpandedRows = LibMT:ExpandRowHelper(menu, rowStates[i].childStates, currentIdx, rowStates[i].nrOfChildRows, rowsLeft)
			
			-- we have to accumulate our total child row count
			rowStates[i].rowsTotal = rowStates[i].rowsTotal + nrOfExpandedRows
			
			-- then, if there are no more rows left, we can return
			if rowsLeft == 0 then
				return currentIdx, rowsLeft, nrOfExpandedRows
			end
		end
	end
	
	return currentIdx, rowsLeft, 0
end

function LibMT:CollapseRow(menu, rowIdx, skipRefresh, isToggle)
	menu.expandStates = menu.expandStates or {}
	
	assert(rowIdx <= #menu.rows, "Row index (" .. rowIdx .. ") is larger than number of rows (" .. #menu.rows .. ")")
	local rowsLeft, nrOfCollapsedRows = LibMT:CollapseRowHelper(menu, menu.expandStates, 99999, rowIdx)
	
	assert(rowsLeft == 0, "Error during row collapsing: number of rows left > 0")
	
	-- we have to adjust the selected row index if it was below the collapsed row if we do a toggle
	if isToggle then
		if menu.selectedRow and menu.selectedRow.idx > rowIdx then
			-- if we had a row selected, that is not visible any more now, we set the collapsed row to be selected
			if menu.selectedRow.idx <= rowIdx + nrOfCollapsedRows then
				menu.selectedRow.idx = rowIdx
			else
				menu.selectedRow.idx = menu.selectedRow.idx - nrOfCollapsedRows
			end
		end
	end
	menu.toprow = GetTopRow(menu.defaulttable)
	menu.selrow = menu.selectedRow.idx
		
	if not skipRefresh then
		menu.display()
	end
end

function LibMT:CollapseRowHelper(menu, rowStates, nrOfChildRows, rowsLeft)
	for i = 1, nrOfChildRows do
		rowsLeft = rowsLeft - 1
	
		-- if the target index reached 0, we collapse the row
		if rowsLeft == 0 then
			if not rowStates[i] then
				return rowsLeft, 0
			end
		
			-- how many rows are we collapsing? 0 if the row was already collapsed
			local nrOfCollapsedRows = (rowStates[i].expanded and rowStates[i].rowsTotal) or 0
			rowStates[i].expanded = false
			return rowsLeft, nrOfCollapsedRows
		end
		
		-- if this row is expanded, we have to go through the child rows as well
		if rowStates[i] and rowStates[i].expanded then
			local nrOfCollapsedRows = false
			rowsLeft, nrOfCollapsedRows = LibMT:CollapseRowHelper(menu, rowStates[i].childStates, rowStates[i].nrOfChildRows, rowsLeft)
			
			-- we have to accumulate our total child row count
			rowStates[i].rowsTotal = rowStates[i].rowsTotal - nrOfCollapsedRows
			
			-- then, if there are no more rows left, we can return
			if rowsLeft == 0 then
				return rowsLeft, nrOfCollapsedRows
			end
		end
	end
	
	return rowsLeft, 0
end

function LibMT:AddRowExpandState(menu, parentRowIdx)
--	local state = self.stack:peek()
	menu.expandStates = menu.expandStates or {}
	
	-- setting the parentRowIdx to to #rows + 1 lets the helper enumerate all rows in the expand state
	parentRowIdx = parentRowIdx or #menu.rows + 1
	parentRowIdx = (parentRowIdx > 0 and parentRowIdx) or #menu.rows + 1
	
	assert(parentRowIdx <= #menu.rows + 1, "Parent row index (" .. parentRowIdx .. ") is larger than number of rows (" .. #menu.rows .. ") + 1")
	
	local _, rowsLeft = LibMT:AddRowExpandStateHelper(menu, menu.expandStates, 0, 99999, parentRowIdx)
	
	-- check if the new row was added at the total end
	if rowsLeft > 0 then
		local newState = {
			expanded = false,
			childStates = {},
			nrOfChildRows = 0, -- will be updated once the row is expanded, until then it doesn't matter
			rowsTotal = 0
		}
		table.insert(menu.expandStates, newState)
	end
end

function LibMT:AddRowExpandStateHelper(menu, rowStates, currentIdx, nrOfChildRows, rowsLeft)
--	local state = self.stack:peek()
	
	for i = 1, nrOfChildRows do
		rowsLeft = rowsLeft - 1
		currentIdx = currentIdx + 1
		
		local row = menu.rows[currentIdx]
		
		if not rowStates[i] then
			rowStates[i] = {
				expanded = false,
				childStates = {},
				nrOfChildRows = row.nrOfChildRows,
				rowsTotal = row.nrOfChildRows
			}
		end
	
		-- if the target index reached 0, we found the parent row to add a state to
		if rowsLeft == 0 then
			-- we check, if we the state should be added to this state, or the one one level up
			rowStates[i].nrOfChildRows = rowStates[i].nrOfChildRows + 1
			rowStates[i].rowsTotal = rowStates[i].rowsTotal + 1
			
			return currentIdx, rowsLeft
		end
		
		-- if this row is expanded, we have to go through the child rows as well
		if rowStates[i].expanded then
			currentIdx, rowsLeft, parentRowIdx = LibMT:AddRowExpandStateHelper(menu, rowStates[i].childStates, currentIdx, rowStates[i].nrOfChildRows, rowsLeft)
			
			-- then, if there are no more rows left, we can return
			if rowsLeft == 0 then
				return currentIdx, rowsLeft
			end
		end
	end
	
	return currentIdx, rowsLeft
end

function LibMT:DeleteRowExpandState(menu, rowIdx)
--	local state = self.stack:peek()
	menu.expandStates = menu.expandStates or {}
	
	assert(rowIdx <= #menu.rows, "Row index (" .. rowIdx .. ") is larger than number of rows (" .. #menu.rows .. ")")
	
	local rowsLeft = LibMT:DeleteRowExpandStateHelper(menu, menu.expandStates, 99999, rowIdx)
	
	assert(rowsLeft == 0, "Error during deletion of row expand state: number of rows left > 0")
end

function LibMT:DeleteRowExpandStateHelper(menu, rowStates, nrOfChildRows, rowsLeft)
	for i = 1, nrOfChildRows do
		rowsLeft = rowsLeft - 1
	
		-- if the target index reached 0, we remove the state
		if rowsLeft == 0 then
			table.remove(rowStates, i)
			return rowsLeft
		end
		
		-- if this row is expanded, we have to go through the child rows as well
		if rowStates[i] and rowStates[i].expanded then
			rowsLeft = LibMT:DeleteRowExpandStateHelper(menu, rowStates[i].childStates, rowStates[i].nrOfChildRows, rowsLeft)
			
			-- then, if there are no more rows left, we can return
			if rowsLeft == 0 then
				-- we also have to decrement our child count
				rowStates[i].nrOfChildRows = rowStates[i].nrOfChildRows - 1
				rowStates[i].rowsTotal = rowStates[i].rowsTotal - 1
				return rowsLeft
			end
		end
	end
	
	return rowsLeft
end

function LibMT:IsExpanded(menu, rowIdx)
	menu.expandStates = menu.expandStates or {}

	local rowsLeft, isExpanded, s = LibMT:IsExpandedHelper(menu, menu.expandStates, 99999, rowIdx, 1)
	
	assert(rowsLeft == 0, "Error during row expansion check: number of rows left > 0")
	
	return isExpanded, s
end

function LibMT:IsExpandedHelper(menu, rowStates, nrOfChildRows, rowsLeft, indentLevel)
	local s = "\n"
	for i = 1, nrOfChildRows do
		for j = 1, indentLevel do
			s = s .. "..."
		end
		local state = rowStates[i] or {
			expanded = false,
			childStates = {},
			nrOfChildRows = 0,
			rowsTotal = 0
		}
--		s = s .. i .. ": " .. tostring(state.expanded) .. ", " .. state.nrOfChildRows .. ", " .. rowsLeft .. "\n"
		
		rowsLeft = rowsLeft - 1
	
		-- if the target index reached 0, we return the current row's state
		if rowsLeft == 0 then
			if not rowStates[i] then
				return rowsLeft, false, s
			end
			return rowsLeft, rowStates[i].expanded, s
		end
		
		-- if this row is expanded, we have to go through the child rows as well
		if rowStates[i] and rowStates[i].expanded then
			local isExpanded = false
			rowsLeft, isExpanded, s2 = LibMT:IsExpandedHelper(menu, rowStates[i].childStates, rowStates[i].nrOfChildRows, rowsLeft, indentLevel + 1)
			s = s .. s2
			
			-- then, if there are no more rows left, we can return
			if rowsLeft == 0 then
				return rowsLeft, isExpanded, s
			end
		end
	end
	
	return rowsLeft, false, s
end




function LibMT:CreateDefaultCenterButton(label, selectable, colour, fontSize, isBold)
	colour = colour or self.colours.white
	local text = Helper.createButtonText(label, "center", (isBold and Helper.standardFontBold) or Helper.standardFont, fontSize or Helper.standardFontSize, colour.r, colour.g, colour.b, colour.a)
	return Helper.createButton(text, nil, false, selectable, 0, 0, 0, Helper.standardTextHeight)
end

function LibMT:CreateDefaultButtonBarButton( label, selectable, hotkey, colour, fontSize, width, offsetY )
	colour = colour or LibMT.colours.white
	local text = Helper.createButtonText( label, "center", Helper.standardFont, fontSize or 11, colour.r, colour.g, colour.b, colour.a )
	return Helper.createButton(text, nil, false, selectable, 0, offsetY or 0, width or 150, 25, nil, hotkey)
end

function LibMT:CheckButtonBarAvailability(menu, rowIdx, rowData)
	local buttons = menu.buttons
	if buttons then
		local buttontable = menu.buttontable
		for _, button in ipairs(buttons) do
			if button and button.label then
				Helper.removeButtonScripts(menu, buttontable, button.row, button.col)
				local selectable = button.availabilityProvider(menu, rowIdx, rowData)
				local offsetY = (button.row == 2 and 10) or 0
				local hotkey = nil
				if button.hotkey ~= "" then
					hotkey = Helper.createButtonHotkey(button.hotkey, true)
				end
				local b = LibMT:CreateDefaultButtonBarButton(button.label, selectable, hotkey, nil, nil, nil, offsetY)
				SetCellContent(buttontable, b, button.row, button.col)
				Helper.setButtonScript(menu, nil, buttontable, button.row, button.col, function () button.script(menu, rowIdx, rowData) end)	
			end
		end
	end
end

function LibMT:SetSelectedRow(menu)
	local topRow = menu.topRow
--	if topRow and topRow.idx then
		-- we have to trigger the onRowChanged event here for the topmost row,
		-- since we will have swallowed it
--		menu.onRowChanged(topRow.idx, topRow.data)
--	else
--		menu.onRowChanged(menu.selectedRow.idx, menu.selectedRow.data)
--		menu.selectedRow = nil
--	end
end




-- Library function that returns a header (title) descriptor and the height of the header
LibMT.create_standard_header = function( menu, title, subtitle, additional_rows, scale, bgColour, custom_rows )
	-- assign our basic table info to a local variable
	local setup = Helper.createTableSetup(menu)
	local spacer = 3
	local headerHeight = Helper.headerRow1Height + spacer
	-- set up the menu title row
	setup.addTitleRow(setup, {
		Helper.createFontString(
			title, 											-- the main title text of our window
			false, 											-- don't scale the text
			"left", 										-- horizontal alignment
			255, 255, 255, 100,								-- The text colour R,G,B,Alpha 
			Helper.headerRow1Font, 							-- The predefined row 1 font
			Helper.headerRow1FontSize, 						-- The predefined row 1 font size (see detailmonitorhelper\helper.lua
			false, 											-- Don't wrap the text
			Helper.headerRow1Offsetx, 						-- Predefined x offset
			Helper.headerRow1Offsety, 						-- Predefined y offset
			Helper.headerRow1Height, 						-- Predefined row 1 height
			Helper.headerRow1Width)							-- Predefined row 1 width
	}, nil, {1}, scale or false, bgCol or Helper.defaultTitleBackgroundColor)

	-- set up the menu sub-title row if one has been requested
	if subtitle then
		for k,text in ipairs(subtitle) do
			setup.addTitleRow(	setup, 
			{ 
				Helper.createFontString( text, false, "left", 255, 255, 255, 100, Helper.headerRow2Font, Helper.headerRow2FontSize, 
				false, Helper.headerRow2Offsetx, Helper.headerRow2Offsety, Helper.headerRow2Height, Helper.headerRow1Width )
			}, nil, {1}, scale or false, bgCol or Helper.defaultTitleBackgroundColor)
			headerHeight = headerHeight + Helper.headerRow2Height + spacer
		end
	end		
	
	-- Add custom blank rows if requested
	if custom_rows and #custom_rows > 0 then
		for i,row in ipairs(custom_rows) do
			setup.addTitleRow( setup, { row }, 
			nil, {1}, scale or false, bgCol or Helper.defaultTitleBackgroundColor )
			headerHeight = headerHeight + Helper.headerRow2Height + spacer
		end
	end
	-- Add additional blank rows if requested
	if additional_rows and #additional_rows > 0 then
		for i = 1, #additional_rows, 1 do
			setup.addTitleRow( setup, { Helper.createFontString( "", false, "left", 255, 255, 255, 100, Helper.headerRow2Font, Helper.headerRow2FontSize, 
			false, Helper.headerRow2Offsetx, Helper.headerRow2Offsety, Helper.headerRow2Height, Helper.headerRow1Width ) }, 
			nil, {1}, scale or false, bgCol or Helper.defaultTitleBackgroundColor )
			headerHeight = headerHeight + Helper.headerRow2Height + spacer
		end
	end


	-- return the header setup function and the height of the header table
	return setup.createCustomWidthTable(setup, {
		[1] = 0
	}, false), headerHeight
end

-- Library function that returns a header (title) descriptor and the height of the header
LibMT.create_column_header = function( menu, title_elements, subtitle, additional_rows, colWidths, colspans, dontscaletable, scale, bgColour )
	-- assign our basic table info to a local variable
	local setup = Helper.createTableSetup(menu)
	local spacer = 3
	local headerHeight = Helper.headerCharacterIconSize + spacer
	local fixedRows = 0
	local sawNonFixedRow = false
	-- set up the menu title row
	setup.addTitleRow(setup, title_elements, nil, colspans, scale or false, bgCol or Helper.defaultTitleBackgroundColor)

	-- set up the menu sub-title row if one has been requested
	if subtitle then
		for k,text in ipairs(subtitle) do
			setup.addTitleRow(	setup, 
			{ 
				Helper.createFontString( text, false, "left", 255, 255, 255, 100, Helper.headerRow2Font, Helper.headerRow2FontSize, 
				false, Helper.headerRow2Offsetx, Helper.headerRow2Offsety, Helper.headerRow2Height, Helper.headerRow1Width )
			}, nil, {#colWidths}, scale or false, bgCol or Helper.defaultTitleBackgroundColor)
			headerHeight = headerHeight + Helper.headerRow2Height + spacer
		end
	end		
	
	-- Add additional rows if requested
	for rowIdx, row in ipairs(additional_rows) do
		local elements, colspans = {}, {}
		local colIdx = 1
		for _, cell in ipairs(row.cells) do
			table.insert(elements, cell.element)
			table.insert(colspans, cell.colspan)
			if cell.script then
				local curColIdx = colIdx -- for closure
				table.insert(cell_scripts, function()
					if cell.type == "button" then
						Helper.setButtonScript(menu, nil, menu.selecttable, rowIdx, curColIdx, function () cell.script(rowIdx, colIdx) end) 
					end
					if cell.type == "editBox" then
						Helper.setEditBoxScript(menu, nil, menu.selecttable, rowIdx, curColIdx, function (_, text, textchanged) cell.script(_, text, textchanged, rowIdx, colIdx) end) 
					end
				end)
			end
			colIdx = colIdx + cell.colspan
		end
		
		if row.isFixed then
			assert(not sawNonFixedRow, "Cannot add fixed rows after non-fixed rows")
			fixedRows = fixedRows + 1
		else
			sawNonFixedRow = true
			
			-- we save either the topmost or the last selected row
--			menu.topRow = menu.topRow or menu.selectrow or {
--				idx = rowIdx,
--				data = row.data
--			}
		end
		
		assert(colIdx - 1 == #colWidths, "Missmatch in nr of colWidths (" .. #colWidths .. ") and provided colspans (" .. colIdx - 1 .. ") in row " .. rowIdx .. "")
		
		setup.addTitleRow(setup, elements, row.data, colspans, scale or false, Helper.defaultTitleBackgroundColor)
		headerHeight = headerHeight + Helper.headerRow2Height + spacer
	end

	-- return the header setup function and the height of the header table
	local isColumnWidthsInPercent = false
	local doNotScale = dontscaletable or false
	local isBorderEnabled = true
	local tabOrder = nil
	local fixedRows = 0
	local offsetX = 0
	local offsetY = 0
	local height = 0 -- headerHeight -- stretch to fill
	
	return setup.createCustomWidthTable(setup, colWidths, isColumnWidthsInPercent, doNotScale, isBorderEnabled, tabOrder, fixedRows, offsetX, offsetY, height), headerHeight
end

-- Library function to create standard body section with collapsible rows from a pre-built row collection table
LibMT.create_body = function( menu, row_collection, cell_scripts, colWidths, enable_border, doNotScale, headerHeight, bodyHeight, toprow, selrow )
	local setup = Helper.createTableSetup( menu )
	local fixedRows = 0
	local sawNonFixedRow = false

	for rowIdx, row in ipairs(row_collection) do
		local elements, colspans = {}, {}
		local colIdx = 1
		for _, cell in ipairs(row.cells) do
			table.insert(elements, cell.element)
			table.insert(colspans, cell.colspan)
			if cell.script then
				local curColIdx = colIdx -- for closure
				table.insert(cell_scripts, function()
					if cell.type == "button" then
						Helper.setButtonScript(menu, nil, menu.selecttable, rowIdx, curColIdx, function () cell.script(rowIdx, colIdx) end) 
					end
					if cell.type == "editBox" then
						Helper.setEditBoxScript(menu, nil, menu.selecttable, rowIdx, curColIdx, function (_, text, textchanged) cell.script(_, text, textchanged, rowIdx, colIdx) end) 
					end
				end)
			end
			colIdx = colIdx + cell.colspan
		end
		
		if row.isFixed then
			assert(not sawNonFixedRow, "Cannot add fixed rows after non-fixed rows")
			fixedRows = fixedRows + 1
		else
			sawNonFixedRow = true
		end
		
		assert(colIdx - 1 == #colWidths, "Missmatch in nr of colWidths (" .. #colWidths .. ") and provided colspans (" .. colIdx - 1 .. ") in row " .. rowIdx .. "")
		if row.isFixed then
			setup.addHeaderRow(setup, elements, row.data, colspans, false, row.bgColor)
		else
			setup.addSimpleRow(setup, elements, row.data, colspans, false, row.bgColor)
		end
	end
	
	local isColumnWidthsInPercent = false
	local doNotScale = doNotScale or false
	local isBorderEnabled = enable_border and true
	local tabOrder = 1
	local offsetX = 0
	local offsetY = headerHeight
	local toprow = toprow or nil
	local selrow = selrow or nil
	
	local desc = setup.createCustomWidthTable(setup, colWidths, isColumnWidthsInPercent or false, doNotScale, 
											isBorderEnabled, tabOrder, fixedRows, offsetX, offsetY, bodyHeight, false, toprow, selrow)
	return desc
end

-- Library function that returns a standard two-row button bar descriptor
LibMT.create_standard_button_bar = function( menu, buttons, headerHeight, bodyHeight )

	local setup = Helper.createTableSetup(menu)
	local uiButtons = {}
	local emptyCell = Helper.getEmptyCellDescriptor()
	
	for i, button in ipairs(buttons) do
		if button and button.label then
			button.hotkey = button.hotkey or LibMT.hotkeys[i]
			local hotkey = nil
			if button.hotkey ~= "" then
				hotkey = Helper.createButtonHotkey(button.hotkey, true)
			end
			local offsetY = (i > 4 and 10) or 0
			local b = LibMT:CreateDefaultButtonBarButton( button.label, false, hotkey, nil, nil, nil, offsetY )
			table.insert(uiButtons, b)
		else
			table.insert(uiButtons, emptyCell)
		end
	end
	
	-- create first line of buttons
	local row1buttons = { emptyCell }
	for i = 1, 4 do
		if uiButtons[i] and uiButtons[i] ~= emptyCell then
			table.insert(row1buttons, uiButtons[i])
			buttons[i].row = 1
			buttons[i].col = 2 * i
		else
			table.insert(row1buttons, emptyCell)
		end
		table.insert(row1buttons, emptyCell)
	end
	
	-- create second line of buttons
	local row2buttons = { emptyCell }
	for i = 5, 8 do
		if uiButtons[i] and uiButtons[i] ~= emptyCell then
			table.insert(row2buttons, uiButtons[i])
			buttons[i].row = 2
			buttons[i].col = 2 * (i - 4)
		else
			table.insert(row2buttons, emptyCell)
		end
		table.insert(row2buttons, emptyCell)
	end
	
	setup.addSimpleRow(setup, row1buttons, nil, nil, false, LibMT.colours.transparent)
	setup.addSimpleRow(setup, row2buttons, nil, nil, false, LibMT.colours.transparent)
	
	
	local colWidths = { 48,150,48,150,0,150,48,150,48 }
	local isColumnWidthsInPercent = false
	local doNotScale = false
	local isBorderEnabled = true
	local tabOrder = 2
	local fixedRows = 2
	local offsetX = 0
	local offsetY = headerHeight + bodyHeight
	local height = 0 -- stretch to fill
	
	return setup.createCustomWidthTable(setup, colWidths, isColumnWidthsInPercent, doNotScale, isBorderEnabled, tabOrder, fixedRows, offsetX, offsetY, height, false)
end

-- Library function to create a simple list body
LibMT.create_section = function( setup, name, header, array, nonetext)
	-- Handle list being empty
	if #array == 0 then
		setup:addSimpleRow({
			[1] = nonetext
		})
	else
		-- add row entry for each item in the table
		for i, component in ipairs(array) do
			setup:addSimpleRow({
				[1] = GetComponentData(component, "name")
			}, component)
		end
	end	
	return
end



-- Functions for querying and manipulating ships
LibMT.filter_ships = function( ships, args )
--[[	Parameters:
			ships - a table of ships
			args - a table of strings that indicate the type of ship to remove from the list
		Returns:
			a table of ships with the requested ship types removed
--]]
	for i = #ships, 1, -1 do
		for _, arg in ipairs(args) do
			if arg == "commander" then
				local commander = GetCommander(ships[i])
				-- if the ship is assigned to another commander (ship or station) then remove from list
				if commander then
					table.remove(ships, i)
					break
				end
			elseif arg == "playership" then
				-- remove the player ship
				if IsSameComponent(ships[i],GetPlayerPrimaryShipID()) then
					table.remove(ships, i)
					break
				end
			elseif arg == "drone" then
				-- remove drones
				if IsComponentClass(ships[i], "drone") then
					table.remove(ships, i)
					break
				end
			elseif arg == "ship_s" then
				-- remove small ships
				if IsComponentClass(ships[i], "ship_s") then
					table.remove(ships, i)
					break
				end
			elseif arg == "ship_m" then
				-- remove medium ships
				if IsComponentClass(ships[i], "ship_m") then
					table.remove(ships, i)
					break
				end
			elseif arg == "ship_xs" then
				-- remove extra small ships
				if IsComponentClass(ships[i], "ship_xs") then
					table.remove(ships, i)
					break
				end
			elseif arg == "ship_xl" then
				-- remove extra large ships
				if IsComponentClass(ships[i], "ship_xl") then
					table.remove(ships, i)
					break
				end
			elseif arg == "ship_l" then
				-- remove large ships
				if IsComponentClass(ships[i], "ship_l") then
					table.remove(ships, i)
					break
				end
			elseif arg == "battleship" then
				-- remove ships with only one cargo bay (i.e. fuel ergo battleships)
				local storage = GetStorageData(ships[i])
				local numberofbays = 0
				local next = next
				if next(storage) ~= nil then
					for i, cargobaytype in ipairs(storage) do
						numberofbays = numberofbays + 1
					end
				end
				if numberofbays < 2 then
					table.remove( ships, i)
					break
				end
			elseif arg == "cv" then
				local macro_string = GetComponentData(ships[i], "macro")
				if string.find(macro_string, "units_size_xl_builder_ship") then
					table.remove( ships, i )
					break
				end
			end
		end
	end
	return( ships )
end

LibMT.filter_ships_bydrones = function( ships, dronetype, min_req )
--[[ 	Parameters:
			ships - a table of ships to filter 
			dronetype - a string describing the drone to look for 
			min_req - an integer that is the amount (at least) that the ship should have
		Returns:
			a table of ships with at least the required number of drones of dronetype
--]]
	for i = #ships, 1, -1 do
		local shipunits = GetUnitStorageData(ships[i])
		local hasdrones = false
		local macroname = ""
		if dronetype == "cargo" then
			macroname = "units_size_xs_transp_empty_macro"
		end
		if IsComponentClass(ships[i], "ship_l") or IsComponentClass(ships[i], "ship_xl") then
			for _, entry in ipairs(shipunits) do
				if entry.macro == macroname and min_req <= entry.amount then
					hasdrones = true
				end
			end
		end
		if hasdrones == false then
			table.remove( ships, i )
		end
	end
	return ships
end

LibMT.remove_ships_with_no_crew = function( ships )
	for i = #ships, 1, -1 do
		local captain, defence, engineer = GetComponentData( ships[i], "pilot", "defencenpc", "engineer" )
--		if captain == nil or defence == nil or engineer == nil then
		if captain == nil then
			table.remove( ships, i ) 
		end
	end
	return ships
end

LibMT.get_crew_level = function( ship )
	local captain, defence, engineer = GetComponentData( ship, "pilot", "defencenpc", "engineer" )
	local captain_score, defence_score, engineer_score = 0, 0, 0
	if captain then
		captain_score = GetComponentData( captain, "combinedskill")
	end
	if defence then 
		defence_score = GetComponentData( defence, "combinedskill")
	end
	if engineer then
		engineer_score = GetComponentData( engineer, "combinedskill")
	end

	-- Now calculate level based on scores
	local crewscore = captain_score + defence_score + engineer_score
	local level = 1
	if crewscore >= 200 and crewscore < 250 then
		level = 2
	elseif crewscore >= 250 then
		level = 3
	end
	return captain_score, defence_score, engineer_score, level, crewscore
end

-- Get a crew member rank index based on XP
LibMT.get_entity_rank = function( xp )
	local rank = 1
	if xp < 250000 then
		rank = 1
	elseif xp < 500000 then
		rank = 2
	elseif xp < 1000000 then
		rank = 3
	elseif xp < 2000000 then
		rank = 4
	elseif xp < 4000000 then
		rank = 5
	elseif xp < 8000000 then
		rank = 6
	else
		rank = 7
	end
	return rank
end

-- A table holding various officer ranks
LibMT.Ranks = {
				{	
					ReadText(150402,50),
					ReadText(150402,51),
					ReadText(150402,52),
					ReadText(150402,53),
					ReadText(150402,54),
					ReadText(150402,55),
					ReadText(150402,56),
				},
				{	
					ReadText(150402,60),
					ReadText(150402,61),
					ReadText(150402,62),
					ReadText(150402,63),
					ReadText(150402,64),
					ReadText(150402,65),
					ReadText(150402,66),
				},
				{
					ReadText(150402,70),
					ReadText(150402,71),
					ReadText(150402,72),
					ReadText(150402,73),
					ReadText(150402,74),
					ReadText(150402,75),
					ReadText(150402,76),
				},
			}

-- Verbose messages for ship log
LibMT.Messages = {
	NO_TRADE 								= ReadText( 150402, 420 ),	-- "Error - report to author" ,
	WP_INACTIVE								= ReadText( 150402, 421 ),	-- "Skipping waypoint due to waypoint set to inactive",
	NO_WAGES								= ReadText( 150402, 422 ),	-- "Skipping waypoint due to wages not being paid!!", 
	WAGES_PAID								= ReadText( 150402, 423 ),	-- "Wages paid - resuming duties", 
	ERR_RANGE								= ReadText( 150402, 424 ),	-- "Skipping waypoint due to waypoint being out of range for the current crew", 
	ERR_HOSTILE								= ReadText( 150402, 425 ),	-- "Skipping waypoint due to destination being hostile", 
	WP_FLYTO_NOMOVE							= ReadText( 150402, 426 ),	-- "Waypoint is fly to. Already close enough so not moving",
	WP_FLYTO								= ReadText( 150402, 427 ),	-- "Successfully flew to destination",
	WP_NULLSWEEP_NOFLY						= ReadText( 150402, 428 ),	-- "Null sweep: already safely at home so not moving",
	WP_NULLSWEEP_FLY						= ReadText( 150402, 429 ),	-- "Null sweep: flew home to safety",
	ERR_SELLOFFER_NOCASH					= ReadText( 150402, 430 ),	-- "Skipping due to not enough cash to pay for wares",
	ERR_SELLOFFER_NOWARES					= ReadText( 150402, 431 ),	-- "Skipping due to not enough wares for purchase at destination",
	ERR_SELLOFFER_COST						= ReadText( 150402, 432 ),	-- "Skipping because the wares are too expensive at the destination",
	ERR_SELLOFFER_NO_OFFER					= ReadText( 150402, 433 ),	-- "Skipping due to no wares for sale at the destination",
	ERR_SELLOFFER_NOTVIABLE_AMOUNT			= ReadText( 150402, 434 ),	-- "Skipping because the amount is too low to be worth the trip",
	ERR_SELLOFFER_DONTNEED					= ReadText( 150402, 435 ),	-- "Skipping because we already have enough of that ware on board",
	ERR_SELLOFFER_NOCARGOSPACE				= ReadText( 150402, 436 ),	-- "Skipping because we don't have enough room in the hold",
	ERR_BUYOFFER_NOTENOUGHWARES				= ReadText( 150402, 437 ),	-- "Skipping because the destination does not want enough wares",
	ERR_BUYOFFER_WONTPAY					= ReadText( 150402, 438 ),	-- "Skipping because the destination won't pay enough for the wares",
	ERR_BUYOFFER_NO_OFFER					= ReadText( 150402, 439 ),	-- "Skipping due to no buy offers at the destination",
	ERR_BUYOFFER_NOTENOUGHCARGO				= ReadText( 150402, 440 ),	-- "Skipping because we don't have enough wares on board to meet the sale",
	ERR_CANTRESERVE							= ReadText( 150402, 441 ),	-- "Skipping due to not being able to reserve enough wares",
	ERR_TARGET_INVALID						= ReadText( 150402, 442 ),	-- "Skipping as it seems that the target has been destroyed or is not functional",
	ERR_CANT_PARK							= ReadText( 150402, 443 ),	-- "Aborted because we couldn't park at the destination",
	ERR_INTRADE_FAIL						= ReadText( 150402, 444 ),	-- "Something went wrong during the trade - Egosoft - I'm looking at you!!!",
	WP_NULLSWEEP_FLYING						= ReadText( 150402, 445 ),	-- "Flying back to homebase",
}
			
--				{ 	"No Action", 		  "Load", 				"Unload", 
--					"Buy", 				 "Sell", 			  "Fly to", 			"Refuel" }
LibMT.WPType = 	{ 	ReadText(150402,167), ReadText(150402,168), ReadText(150402,169), 
					ReadText(1001,2916), ReadText(1001,2917), ReadText(150402,170), ReadText(1002,2027) }			

-- Creates a string of 1 to 5 stars as per Egosoft profile menus					
LibMT.createStarsText = function(skillvalue)
	local stars = string.rep("*", skillvalue) .. string.rep("#", 5 - skillvalue)
	return Helper.createFontString(stars, false, "left", 255, 255, 0, 100, Helper.starFont, 16)
end

			
			
LibMT.GetCargoSpecs = function( ship )
--[[
<page id="20205" title="Ware Transport Types" descr="0" voice="no">
 <t id="100">Container</t>
 <t id="200">Bulk</t>
 <t id="300">Liquid</t>
 <t id="400">Passenger</t>
 <t id="500">Equipment</t>
 <t id="600">Inventory</t>
 <t id="700">Energy</t>
 <t id="800">Fuel</t>
 <t id="900">Ship</t>
</page>
--]]
	local bulk = ReadText(20205, 200)
	local container = ReadText(20205, 100)
	local energy = ReadText(20205, 700)
	local liquid = ReadText(20205, 300)
	local fuel = ReadText(20205, 800)

	local transporttypes = {}
	local canCarryContainer, canCarryLiquid, canCarryEnergy, canCarryBulk, canCarryFuel = false, false, false, false, false
	-- Get possible waretypes for ship
	canCarryFuel = CheckSuitableTransportType(ship, "fuelcells")
	table.insert(transporttypes, (canCarryFuel and 1) or 0)

	canCarryBulk = CheckSuitableTransportType(ship, "nividium")
	table.insert(transporttypes, (canCarryBulk and 1) or 0)

	canCarryContainer = CheckSuitableTransportType(ship, "chemicalcompounds")
	table.insert(transporttypes, (canCarryContainer and 1) or 0)

	canCarryEnergy = CheckSuitableTransportType(ship, "ioncells")
	table.insert(transporttypes, (canCarryEnergy and 1) or 0)

	canCarryLiquid = CheckSuitableTransportType(ship, "ions")
	table.insert(transporttypes, (canCarryLiquid and 1) or 0)


	local num = 0
	for i,v in ipairs(transporttypes) do 
		num = num + v
	end

	if num > 4 then 
		table.insert(transporttypes, 1)
	else
		table.insert(transporttypes, 0)
	end
	
	-- Now get capacity for each transport type
	local storage = GetStorageData(ship)
	for i, cargobay in ipairs(storage) do

		if string.find(cargobay.name, bulk) and string.find(cargobay.name, energy) and string.find(cargobay.name, liquid) and string.find(cargobay.name, container) then
			-- We have universal storage so break
			local mult = transporttypes[6] * cargobay.capacity
			transporttypes[2] = mult
			transporttypes[3] = mult
			transporttypes[4] = mult
			transporttypes[5] = mult
			transporttypes[6] = mult
		end

		if cargobay.name == fuel then
			local mult = transporttypes[1] * cargobay.capacity
			transporttypes[1] = mult
		end

		if cargobay.name == bulk then
			local mult = transporttypes[2] * cargobay.capacity
			transporttypes[2] = mult
		end

		if cargobay.name == container then
			local mult = transporttypes[3] * cargobay.capacity
			transporttypes[3] = mult
		end

		if cargobay.name == energy then
			local mult = transporttypes[4] * cargobay.capacity
			transporttypes[4] = mult
		end

		if cargobay.name == liquid then
			local mult = transporttypes[5] * cargobay.capacity
			transporttypes[5] = mult
		end
	end
	return transporttypes
end

LibMT.RemoveWares = function( warelist, removetype )
	for i = #warelist, 1, -1 do
		if GetWareData(warelist[i], "transport") == removetype then
			table.remove(warelist, i)
		end
	end
	return warelist
end

LibMT.GetStationRange = function( station1, station2)
	local hzone, hsector, hcluster = GetComponentData(station1, "zone", "sector", "cluster")
	local wpzone, wpsector, wpcluster = GetComponentData(station2, "zone", "sector", "cluster")
	local wprange = 1
--	DebugError( "H Zone:  " .. hzone .. "  H Sector:  " .. hsector .. " H Cluster:  " .. hcluster )
--	DebugError( "WP Zone:  " .. wpzone .. "  WP Sector:  " .. wpsector .. " WP Cluster:  " .. wpcluster )
	if hsector == wpsector then
		wprange = 1
	elseif hcluster == wpcluster then
		wprange = 2
	else
		wprange = 3
	end
	return wprange
end

-- Functions for querying and manipulating stations
LibMT.CompareStationWarelist = function( resources, products, tradewares, cargolist ) 
	local ship_res, ship_prod, ship_trade, ship_all = {}, {}, {}, {}
	if cargolist[6] > 0 then -- cargo is universal so all wares are valid
		local temp = LibMT.deepcopy(LibMT.Set.Symmetric( resources, products ))
		ship_all = LibMT.deepcopy(LibMT.Set.Symmetric( ship_all, temp))
		local canRefuel = false
		for i, ware in ipairs(ship_all) do
			if GetWareData(ware, "transport") == "fuel" then
				canRefuel = true
				table.remove(ship_all, i)
				for i, ware in ipairs(products) do
					if GetWareData(ware, "transport") == "fuel" then
						table.remove(products, i)
					end
				end
			end
		end
		return resources, products, tradewares, ship_all, canRefuel
	end
	
	-- cargolist 1 is fuel
	if cargolist[1] > 0 then
		for i, ware in ipairs(resources) do
			if GetWareData(ware, "transport") == "fuel" then
				table.insert(ship_res, ware)
			end
		end
		for i, ware in ipairs(products) do
			if GetWareData(ware, "transport") == "fuel" then
				table.insert(ship_all, ware)
			end
		end
	end
	
	-- Get bulk wares 
	if cargolist[2] > 0 then
		for i, ware in ipairs(resources) do
			if GetWareData(ware, "transport") == "bulk" then
				table.insert(ship_res, ware)
			end
		end
		for i, ware in ipairs(products) do
			if GetWareData(ware, "transport") == "bulk" then
				table.insert(ship_prod, ware)
			end
		end
		for i, ware in ipairs(tradewares) do
			if GetWareData(ware, "transport") == "bulk" then
				table.insert(ship_trade, ware)
			end
		end
	end
	if cargolist[3] > 0 then
		for i, ware in ipairs(resources) do
			if GetWareData(ware, "transport") == "container" then
				table.insert(ship_res, ware)
			end
		end
		for i, ware in ipairs(products) do
			if GetWareData(ware, "transport") == "container" then
				table.insert(ship_prod, ware)
			end
		end
		for i, ware in ipairs(tradewares) do
			if GetWareData(ware, "transport") == "container" then
				table.insert(ship_trade, ware)
			end
		end
	end
	if cargolist[4] > 0 then
		for i, ware in ipairs(resources) do
			if GetWareData(ware, "transport") == "energy" then
				table.insert(ship_res, ware)
			end
		end
		for i, ware in ipairs(products) do
			if GetWareData(ware, "transport") == "energy" then
				table.insert(ship_prod, ware)
			end
		end
		for i, ware in ipairs(tradewares) do
			if GetWareData(ware, "transport") == "energy" then
				table.insert(ship_trade, ware)
			end
		end
	end
	if cargolist[5] > 0 then
		for i, ware in ipairs(resources) do
			if GetWareData(ware, "transport") == "liquid" then
				table.insert(ship_res, ware)
			end
		end
		for i, ware in ipairs(products) do
			if GetWareData(ware, "transport") == "liquid" then
				table.insert(ship_prod, ware)
			end
		end
		for i, ware in ipairs(tradewares) do
			if GetWareData(ware, "transport") == "liquid" then
				table.insert(ship_trade, ware)
			end
		end
	end
	
	
	local temp = LibMT.deepcopy(LibMT.Set.Symmetric( ship_res, ship_prod ))
	ship_all = LibMT.deepcopy(LibMT.Set.Symmetric( ship_all, temp))
	local canRefuel = false
	for i, ware in ipairs(ship_all) do
		if GetWareData(ware, "transport") == "fuel" then
			canRefuel = true
			table.remove(ship_all, i)
		end
	end

	return ship_res, ship_prod, ship_trade, ship_all, canRefuel
	
end

-- Utility functions
-- Table copying
LibMT.deepcopy = function (orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[LibMT.deepcopy(orig_key)] = LibMT.deepcopy(orig_value)
        end
        setmetatable(copy, LibMT.deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end





-- set manipulation
LibMT.Set = {}

-- returns true if val is found in set
LibMT.Set.Find = function( val, set )
	for _, val_ in ipairs( set ) do
--	DebugError( "Find Func Val_ = " .. tostring(val_) .. "  Comp Val = " .. tostring( val ) .. "  " .. tostring( tostring(val_) == tostring(val) ))
		if tostring(val_) == tostring(val) then
			return true
		end
	end
	return false
end
-- returns true if val is found in set
LibMT.Set.Find2 = function( val, set )
	for _, val_ in ipairs( set ) do
--	DebugError( "Find Func Val_ = " .. tostring(val_) .. "  Comp Val = " .. tostring( val ) .. "  " .. tostring( tostring(val_) == tostring(val) ))
		if val_ == val then
			return true
		end
	end
	return false
end

-- returns the union of seta and setb
LibMT.Set.Union = function( seta, setb )
	local seta = {unpack(seta)}
	for _, setb_ in ipairs( setb ) do
		if not LibMT.Set.Find( setb_, seta ) then
			table.insert( seta, setb_ )
		end
	end
	return seta
end

-- returns the intersection of seta and setButtonScript
LibMT.Set.Intersection = function( seta, setb )
	local ret_set = {}
	for _, setb_ in ipairs( setb ) do
		if LibMT.Set.Find( setb_, seta ) then
			table.insert( ret_set, setb_ )
		end
	end
	return ret_set
end

-- returns the difference between seta and setb
LibMT.Set.Difference = function( seta, setb )
	local ret_set = {}
	for _, seta_ in ipairs( seta ) do
		if not LibMT.Set.Find( seta_, setb ) then
			table.insert( ret_set, seta_ )
--			DebugError( "Adding:....  " .. tostring( seta_ ))
		end
	end
	return ret_set
end

-- returns symmetric of seta and setb i.e. all the unique values of a and b
LibMT.Set.Symmetric = function( seta, setb )
	return LibMT.Set.Difference( LibMT.Set.Union( seta, setb), LibMT.Set.Intersection( seta, setb ))
end	
	
	
-- init()

--[[	Manages the administration screen for the MT Station Logistics mod
		Version:		1.0.1
		Last Update:	2015-01-20
 --]]
-- Set up the default menu table
local menu = 	{	name = "gMT_Station_Logistics_Admin",
					statusWidth = 150,
					statusHeight = 24,
					transparent = 
					{
						g = 0,
						a = 0,
						b = 0,
						r = 0
					}
				}		

local Buttons = {}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.defaulttable = nil
	menu.buttons = nil
	menu.admin = nil
	return
end

-- standard callback function that fires on first time display of menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.admin = {}
	menu.admin.toprow = menu.param[1]						-- return toprow
	menu.admin.selrow = menu.param[2]						-- return row
	menu.admin.title = ReadText(150402,21)					-- menu.title = "MT Station Logistics - Administration"
	menu.admin.subtitle = ReadText(150402,22) 				-- "Select an option from the list below and click select"

	menu.admin.options = {
		{ReadText(150402,26), "gMT_Admin_Ship_menu"},		-- "Administer Trade Ships"
		{ReadText(150402,27), "gMT_Admin_Report_menu"},		-- Get Reports
		{ReadText(150402,28), "gMT_Admin_Config_menu"}		-- Configure
	}

	menu.admin.selection = menu.admin.options[1][2]			-- Default menu selection

	menu.display( )
	
	return
end

-- main draw/redraw function
menu.display = function ()	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}

	-- Create the menu header and get its height
	local infodesc, headerHeight = LibMT.create_standard_header( menu, menu.admin.title, {menu.admin.subtitle} )

	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {	0 }

	-- Setup table
	for _, option in ipairs(menu.admin.options) do
		local cells = {}
		local Label = option[1]
		table.insert(cells, LibMT:Cell(Label, nil, 1))
		table.insert(row_collection, LibMT:Row(cells, option, Helper.defaultHeaderBackgroundColor, false, 0))
	end

	-- create the body descriptor
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight + 6, bodyHeight - 45, menu.admin.toprow, menu.admin.selrow)

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,3102), Buttons.Select, function () return true end, "INPUT_STATE_DETAILMONITOR_X" ))
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false, "", "", 0, 0, 0,0, "both", false, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	Helper.releaseDescriptors()
	
	return 
end

-- standard callback function that fires on a row change
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.admin.selection = rowdata[2]
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
--[[
	DebugError( "Admin: onRowChanged: row = " .. tostring(row) .. 
				"   Rowdata =   " .. tostring(rowdata[2]) .. "\n" .. 
				"Helper.currentTableRow: " .. tostring(Helper.currentTableRow[menu.defaulttable]) .. 
				"\n Helper.currentDefaultTableRow: " .. tostring(Helper.currentDefaultTableRow) .. 
				"\n Menu.selection = " .. tostring(menu.selection)   )
--]]
	return
end

-- standard callback function that fires when an element is selected
menu.onSelectElement = function ()
	return 
end

-- standard callback function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuAndCancel(menu)
		menu.cleanup()
	else
		Buttons:Back()
	end
	return
end

-- Callback function for back button
Buttons.Back = function()
	Helper.closeMenuForSection(menu, false, "gMT_Admin_close", {} )
--	Helper.closeMenuAndCancel(menu)
	menu.cleanup()
	return
end

-- Callback function for select button
Buttons.Select = function()
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow
	Helper.closeMenuForSection(menu, false, menu.admin.selection, { toprow, selrow, {}, })
	menu.cleanup()
	return
end

init()

return
--[[	Manages the trader admin log screen for the MT Station Logistics mod
		Version:		1.0.1
		Last Update:	2015-01-23
 --]]
 
-- Set up the default menu table
local menu = 	{	name = "gMT_Station_Logistics_AdminLog",
					statusWidth = 150,
					statusHeight = 24,
					transparent = 
					{
						g = 0,
						a = 0,
						b = 0,
						r = 0
					}
				}		

local Buttons, Availability = {}, {}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.lastupdate = nil
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.defaulttable = nil
	menu.buttons = nil
	menu.adminlog = nil
--	menu.updateInterval = nil
	return
end

-- standard callback function that fires on first time display of menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.adminlog = {}
	menu.toprow = menu.param[1]					-- return toprow
	menu.selrow = menu.param[2]					-- return row
	menu.adminlog.ret_exp = menu.param[4]				-- return row and expand states
	menu.adminlog.trader = menu.param[7]				-- trader log for current ship for return ?? sort	
	menu.adminlog.log = menu.param[8]					-- The entire admin log	
	
	menu.adminlog.title = ReadText(150402,460)			-- menu.title = "MT Station Logistics - Admin Log"
	menu.adminlog.subtitle = ReadText(150402,461) 		-- "See all actions on Logistics Ships"
	
	menu.selectedRow = { idx = menu.selrow, data = {} }

	menu.display( )
	
	return
end

-- main draw/redraw function
menu.display = function ()	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}

	-- Setup for display
	-- Create the menu header and get its height
	local infodesc, headerHeight = LibMT.create_standard_header( menu, menu.adminlog.title, { menu.adminlog.subtitle, "" })
--	local infodesc, headerHeight = LibMT.create_column_header( menu, title, { typename }, additional, colwidth, colspan, true )

	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {			
		75,
		100,
		200,
		100,
		0
	}
	
	-- Setup main table
	-- create the body descriptor
	if 0 < #menu.adminlog.log then
		for i, msg in ipairs(menu.adminlog.log) do
			local cells = {}
			table.insert(cells, LibMT:Cell( ConvertTimeString(GetCurTime() - msg[1]), nil, 1))  -- "Time"
			table.insert(cells, LibMT:Cell( msg[2], nil, 4))  -- "Message"
			table.insert(row_collection, LibMT:Row(cells, { "none" }, Helper.defaultHeaderBackgroundColor, false, 0))
		end
	else
		local cells = {}
		table.insert(cells, LibMT:Cell( ReadText(150402, 462), nil, 5))  -- "No Admin Log messages"
		table.insert(row_collection, LibMT:Row(cells, { "none" }, Helper.defaultHeaderBackgroundColor, false, 0))
	end
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight + 14, bodyHeight + 20, menu.toprow, menu.selrow)

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false, "", "", 0, 0, 0,0, "both", false, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	Helper.releaseDescriptors()
	
	return 
end

-- standard callback function that fires on a row change
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.selectedRow.idx = row
		menu.selectedRow.data = rowdata
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

-- standard callback function that fires when an element is selected
menu.onSelectElement = function ()
	return 
end

-- standard callback function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	Buttons:Back()
	return
end

-- Callback function for back button
Buttons.Back = function()
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_returnadmin", { menu.adminlog.ret_exp[1], menu.adminlog.ret_exp[2], {}, menu.adminlog.ret_exp, {}, {}, menu.adminlog.trader, menu.adminlog.log } )
	menu.cleanup()
	return
end


init()

return
-- Manages config screen for MT Station Logistics mod
 
-- Set up the default menu table
local menu = 	{	name = "gMT_Station_Logistics_Configure",
					statusWidth = 150,
					statusHeight = 24,
					transparent = 
					{
						g = 0,
						a = 0,
						b = 0,
						r = 0
					}
				}		

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	return
end

-- local holder for buttons tasks and availability
local Buttons, Availability = {}, {}

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.defaulttable = nil
	menu.config = nil
	menu.buttons = nil
	return
end

-- function to handle displaying the menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.config = {}
	menu.config.toprow = menu.param[4][1]
	menu.config.selrow = menu.param[4][2]
	menu.config.currentdbg = menu.param[4][3]
	
	menu.config.title 		= ReadText(150402,81)			-- menu.title = "MT Station Logistics - Administration"
	menu.config.subtitle 	= ReadText(150402,82) .. "   " .. ReadText(150402,9001) .. " - " .. ReadText(150402, 9001 + 1 + menu.config.currentdbg)
	if LibMT.DEBUG then
		menu.config.options = {
			{ReadText(150402,83), "gMT_ConfigMenu_debug-error", 0},
			{ReadText(150402,84), "gMT_ConfigMenu_debug-info", 1},
			{ReadText(150402,85), "gMT_ConfigMenu_debug-detail", 2},
			{ReadText(150402,86), "gMT_ConfigMenu_debug-verbose", 3},
			{ReadText(150402,87), "gMT_ConfigMenu_uninstall", 0},
			{ReadText(150402,88), "gMT_ConfigMenu_reset", 0}
		}
	else
		menu.config.options = {
			{ReadText(150402,87), "gMT_ConfigMenu_gMT_ConfigMenu_uninstall", 0},
		}
	end
--	menu.config.selection = menu.config.options[1][2]
--	menu.config.debug_num = menu.config.options[1][3]
	
	-- display our menu
	menu.display( )
	
	return
end

menu.display = function ()	
	-- menu setup
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}

	
	-- Create the menu header and get its height
	local infodesc, headerHeight = LibMT.create_standard_header( menu, menu.config.title, {menu.config.subtitle} )

	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {	0 }

	-- Setup table
	for _, option in ipairs(menu.config.options) do
		local cells = {}
		local Label = option[1]
		table.insert(cells, LibMT:Cell(Label, nil, 1))
		table.insert(row_collection, LibMT:Row(cells, option, Helper.defaultHeaderBackgroundColor, false, 0))
	end

	-- create the body descriptor
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight+6, bodyHeight - 45)

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,3102), Buttons.Select, function () return true end, "INPUT_STATE_DETAILMONITOR_X" ))
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false, "", "", 0, 0, 0,0, "both", false, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	Helper.releaseDescriptors()

	return 
end

-- standard function stub to handle changing row
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.config.selection = rowdata[2]
		menu.config.debug_num = rowdata[3]
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

menu.onSelectElement = function ()
	return 
end

-- standard function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuAndCancel(menu)
		menu.cleanup()
	else
		Buttons:Back()
		menu.cleanup()
	end

	return
end

-- Callback function for back button
Buttons.Back = function()
	-- return with saved row selections
	Helper.closeMenuForSection(menu, false, "gMT_Admin_Config_return", { menu.config.toprow, menu.config.selrow })
	menu.cleanup()
	return
end

-- Callback function for select button
Buttons.Select = function()
	Helper.closeMenuForSection(menu, false, menu.config.selection, { menu.config.toprow, menu.config.selrow, menu.config.debug_num })
	menu.cleanup()
	return
end


init()

return
--[[	Manages the crew training and log screen for the MT Station Logistics mod
		Version:		1.0.1
		Last Update:	2015-01-23
 --]]
 
-- Set up the default menu table
local menu = 	{	name = "gMT_Station_Logistics_CrewLog",
					statusWidth = 150,
					statusHeight = 24,
					transparent = 
					{
						g = 0,
						a = 0,
						b = 0,
						r = 0
					}
				}		

local Buttons, Availability = {}, {}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.defaulttable = nil
	menu.buttons = nil
	menu.crew = nil
	return
end

-- standard callback function that fires on first time display of menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.crew = {}
	menu.toprow = menu.param[1]						-- return toprow
	menu.selrow = menu.param[2]						-- return row
	menu.crew.ret_exp = menu.param[4]				-- return row and expand states
	menu.crew.crewdata = menu.param[3]				-- data for selected crew member
	menu.crew.entity = menu.crew.crewdata[2]		-- entity
	menu.crew.crewlog = GetNPCBlackboard(menu.crew.entity, "$XRCLS")
	
	menu.crew.title = ReadText(150402,301)			-- menu.title = "MT Station Logistics - Crew"
	menu.crew.subtitle = ReadText(150402,302) 		-- "Train your crew member"

	menu.selectedRow = { idx = menu.selrow, data = {} }

	menu.display( )
	
	return
end

-- main draw/redraw function
menu.display = function ()	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}

	-- Setup for display
	local name, entity_type, typeicon, typename, ownericon, skills = GetComponentData(menu.crew.entity, "name", "typestring", "typeicon", "typename", "ownericon", "skills")
	local rank = ReadText(150402,44)   -- "No Rank"
	if entity_type == "commander" then
		rank = LibMT.Ranks[1][LibMT.get_entity_rank(menu.crew.crewlog[4])] -- menu.crew.crewlog[4]
	elseif entity_type == "defencecontrol" then
		rank = LibMT.Ranks[2][LibMT.get_entity_rank(menu.crew.crewlog[4])]
	elseif entity_type == "engineer" then
		rank = LibMT.Ranks[3][LibMT.get_entity_rank(menu.crew.crewlog[4])]
	else
		rank = ReadText(150402,44)   -- "No Rank"
	end

	title = {Helper.createIcon(typeicon, false, 255, 255, 255, 100, 0, 0, Helper.headerCharacterIconSize, Helper.headerCharacterIconSize),
	Helper.createFontString(rank .. " " .. name, false, "left", 255, 255, 255, 100, Helper.headerRow1Font, Helper.headerRow1FontSize),
	Helper.createIcon(ownericon, false, 255, 255, 255, 100, 0, 0, Helper.headerCharacterIconSize, Helper.headerCharacterIconSize) 
	}
	local colwidth = {
						Helper.scaleX(Helper.headerCharacterIconSize),
						0,
						Helper.scaleX(Helper.headerCharacterIconSize) + 37
					}
	local colspan = {1,1,1}
	local additional = {}
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,303) .. ":", nil, 1))  -- "Flying Time"
	table.insert(cells, LibMT:Cell(ConvertTimeString(  menu.crew.crewlog[2] ), nil, 1))   --  menu.crew.crewlog[2]
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,304) .. ":", nil, 1))  -- "Salary Earned"
	local money = ConvertMoneyString( menu.crew.crewlog[3], false, true, nil, true) .. " Cr" -- menu.crew.crewlog[3]
	table.insert(cells, LibMT:Cell(money, nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,305) .. ":", nil, 1))  -- "Experience points left to spend"
	table.insert(cells, LibMT:Cell(ConvertIntegerString(menu.crew.crewlog[5],true, 4, true), nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
--	table.insert(cells, LibMT:Cell(ReadText(150402,305) .. ":", nil, 1))  -- "XP needed:"
	-- "1st star - 25K xp;   2nd star - 50K xp;   3rd star - 100K xp;   4th star - 200K xp;   5th star - 400K xp;"
	table.insert(cells, LibMT:Cell(ReadText(150402,306), nil, 2))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	
	-- Create the menu header and get its height
	local infodesc, headerHeight = LibMT.create_column_header( menu, title, { typename }, additional, colwidth, colspan, true )

	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {			
		Helper.standardButtonWidth,
		0,
		176,
		Helper.standardButtonWidth
	}

	-- Setup main table
	-- Header Row
	local cells = {}
	table.insert(cells, LibMT:Cell( ReadText(1001, 1918), nil, 2) )
	table.insert(cells, LibMT:Cell( "", nil, 2) )
	table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))

	-- Sort the skill table by relevance
	table.sort(skills, function (a, b)
		return b.relevance < a.relevance
	end)
	local playermoney = GetPlayerMoney()
	local skillpoints = menu.crew.crewlog[5]
	local skillbuy = { 25000, 50000, 100000, 200000, 400000, 0 }
		
	-- Skill table
	for _,skill in ipairs(skills) do
		local moneyneeded = skillbuy[skill.value + 1] * 100
		local skillpointsneeded = skillbuy[skill.value + 1]
		local cells = {}
		local bolded = false
		if 0 < skill.relevance then
			bolded = true
		end
		local skilltext = Helper.createFontString(ReadText(1013, skill.textid), false, "left", 255, 255, 255, 100, (bolded and Helper.standardFontBold) or Helper.standardFont)
		local skillstars = LibMT.createStarsText(skill.value)
		table.insert(cells, LibMT:Cell( skilltext, nil, 2) )
		table.insert(cells, LibMT:Cell( skillstars, nil, 2) )
		table.insert(row_collection, LibMT:Row(cells, {skill.value, skill.relevance, moneyneeded, skillpointsneeded, skillpoints, playermoney, skill.name}, Helper.defaultHeaderBackgroundColor, false, 0))
	end

	-- create the body descriptor
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight + 14, bodyHeight - 45, menu.toprow, menu.selrow)

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	if LibMT.DEBUG then
		table.insert(menu.buttons, LibMT:BarButton("(DBG) Give XP", Buttons.Test, function () return true end, "INPUT_STATE_DETAILMONITOR_BACK" ))
	else
		table.insert(menu.buttons, LibMT:BarButton())
	end
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,1114), Buttons.Rename, function () return true end, "INPUT_STATE_DETAILMONITOR_Y"))
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,45), Buttons.Select, Availability.Select, "INPUT_STATE_DETAILMONITOR_X" )) -- Train
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false, "", "", 0, 0, 0,0, "both", false, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	Helper.releaseDescriptors()
	
	return 
end

-- standard callback function that fires on a row change
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.selectedRow.idx = row
		menu.selectedRow.data = rowdata
		menu.crew.training_data = rowdata
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

-- standard callback function that fires when an element is selected
menu.onSelectElement = function ()
	return 
end

-- standard callback function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	Buttons:Back()
	return
end

-- Callback function for back button
Buttons.Back = function()
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_returncrew", { menu.crew.ret_exp[1], menu.crew.ret_exp[2], {}, menu.crew.ret_exp, {}, {} } )
	menu.cleanup()
	return
end

-- Callback function for train button
Buttons.Select = function()
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_train", {  toprow, selrow, 
																		menu.crew.crewdata, menu.crew.ret_exp, menu.crew.training_data })
	menu.cleanup()
	return
end

-- Callback function for rename button
Buttons.Rename = function()
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_rename", {  toprow, selrow, 
																		menu.crew.crewdata, menu.crew.ret_exp, menu.crew.training_data })
	menu.cleanup()
	return
end

-- Callback function - Test to give XP to crew for testing
Buttons.Test = function()
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_testxp", {  toprow, selrow, 
																		menu.crew.crewdata, menu.crew.ret_exp, menu.crew.training_data })
	menu.cleanup()
	return
end

-- Availability provider for the train button
Availability.Select = function(menu, rowIdx, rowData )
	return 0 < rowData[2] and rowData[1] < 5  and rowData[4] < rowData[5] and rowData[3] < rowData[6]
end

-- {skill.value, skill.relevance, moneyneeded, skillpointsneeded, skillpoints, playermoney, skill.name }



init()

return
-- Manages Waypoint Configuration for MT Station Logistics mod
 
-- GLOBALS
-- List of waypoint types

 
-- Set up the default menu table
local menu = {	name = "gMT_Station_Logistics_EditWaypoint",
				statusWidth = 150,
				statusHeight = 24,
				transparent = {
				g = 0,
				a = 0,
				b = 0,
				r = 0			}
	}

local Buttons, Availability, Utility = {}, {}, {}
	
-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}

	table.insert(Menus, menu)

	if Helper then
		Helper.registerMenu(menu)
	end

	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.updateInterval = nil
--	menu.title = nil
--	menu.subtitle = nil
--	menu.subtitle2 = nil
--	menu.subtitle3 = nil
--	menu.ret_arg = nil
--	menu.waypointType = nil
--	menu.revwaypointType = nil
--	menu.selectedWPType = nil
--	menu.selectedModifier = nil
--	menu.modifierType = nil
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.waypoint = nil
--	menu.wp_station = nil
--	menu.ware = nil
--	menu.temp = nil
--	menu.trader = nil
--	menu.warelist = nil
--	menu.cargo = nil
--	menu.homebase = nil
--	menu.wprange = nil
	menu.buttons = nil
	menu.bool = nil
	menu.ware = nil
	menu.wpedit = nil
	return
end

-- function to handle displaying the menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.bool = 				{} -- empty table for grouping our menu switches
	menu.ware = 				{}
	menu.wpedit = 				{} 
	
	menu.toprow = 				menu.param[1]
	menu.selrow = 				menu.param[2]
	menu.wpedit.toggle =		0
	
	menu.wpedit.ret_arg = 		menu.param[4]

	menu.wpedit.wp_action = 	menu.param[4][4] or ""
	menu.wpedit.trader = 		menu.param[6]
	menu.wpedit.waypoint = 		menu.param[7]
	menu.wpedit.warelist = 		menu.param[8] or {}
	menu.wpedit.newstation = 	menu.param[9]

	menu.wpedit.cargo = 		menu.wpedit.trader[3]
	menu.wpedit.homebase = 		menu.wpedit.trader[2]


	menu.bool.IsWPActive =		menu.wpedit.waypoint[2] or 1
	menu.wpedit.wp_station = 	menu.wpedit.waypoint[3]
	menu.ware.ware = 			menu.wpedit.waypoint[5]


	menu.bool.stationchanged = false
--	menu.wpedit.waypointType = { 	"No Action", "Load", "Unload", "Buy", "Sell", "Fly to", "Refuel" }
	menu.wpedit.waypointType = { ReadText(150402,167), ReadText(150402,168), ReadText(150402,169), 
									ReadText(1001,2916), ReadText(1001,2917), ReadText(150402,170), ReadText(1002,2027) }

--	DebugError( "Menu.param[5][5] = " .. tostring(menu.param[5][5] ) )
	if menu.wpedit.newstation then 
		-- determine if the station has been changed or not
		menu.bool.stationchanged = true
		menu.wpedit.wp_station = 	menu.wpedit.newstation
	end
	
	menu.wpedit.title = 		ReadText(150402,21)			-- menu.title = "MT Station Logistics - Administration"
	
	if menu.wpedit.wp_action == "addwaypoint" then
		menu.wpedit.subtitle = 		ReadText(150402,222)		-- "Add Waypoint"
	else
		menu.wpedit.subtitle = 		ReadText(150402,221)		-- "Edit Waypoint"
	end
	menu.wpedit.subtitle3 = ""

	Utility.RecheckMenu( menu.bool.stationchanged, true, true, true, true, true ) -- Recheck all at start
	-- Good to go!
	menu.display()
end

-- Main redraw function
menu.display = function ()	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}
	-- Setup the header block
	local title_txt = menu.wpedit.title .. " - " .. menu.wpedit.subtitle
	local subtitle2 = ReadText(150402,173) .. ": " .. GetComponentData(menu.wpedit.trader[1], "name") .. " -- " .. ReadText(150402,174) .. ": " .. GetComponentData(menu.wpedit.trader[2], "name")
	local infodesc, headerHeight = LibMT.create_standard_header( menu, title_txt, {subtitle2}, {  }, 1,  nil, { menu.wpedit.subtitle3 })
	
	-- Setup the main body
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {
		175,
		250,
		Helper.standardTextHeight,			-- NB Width set using height parameter to get square button
		Helper.standardTextHeight,			-- NB Width set using height parameter to get square button
		80,									-- stretch to fill row
		80, 80, 80, 0 }

		--Header row
	local cells = {}
	local header_text = { ReadText(150402,228) .. ":",  ReadText(150402,229) .. ":", "", ""}		-- "Description:",  "Action:", "", ""
	local rowData = "header"
	for _, text in pairs(header_text) do
		table.insert( cells, LibMT:Cell(text, nil, 1))
	end
	table.insert( cells, LibMT:Cell("", nil, 5))
	table.insert(row_collection, LibMT:Row(cells, rowData, menu.transparent, false, 0))

	-- Row 1 - destination selection
	local cells = {}
	table.insert( cells, LibMT:Cell(ReadText(1001,3), nil, 1))		-- "Station"
	local station = ReadText(150402,112)		-- "None"
	if menu.bool.isStationValid then
		station = GetComponentData( menu.wpedit.wp_station, "name")
	end
	table.insert( cells, LibMT:Cell((station) or ReadText(150402,112), nil, 1))		-- "None"
	table.insert( cells, LibMT:ButtonCell( "", nil, 1, false))    -- TODO: LIST OF PLAYER STATIONS FOR SELECTION??
	table.insert( cells, LibMT:ButtonCell( "", nil, 1, false))
	table.insert( cells, LibMT:ButtonCell( ReadText(150402,230), function() Buttons:SelectHomebase() end, 1, true))							-- "Home"
	table.insert( cells, LibMT:ButtonCell( ReadText(20203,1601), function(rowIdx, colIdx) Buttons:mapSelect("player") end, 1, true))		-- "Player"
	table.insert( cells, LibMT:ButtonCell( ReadText(150402,231), function(rowIdx, colIdx) Buttons:mapSelect("npc") end, 1, true))			-- "NPC"
	table.insert( cells, LibMT:Cell("", nil, 2))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Row 2 - Waypoint type selection
	local cells = {}
	table.insert( cells, LibMT:Cell( ReadText(150402,232), nil, 1))				-- "Waypoint Type"
	table.insert( cells, LibMT:Cell(menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]], nil, 1))
	table.insert( cells, LibMT:ButtonCell( "-", Buttons.DecWPType, 1, menu.bool.isStationValid))
	table.insert( cells, LibMT:ButtonCell( "+", Buttons.IncWPType, 1, menu.bool.isStationValid))
	table.insert( cells, LibMT:Cell("", nil, 5))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Row 3 - Ware Type selection
	local cells = {}
	table.insert( cells, LibMT:Cell( ReadText(150402,233), nil, 1))				-- "Ware Type"
	
	if menu.ware.selectedWareType == 1 or not menu.ware.display then
		table.insert( cells, LibMT:Cell(ReadText(150402,162), nil, 1))			-- "None Selected"
	else
		table.insert( cells, LibMT:Cell(GetWareData(menu.ware.display[menu.ware.selectedWareType], "name"), nil, 1))
	end
	
	table.insert( cells, LibMT:ButtonCell( "-", Buttons.DecWareType, 1, menu.bool.isWPTypeValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells"))
	table.insert( cells, LibMT:ButtonCell( "+", Buttons.IncWareType, 1, menu.bool.isWPTypeValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells"))
	table.insert( cells, LibMT:Cell("", nil, 5))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Row 4 - Minimum Amount selection
	local cells = {}
	if menu.ware.display[menu.ware.selectedWareType] == "fuelcells" then
		table.insert( cells, LibMT:Cell( ReadText(150402,234), nil, 1))			-- "If fuel left less than"
	else
		table.insert( cells, LibMT:Cell( ReadText(150402,235), nil, 1))			-- "Minimum Amount"
	end
	table.insert( cells, LibMT:Cell(menu.ware.MinAmount .. "  (" .. menu.ware.selectedMinAmount .. " % " .. ReadText(150402,236) .. ")", nil, 1)) -- "Cargo Space"
	table.insert( cells, LibMT:ButtonCell( "-", Buttons.DecModifierType, 1, menu.bool.isWareValid and not menu.bool.isFlyTo))
	table.insert( cells, LibMT:ButtonCell( "+", Buttons.IncModifierType, 1, menu.bool.isWareValid and not menu.bool.isFlyTo))
	table.insert( cells, LibMT:ButtonCell( "25%", function(rowIdx, colIdx) Buttons:SetAmount( 25, false ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo))    
	table.insert( cells, LibMT:ButtonCell( "50%", function(rowIdx, colIdx) Buttons:SetAmount( 50, false ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo))
	table.insert( cells, LibMT:ButtonCell( "75%", function(rowIdx, colIdx) Buttons:SetAmount( 75, false ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo))    
	table.insert( cells, LibMT:ButtonCell( ReadText(1001,19), function(rowIdx, colIdx) Buttons:SetAmount( 100, false ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo)) -- "Max"
	table.insert( cells, LibMT:Cell("", nil, 1))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Row 5 - Maximum amount selection
	local cells = {}
	table.insert( cells, LibMT:Cell( ReadText(150402,237), nil, 1)) 		-- "Maximum Amount"
	table.insert( cells, LibMT:Cell(menu.ware.DisplayAmount .. "  (" .. menu.ware.selectedAmount .. " % " .. ReadText(150402,236) .. ")", nil, 1))
	table.insert( cells, LibMT:ButtonCell( "-", Buttons.DecAmount, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" ))			-- TODO: Also validate on amount > 0
	table.insert( cells, LibMT:ButtonCell( "+", Buttons.IncAmount, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" ))			-- Add 50% and MAX buttons
	table.insert( cells, LibMT:ButtonCell( "25%", function(rowIdx, colIdx) Buttons:SetAmount( 25, true ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells"))    
	table.insert( cells, LibMT:ButtonCell( "50%", function(rowIdx, colIdx) Buttons:SetAmount( 50, true ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells"))
	table.insert( cells, LibMT:ButtonCell( "75%", function(rowIdx, colIdx) Buttons:SetAmount( 75, true ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells"))    
	table.insert( cells, LibMT:ButtonCell( ReadText(1001,19), function(rowIdx, colIdx) Buttons:SetAmount( 100, true ) end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells"))  -- "Max"
	table.insert( cells, LibMT:Cell("", nil, 1))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Row 6 - max price selection select + AVG MIN MAX BUTTONS - may need reset on ware type change
	local cells = {}
	if menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] == ReadText(1001,2916) then -- "Buy"
		table.insert( cells, LibMT:Cell( ReadText(150402,238), nil, 1))		-- "Maximum buy Price"
	elseif menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] == ReadText(1001,2917) then -- "Sell"
 		table.insert( cells, LibMT:Cell( ReadText(150402,239), nil, 1))		-- "Minimum sell Price"
	else
		table.insert( cells, LibMT:Cell("", nil, 1))
	end
	table.insert( cells, LibMT:Cell(menu.ware.Price, nil, 1))
	table.insert( cells, LibMT:ButtonCell( "-", function(rowIdx, colIdx) Buttons:DecPrice() end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Load" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Unload"))		
	table.insert( cells, LibMT:ButtonCell( "+", function(rowIdx, colIdx) Buttons:IncPrice() end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Load" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Unload"))
	table.insert( cells, LibMT:ButtonCell( ReadText(150402,164), function(rowIdx, colIdx) Buttons:SetPrice("min") end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Load" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Unload"))
	table.insert( cells, LibMT:ButtonCell( ReadText(150402,240), function(rowIdx, colIdx) Buttons:SetPrice("avg") end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Load" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Unload"))    
	table.insert( cells, LibMT:ButtonCell( ReadText(1001,19), function(rowIdx, colIdx) Buttons:SetPrice("max") end, 1, menu.bool.isWareValid and not menu.bool.isFlyTo and menu.ware.display[menu.ware.selectedWareType] ~= "fuelcells" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Load" and menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] ~= "Unload"))
	table.insert( cells, LibMT:Cell( "", nil, 2))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Row 7 - Activate/deactivate waypoint
	local cells = {}
	table.insert( cells, LibMT:Cell( ReadText(150402,241), nil, 1))  -- "Is Waypoint Active?"
	local label = ""
	if menu.bool.IsWPActive == 0 then label = ReadText(1001,2618) else label = ReadText(1001,2617) end		-- "No" "Yes"
	table.insert( cells, LibMT:Cell(label, nil, 1))
	table.insert( cells, LibMT:ButtonCell( "", nil, 1, false))
	table.insert( cells, LibMT:ButtonCell( "", nil, 1, false))
	table.insert( cells, LibMT:ButtonCell( ReadText(150402,242), function(rowIdx, colIdx) Buttons:SetActive() end, 1, true))	-- "Change"
	table.insert( cells, LibMT:Cell("", nil, 4))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))

	-- Row 8 - Waypoint range
	local cells = {}
	table.insert( cells, LibMT:Cell( ReadText(150402,243), nil, 1))		-- "Waypoint Range"
	local range = { ReadText(20001,201), ReadText(20001,101), ReadText(20001,901)  }	-- local range = { "Sector", "System", "Galaxy" }
	local label = range[menu.wpedit.wprange]
	table.insert( cells, LibMT:Cell(label, nil, 1))
	table.insert( cells, LibMT:Cell( "", nil, 1))
	table.insert( cells, LibMT:Cell( "", nil, 1))
	table.insert( cells, LibMT:Cell("", nil, 1))
	table.insert( cells, LibMT:Cell("", nil, 4))
	table.insert( row_collection, LibMT:Row( cells, nil, menu.transparent, false, 0))
	
	-- Build the table descriptor
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, false, false, headerHeight + 8, bodyHeight )
	
	-- Setup the button bar
	menu.buttons = {}
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton( ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,244), Buttons.Done, Availability.Done, "INPUT_STATE_DETAILMONITOR_X" )) -- "Save"

	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )
	
	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	Helper.releaseDescriptors()

	return 
end

-- Timed update callback 
menu.updateInterval = 0.5
menu.onUpdate = function ()
	if menu.wpedit.toggle > 0 then
		menu.wpedit.toggle = 0
		Helper.updateCellText(menu.infotable, 3, 1, menu.wpedit.subtitle3, LibMT.colours.red)
	else		
		menu.wpedit.toggle = 1
		Helper.updateCellText(menu.infotable, 3, 1, menu.wpedit.subtitle3, LibMT.colours.white)
	end
end 

-- standard function stub to handle changing row
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

menu.onSelectElement = function ()
	return 
end

-- standard function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuAndCancel(menu)
		menu.cleanup()
	else
		Buttons.Back()
	end
	return
end
-- Callback function for waypoint editor back button

Buttons.Back = function()
	local return_waypoint = menu.wpedit.waypoint
	menu.wpedit.ret_arg[4] = "none"
	Helper.closeMenuForSection(menu, false, "gMT_WPListMenu_return", { 0, 0, {}, menu.wpedit.ret_arg, {}, menu.wpedit.trader, return_waypoint})
	menu.cleanup()
	return
end

-- Callback function for waypoint editor done button
Buttons.Done = function()
-- Calculate parameters of waypoint here
	local new_wp_idx = menu.wpedit.waypoint[1]
	menu.wpedit.waypoint[1] = new_wp_idx
	menu.wpedit.waypoint[2] = menu.bool.IsWPActive
	menu.wpedit.waypoint[3] = menu.wpedit.wp_station or ""
	menu.wpedit.waypoint[4] = menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]
	-- Remove values for fuel and flyto
	if menu.wpedit.waypoint[4] == 6 then
		menu.wpedit.waypoint[5] = ReadText(150402,162)		-- "None Selected" 
		menu.wpedit.waypoint[6] = 0 --menu.ware.MinAmount
		menu.wpedit.waypoint[7] = 0 --menu.ware.DisplayAmount
		menu.wpedit.waypoint[8] = 0 -- Price
		menu.wpedit.waypoint[9] = menu.wpedit.wprange
	else
		menu.wpedit.waypoint[5] = menu.ware.display[menu.ware.selectedWareType]
		menu.wpedit.waypoint[6] = menu.ware.MinAmount
		menu.wpedit.waypoint[7] = menu.ware.DisplayAmount
		menu.wpedit.waypoint[8] = menu.ware.Price
		menu.wpedit.waypoint[9] = menu.wpedit.wprange
	end

	local return_waypoint = menu.wpedit.waypoint
	menu.wpedit.ret_arg[4] = menu.wpedit.wp_action
	Helper.closeMenuForSection(menu, false, "gMT_WPListMenu_return", { 0, 0, {}, menu.wpedit.ret_arg, {}, menu.wpedit.trader, return_waypoint})
	menu.cleanup()
	return
end

-- Callback to handle waypoint decrement
Buttons.DecWPType = function()
	menu.wpedit.selectedWPType = menu.wpedit.selectedWPType - 1
	if menu.wpedit.selectedWPType < 1 then
		menu.wpedit.selectedWPType = #menu.wpedit.revwaypointType
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, true, false, false, false )
	menu.display()
	return
end

-- Callback to handle waypoint increment
Buttons.IncWPType = function()
	menu.wpedit.selectedWPType = menu.wpedit.selectedWPType + 1
	if menu.wpedit.selectedWPType > #menu.wpedit.revwaypointType then
		menu.wpedit.selectedWPType = 1
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, true, false, false, false )
	menu.display()
	return
end

-- Callback to handle ware type increment
Buttons.IncWareType = function()
	menu.ware.selectedWareType = menu.ware.selectedWareType + 1
	if menu.ware.selectedWareType > #menu.ware.display then
		menu.ware.selectedWareType = 1
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false )
	menu.display()
	return
end

-- Callback to handle ware type decrement
Buttons.DecWareType = function()
	menu.ware.selectedWareType = menu.ware.selectedWareType - 1
	if menu.ware.selectedWareType < 1 then
		menu.ware.selectedWareType = #menu.ware.display
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false)
	menu.display()
	return
end

-- Callback to handle modifier type increment
Buttons.IncModifierType = function()
	menu.ware.selectedMinAmount = menu.ware.selectedMinAmount + 1
	if menu.ware.selectedMinAmount  > 100 then
		menu.ware.selectedMinAmount = 100
	end
	-- Check for exceding min amount
	if menu.ware.selectedMinAmount > menu.ware.selectedAmount then
		menu.ware.selectedAmount = menu.ware.selectedMinAmount 
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false )
	menu.display()
	return
end

-- Callback to handle modifier type decrement
Buttons.DecModifierType = function()
	menu.ware.selectedMinAmount = menu.ware.selectedMinAmount - 1
	if menu.ware.selectedMinAmount < 0 then
		menu.ware.selectedMinAmount = 0
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false)
	menu.display()
	return
end

-- Callback to handle amount type increment
Buttons.IncAmount = function()
	menu.ware.selectedAmount = menu.ware.selectedAmount + 1
	if menu.ware.selectedAmount  > 100 then
		menu.ware.selectedAmount = 100
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false )
	menu.display()
	return
end

-- Callback to handle amount type decrement
Buttons.DecAmount = function()
	menu.ware.selectedAmount = menu.ware.selectedAmount - 1
	if menu.ware.selectedAmount < 0 then
		menu.ware.selectedAmount = 0
	end
	-- Check for exceding min amount
	if  menu.ware.selectedAmount < menu.ware.selectedMinAmount then
		menu.ware.selectedMinAmount = menu.ware.selectedAmount
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false)
	menu.display()
	return
end

-- Callback to increment buy/sell price
function Buttons:IncPrice()
	local pricerange = menu.ware.maxprice - menu.ware.minprice
	if pricerange < 100 then
		menu.ware.Price = menu.ware.Price + 1
	elseif pricerange < 1000 then
		menu.ware.Price = menu.ware.Price + 10
	elseif pricerange < 10000 then
		menu.ware.Price = menu.ware.Price + 100
	elseif pricerange < 100000 then
		menu.ware.Price = menu.ware.Price + 1000
	else
		menu.ware.Price = menu.ware.Price + 10000
	end
	if menu.ware.Price > menu.ware.maxprice then
		menu.ware.Price = menu.ware.maxprice
	end
	if menu.ware.Price < menu.ware.minprice then
		menu.ware.Price = menu.ware.minprice
	end  -- covers adding a new waypoint where price is unknown so set to zero
	menu.display()
end

-- Callback to Decrement buy/sell price
function Buttons:DecPrice()
	local pricerange = menu.ware.maxprice - menu.ware.minprice
	if pricerange < 100 then
		menu.ware.Price = menu.ware.Price - 1
	elseif pricerange < 1000 then
		menu.ware.Price = menu.ware.Price - 10
	elseif pricerange < 10000 then
		menu.ware.Price = menu.ware.Price - 100
	elseif pricerange < 100000 then
		menu.ware.Price = menu.ware.Price - 1000
	else
		menu.ware.Price = menu.ware.Price - 10000
	end
	if menu.ware.Price < menu.ware.minprice then
		menu.ware.Price = menu.ware.minprice
	end
	menu.display()
end



-- Callback to set ware price to mac min avg
function Buttons:SetPrice( value )
	if value == "max" then
		menu.ware.Price = menu.ware.maxprice
	elseif value == "avg" then
		menu.ware.Price = menu.ware.avgprice
	else
		menu.ware.Price = menu.ware.minprice
	end
	menu.display()
	return	
end

-- Callback to set active waypoint
function Buttons:SetActive()
	if menu.bool.IsWPActive == 0 then menu.bool.IsWPActive = 1 else menu.bool.IsWPActive = 0 end
	menu.display()
end

-- Callback to set specific amount
function Buttons:SetAmount( amount, isMax)
	if isMax then
		menu.ware.selectedAmount = amount
		-- Check for exceding min amount
		if  menu.ware.selectedAmount < menu.ware.selectedMinAmount then
			menu.ware.selectedMinAmount = menu.ware.selectedAmount
		end
	else
		menu.ware.selectedMinAmount = amount
		-- Check for exceding min amount
		if menu.ware.selectedMinAmount > menu.ware.selectedAmount then
			menu.ware.selectedAmount = menu.ware.selectedMinAmount 
		end
	end
	-- Signal that the WP type has changed and check the menu
	Utility.RecheckMenu( false, false, false, false, true, false)
	menu.display()
	return
end

-- Callback for button to set homebase as destination
function Buttons:SelectHomebase()
	menu.wpedit.wp_station = menu.wpedit.homebase
	-- Temporary save the working waypoint so we can call up the map
	local new_wp_idx = menu.wpedit.waypoint[1]
	menu.wpedit.waypoint[1] = new_wp_idx
	menu.wpedit.waypoint[2] = menu.bool.IsWPActive
	menu.wpedit.waypoint[3] = menu.wpedit.wp_station
	menu.wpedit.waypoint[4] = menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]
	if menu.wpedit.waypoint[5] == "None Selected" then
		menu.wpedit.waypoint[5] = "None Selected"
		menu.wpedit.waypoint[6] = 0
		menu.wpedit.waypoint[7] = 0
		menu.wpedit.waypoint[8] = 0
	else
		menu.wpedit.waypoint[5] = menu.ware.display[menu.ware.selectedWareType]
		menu.wpedit.waypoint[6] = menu.ware.MinAmount
		menu.wpedit.waypoint[7] = menu.ware.DisplayAmount
		menu.wpedit.waypoint[8] = menu.ware.Price
	end

	local return_waypoint = menu.wpedit.waypoint
	menu.wpedit.ret_arg[4] = menu.wpedit.wp_action
	Helper.closeMenuForSection(menu, false, "gMT_Map_HomebaseSelected", { 0, 0, {}, menu.wpedit.ret_arg, {}, menu.wpedit.trader, return_waypoint})
	menu.cleanup()
	return
end

function Buttons:mapSelect(faction)
	-- Temporary save the working waypoint so we can call up the map
	menu.wpedit.waypoint[1] = menu.wpedit.waypoint[1]
	menu.wpedit.waypoint[2] = menu.bool.IsWPActive
	menu.wpedit.waypoint[3] = menu.wpedit.wp_station
	menu.wpedit.waypoint[4] = menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]
	if menu.wpedit.waypoint[5] == "None Selected" then
		menu.wpedit.waypoint[5] = "None Selected"
		menu.wpedit.waypoint[6] = 0
		menu.wpedit.waypoint[7] = 0
		menu.wpedit.waypoint[8] = 0
	else
		menu.wpedit.waypoint[5] = menu.ware.display[menu.ware.selectedWareType]
		menu.wpedit.waypoint[6] = menu.ware.MinAmount
		menu.wpedit.waypoint[7] = menu.ware.DisplayAmount
		menu.wpedit.waypoint[8] = menu.ware.Price
	end

	local return_waypoint = menu.wpedit.waypoint
	Helper.closeMenuForSubSection(menu, false, "gMT_Map_GetStation", { 0, 0, {}, menu.wpedit.ret_arg, {}, menu.wpedit.trader, return_waypoint, faction})
	menu.cleanup()
	return
end

Availability.Done = function ()
	return menu.bool.isStationValid == true and menu.bool.isWPTypeValid == true and menu.bool.isWareValid == true 
end

-- Utility functions
Utility.RecheckMenu = function( newstation, checkStation, checkWPType, firstwptypecheck, checkWare, firstWareCheck )

	-- check the validity of the station
	if checkStation then
		menu.ware.shipres, menu.ware.shipprod, menu.ware.shiptrade, menu.ware.shipall = {}, {}, {}, {}
		-- initialise some booleans for directing action and button availability
		menu.bool.playerstation = false
		menu.bool.shipCanRefuel = false
		menu.bool.isWayPointValid = menu.wpedit.waypoint[2] or 0
		menu.bool.isStationValid = false
		menu.bool.isWPTypeValid = false
		menu.bool.isWareValid = false
		-- Initialise values we need to display on new or changed station
		
		-- check if the station we picked is valid
		if menu.wpedit.wp_station and (type(menu.wpedit.wp_station) ~= "string")  then
			if not IsComponentClass( menu.wpedit.wp_station, "station") then
				menu.wpedit.subtitle3 = ReadText(150402,223)				-- "!!OBJECT SELECTED MUST BE A STATION!!"
				DebugError("NOT A STATION WAS FIRED")
			elseif not GetComponentData(menu.wpedit.wp_station, "tradesubscription") then
				menu.wpedit.subtitle3 = ReadText(150402,224)		-- "!!STATION MUST HAVE A TRADE AGENT ONBOARD!!"
			-- check if hostile
			elseif GetComponentData(menu.wpedit.wp_station, "isenemy") then
				menu.wpedit.subtitle3 = ReadText(150402,225)		-- "!!STATION SELECTED IS HOSTILE - PLEASE CHOOSE ANOTHER!!"
			elseif LibMT.GetStationRange(menu.wpedit.homebase, menu.wpedit.wp_station) > menu.wpedit.trader[5] then
				menu.wpedit.subtitle3 = ReadText(150402,226)		-- "!!STATION SELECTED IS OUT OF RANGE FOR THE CURRENT CREW!!"
			else
				menu.wpedit.subtitle3 = ""			
				menu.bool.isStationValid = true
			end
		end

		-- Get station warelist and check if it has any wares the ship can carry
		if menu.bool.isStationValid then
--			DebugError( "Is station Valid:  " .. tostring(menu.bool.isStationValid) .. "  STATION:  " .. GetComponentData( menu.wpedit.wp_station, "name"))
			local resources = menu.wpedit.warelist[1] or {}
			local products = menu.wpedit.warelist[2] or {}
			local tradewares = menu.wpedit.warelist[3] or {}
			local cargolist = menu.wpedit.trader[3]
			resources = LibMT.RemoveWares( resources, "ship" )
			products = LibMT.RemoveWares( products, "ship" )
			tradewares = LibMT.RemoveWares( tradewares, "ship" )

			-- Get station range
			menu.wpedit.wprange = LibMT.GetStationRange( menu.wpedit.homebase, menu.wpedit.wp_station )

			menu.ware.shipres, menu.ware.shipprod, menu.ware.shiptrade, menu.ware.shipall, menu.bool.shipCanRefuel = LibMT.CompareStationWarelist( resources, products, tradewares, cargolist ) 
			if menu.wpedit.wp_station ~= ReadText(150402,112) then  -- "None"
 				if GetComponentData(menu.wpedit.wp_station, "owner") == "player" then menu.bool.playerstation = true else menu.bool.playerstation = false end
			end
			
			-- now compare these lists with the ship's cargo capability
			-- Check at least some wares can be traded here
			if #menu.ware.shipres < 1 and #menu.ware.shipprod < 1 and #menu.ware.shiptrade < 1 then
				menu.wpedit.subtitle3 = ReadText(150402,227)		-- "!!! WARNING!  THE STATION SELECTED DOES NOT DEAL IN ANY WARES THAT THE SHIP CAN CARRY !!!"
			end
		end	
	
	
		-- now determine the waypoint types supported
		menu.wpedit.revwaypointType = {1,2,3,4,5,6,7}
		if not menu.bool.shipCanRefuel then table.remove(menu.wpedit.revwaypointType, 7) end


		if (#menu.ware.shipres < 1 and #menu.ware.shiptrade < 1) or menu.bool.playerstation then table.remove(menu.wpedit.revwaypointType, 5) end
		if #menu.ware.shipprod < 1 or menu.bool.playerstation then table.remove(menu.wpedit.revwaypointType, 4) end
		if #menu.ware.shipres < 1 and #menu.ware.shiptrade < 1 and menu.bool.playerstation then table.remove(menu.wpedit.revwaypointType, 3) end
		if #menu.ware.shipprod < 1 and menu.bool.playerstation then table.remove(menu.wpedit.revwaypointType, 2) end


		if not menu.bool.playerstation then 
			table.remove(menu.wpedit.revwaypointType, 3) 
			table.remove(menu.wpedit.revwaypointType, 2) 
		end
	
		-- now resolve the selector index vs the types available
		menu.wpedit.selectedWPType = 1
		for i,v in ipairs(menu.wpedit.revwaypointType) do
			if v == menu.wpedit.waypoint[4] then
				menu.wpedit.selectedWPType = i 
			end
		end
		-- reset the waypoint to "No Action" if a new station is detected
		if newstation then
			menu.wpedit.selectedWPType = 1
		end
	end
	
	-- Check if waypoint type is changed
	if checkWPType then
		menu.ware.display = {}
		-- reset ware type display
		menu.ware.selectedWareType = 1
		local wp_type = menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] -- gets the text of the WP type
		menu.bool.isWPTypeValid = false
		menu.bool.isWareValid = false
		menu.bool.isFlyTo = false
		if wp_type ~= ReadText(150402,167) then   -- "No Action"
			if wp_type == ReadText(1001,2916) or wp_type == ReadText(150402,168) then		-- "Buy" "Load"
				menu.ware.display = LibMT.deepcopy(menu.ware.shipprod)
				menu.bool.isWPTypeValid = true
			elseif wp_type == ReadText(1001,2917) or wp_type == ReadText(150402,169) then				-- "Sell"  "Unload"
				menu.ware.display =  LibMT.deepcopy(LibMT.Set.Symmetric(menu.ware.shipres, menu.ware.shiptrade))
				menu.bool.isWPTypeValid = true
			elseif wp_type == ReadText(1002,2027) then  -- "Refuel"
				menu.ware.display = {"fuelcells"}
				menu.bool.isWPTypeValid = true
				menu.ware.selectedWareType = 2
				menu.bool.isWareValid = true
			elseif wp_type == ReadText(150402,170) then  -- "Fly to"
				menu.ware.display = {ReadText(150402,112)}		-- "None"
				menu.bool.isWPTypeValid = true
				menu.bool.isWareValid = true
				menu.bool.isFlyTo = true
				menu.ware.selectedWareType = 1
				menu.ware.selectedAmount = 0
				menu.ware.selectedMinAmount = 0
				menu.ware.DisplayAmount = 0
			end
			table.insert(menu.ware.display, 1, ReadText(150402,162))		-- "None Selected"

		end

		if firstwptypecheck then
			-- need to get our displayed ware type
			menu.ware.selectedWareType = 1
			for i,ware in ipairs(menu.ware.display) do
				local label = "None"
				if ware ~= ReadText(150402,162) or ware ~= ReadText(150402,112) then  -- "None Selected" "None"
					label = GetWareData(ware, "name")
				end
				if 	menu.ware.ware == ware then
					menu.ware.selectedWareType = i
				end
			end
			if menu.ware.display[2] == "fuelcells" then
				menu.ware.selectedWareType = 2
			end
			if menu.ware.display[2] == ReadText(150402,112) then    -- "None"
				menu.ware.selectedWareType = 2
			end
		end
	end
	
	-- check if ware type is changed
	if checkWare then
		-- Manage reset of volumes etc if ware changes
		if menu.ware.display[menu.ware.selectedWareType] == ReadText(150402,162) or #menu.ware.display < 2 then  -- "None Selected"
			menu.bool.stationchanged = false
			menu.bool.isWareValid = false
			menu.ware.selectedAmount = 0
			menu.ware.DisplayAmount = 0
			menu.ware.selectedMinAmount = 0
			menu.ware.MinAmount = 0
			menu.ware.Price = 0
		elseif menu.ware.display[menu.ware.selectedWareType] == ReadText(150402,112) then  -- Fly to "None"
			menu.ware.selectedAmount = 0
			menu.ware.DisplayAmount = 0
			menu.ware.selectedMinAmount = 0
			menu.ware.selectedWareType = 1
			menu.ware.MinAmount = 0
			menu.ware.Price = 0
		else
--			menu.bool.isWareValid = true
			local ware_lib = GetLibraryEntry("wares", menu.ware.display[menu.ware.selectedWareType])
			menu.ware.volume = ware_lib.volume
			menu.ware.minprice, menu.ware.avgprice, menu.ware.maxprice = GetWareData( menu.ware.display[menu.ware.selectedWareType], "minprice", "avgprice", "maxprice")
--			menu.ware.Price = menu.waypoint[8]
			if menu.wpedit.waypoint[8] == 0 then
				menu.ware.Price = menu.ware.avgprice
			else
				menu.ware.Price = menu.wpedit.waypoint[8]
			end
			-- Determine ware volume and manage further buttons
			local waretransport = GetWareData(menu.ware.display[menu.ware.selectedWareType], "transport")
			local wp_type = menu.wpedit.waypointType[menu.wpedit.revwaypointType[menu.wpedit.selectedWPType]] 
			if firstWareCheck then
				-- Resolve ware max amount
				if menu.wpedit.cargo[6] > 0 then
					if wp_type == ReadText(1002,2027) then -- "Refuel"
 						menu.ware.selectedAmount = Helper.round(   (100 * ((menu.wpedit.cargo[1]/4) - menu.wpedit.waypoint[7]))/(menu.wpedit.cargo[1]/4)    , 0)
						menu.ware.selectedMinAmount = Helper.round(   (100 * ((menu.wpedit.cargo[1]/4) - menu.wpedit.waypoint[6]))/(menu.wpedit.cargo[1]/4)    , 0)
					else	
						menu.ware.selectedAmount = Helper.round(menu.wpedit.waypoint[7]*menu.ware.volume*100/menu.wpedit.cargo[6], 0 ) 
						menu.ware.selectedMinAmount = Helper.round(menu.wpedit.waypoint[6]*menu.ware.volume*100/menu.wpedit.cargo[6], 0 ) 
					end
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "nividium") and waretransport == "bulk" then
					menu.ware.selectedAmount = Helper.round(menu.wpedit.waypoint[7]*menu.ware.volume*100/menu.wpedit.cargo[2], 0)
					menu.ware.selectedMinAmount = Helper.round(menu.wpedit.waypoint[6]*menu.ware.volume*100/menu.wpedit.cargo[2], 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "chemicalcompounds") and waretransport == "container" then
					menu.ware.selectedAmount = Helper.round(menu.wpedit.waypoint[7]*menu.ware.volume*100/menu.wpedit.cargo[3], 0)
					menu.ware.selectedMinAmount = Helper.round(menu.wpedit.waypoint[6]*menu.ware.volume*100/menu.wpedit.cargo[3], 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "ioncells") and waretransport == "energy" then
					menu.ware.selectedAmount = Helper.round(menu.wpedit.waypoint[7]*menu.ware.volume*100/menu.wpedit.cargo[4], 0)
					menu.ware.selectedMinAmount = Helper.round(menu.wpedit.waypoint[6]*menu.ware.volume*100/menu.wpedit.cargo[4], 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "ions") and waretransport == "liquid" then
					menu.ware.selectedAmount = Helper.round(menu.wpedit.waypoint[7]*menu.ware.volume*100/menu.wpedit.cargo[5], 0)
					menu.ware.selectedMinAmount = Helper.round(menu.wpedit.waypoint[6]*menu.ware.volume*100/menu.wpedit.cargo[5], 0)
				elseif wp_type == ReadText(1002,2027) then
					menu.ware.selectedAmount = 100
					menu.ware.selectedMinAmount = Helper.round(   (100 * ((menu.wpedit.cargo[1]/4) - menu.wpedit.waypoint[6]))/(menu.wpedit.cargo[1]/4)    , 0)
				else
					menu.ware.selectedAmount = 0
					menu.ware.selectedMinAmount = 0
				end
			end
		
			-- calculate the ware number from the amount selected already
			if menu.ware.display[menu.ware.selectedWareType] ~= ReadText(150402,162) then -- "None Selected"
				menu.bool.isWareValid = true
				if menu.wpedit.cargo[6] > 0 and not menu.bool.shipCanRefuel then  -- universal
					menu.ware.DisplayAmount = math.floor(menu.wpedit.cargo[6]*menu.ware.selectedAmount/(menu.ware.volume*100), 0)
					menu.ware.MinAmount = math.floor(menu.wpedit.cargo[6]*menu.ware.selectedMinAmount/(menu.ware.volume*100), 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "nividium") and waretransport == "bulk" then
					menu.ware.DisplayAmount = math.floor(menu.wpedit.cargo[2]*menu.ware.selectedAmount/(menu.ware.volume*100), 0)
					menu.ware.MinAmount = math.floor(menu.wpedit.cargo[2]*menu.ware.selectedMinAmount/(menu.ware.volume*100), 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "chemicalcompounds") and waretransport == "container" then
					menu.ware.DisplayAmount = math.floor(menu.wpedit.cargo[3]*menu.ware.selectedAmount/(menu.ware.volume*100), 0)
					menu.ware.MinAmount = math.floor(menu.wpedit.cargo[3]*menu.ware.selectedMinAmount/(menu.ware.volume*100), 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "ioncells") and waretransport == "energy" then
					menu.ware.DisplayAmount = math.floor(menu.wpedit.cargo[4]*menu.ware.selectedAmount/(menu.ware.volume*100), 0)
					menu.ware.MinAmount = math.floor(menu.wpedit.cargo[4]*menu.ware.selectedMinAmount/(menu.ware.volume*100), 0)
				elseif CheckSuitableTransportType(menu.wpedit.trader[1], "ions") and waretransport == "liquid" then
					menu.ware.DisplayAmount = math.floor(menu.wpedit.cargo[5]*menu.ware.selectedAmount/(menu.ware.volume*100), 0)
					menu.ware.MinAmount = math.floor(menu.wpedit.cargo[5]*menu.ware.selectedMinAmount/(menu.ware.volume*100), 0)
				elseif menu.bool.shipCanRefuel and wp_type == ReadText(1002,2027) then
					menu.ware.DisplayAmount = math.floor(menu.wpedit.cargo[1]/4, 0) 
					menu.ware.selectedAmount = 100
					menu.ware.MinAmount = math.floor((menu.wpedit.cargo[1]/4)*menu.ware.selectedMinAmount/100, 0)
					menu.bool.isWareValid = true
					menu.ware.selectedWareType = 2
				end
			else
				menu.ware.DisplayAmount = 0
				menu.ware.MinAmount = 0
				menu.bool.isWareValid = false
			end
		end
	end	
return	

end

init()

return
--[[	Manages the list waypoint screen for the MT Station Logistics mod
		Version:		1.0.0
		Last Update:	2014-12-13
 --]]
 
local Buttons, Availability = {}, {}

-- Set up the default menu table
local menu = {	name = "gMT_Station_Logistics_ListWaypoints",
				statusWidth = 150,
				statusHeight = 24,
				transparent = {
				g = 0,
				a = 0,
				b = 0,
				r = 0
				}
	}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}

	table.insert(Menus, menu)

	if Helper then
		Helper.registerMenu(menu)
	end

	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.faction = nil
--	menu.title = nil
--	menu.subtitle = nil
--	menu.subtitle2 = nil
--	menu.subtitle3	= nil
--	menu.ret_arg = nil
--	menu.ship = nil
--	menu.homebase = nil
--	menu.cargolist = nil
--	menu.waypoints = nil
--	menu.wp_paste_buffer = nil
--	menu.trader = nil
--	menu.crewscore = nil
--	menu.level = nil
--	menu.maxwaypoints = nil
--	menu.logindex = nil
	menu.buttons = nil
	menu.wplist = nil
	return
end

-- function to handle displaying the menu
menu.onShowMenu = function ()
	menu.wplist = {}
	-- Get the passed parameters
	menu.toprow = menu.param[1]
	menu.selrow = menu.param[2]
	
	menu.wplist.action = menu.param[4][4]
	menu.wplist.trader = menu.param[6]
	menu.wplist.waypoint = menu.param[7] or {}    -- collects return from WP edit menu
	
	menu.wplist.ret_arg = { menu.param[4][1],menu.param[4][2],menu.param[4][3], menu.wplist.action } -- Return parameters if required
	
	-- setup various variables used in the menu
	menu.wplist.title = ReadText(150402,21)				-- menu.title = "MT Station Logistics - Administration"
	menu.wplist.subtitle = ReadText(150402,161)			-- menu.title = "Waypoint Management"
	
--	menu.wplist.waypointType = { "No Action", "Load", "Unload", "Buy", "Sell", "Fly to", "Refuel" }
	menu.wplist.waypointType = { ReadText(150402,167), ReadText(150402,168), ReadText(150402,169), 
									ReadText(1001,2916), ReadText(1001,2917), ReadText(150402,170), ReadText(1002,2027) }

	menu.wplist.ship = menu.wplist.trader[1]
	menu.wplist.homebase = menu.wplist.trader[2]
	menu.wplist.cargolist = menu.wplist.trader[3]
	menu.wplist.waypoints = menu.wplist.trader[4]
	menu.wplist.level = menu.wplist.trader[5]
	menu.wplist.crewscore = menu.wplist.trader[6]
	menu.wplist.log = menu.wplist.trader[7]
	menu.wplist.activity = menu.wplist.trader[8]
	menu.wplist.stats = menu.wplist.trader[9]
	menu.wplist.index = menu.wplist.trader[10]
	menu.wplist.numwp = menu.wplist.trader[11]
	menu.wplist.tracklog = {} -- empty unless in reporting tracking menu
	menu.wplist.DbgLvl = menu.wplist.trader[13]									-- Debug level for this ship
	menu.wplist.Track = menu.wplist.trader[14]										-- True if ship is being tracked
	
	
	-- Deal with add or edit WP here
	if menu.wplist.action == "addwaypoint" then
		-- add a new waypoint
		table.insert(menu.wplist.waypoints, menu.wplist.waypoint[1], menu.wplist.waypoint)
		-- resync waypoint indices
		for i, wp in ipairs(menu.wplist.waypoints) do
			wp[1] = i
		end
	elseif menu.wplist.action == "editwaypoint" then
		-- replace old with edited version
		table.remove(menu.wplist.waypoints, menu.wplist.waypoint[1])
		table.insert(menu.wplist.waypoints, menu.wplist.waypoint[1], menu.wplist.waypoint)
	end
	
	-- Clip maximum waypoints allowed 
	menu.wplist.maxwaypoints = 10
	if menu.wplist.level > 1 and menu.wplist.level < 3 then
		menu.wplist.maxwaypoints = 20
	elseif menu.wplist.level > 2 then
		menu.wplist.maxwaypoints = 40
	end
	
	-- Deal with lists that are too long because crew has been changed for a lower skilled crew 
	-- Routine to check here for crew changes causing change in validity of WP list
	local checkcount = 0 -- keep count of number of valid wps found in list
	for i, waypoint in ipairs(menu.wplist.waypoints) do
		if waypoint[9] <= menu.wplist.level then  -- valid waypoint
			menu.wplist.waypoints[i][10] = 0 			-- Set as valid
			checkcount = checkcount + 1
			if checkcount > menu.wplist.maxwaypoints then
				menu.wplist.waypoints[i][10] = 1
			end
		else
			menu.wplist.waypoints[i][10] = 1			-- Flag waypoint as invalid
		end
	end
--	DebugError( "MT Logistics Captain Score:  " .. captainscore .. "  DO Score:  " .. defencescore .. "  Engineer score:  " ..  engineerscore .. "  Crew Score  " .. crewscore .. " Crew Level:  " .. level)


	-- display our menu
	menu.selectedRow = { idx = menu.selrow, data = {} }
	menu.display( true )
	return
end

-- Main screen redraw function
menu.display = function ( first )	
	Helper.removeAllButtonScripts(menu)

	-- Setup the header block
	local homebase = ""
	if menu.wplist.homebase == "none" then
		homebase = ReadText(150402,162) else homebase = GetComponentData(menu.wplist.homebase, "name") -- "None Selected" or homebase name
	end
	local title = {
			Helper.createFontString(
			menu.wplist.title .. " - " .. menu.wplist.subtitle, -- the main title text of our window
			false, 											-- don't scale the text
			"left", 										-- horizontal alignment
			255, 255, 255, 100,								-- The text colour R,G,B,Alpha 
			Helper.headerRow1Font, 							-- The predefined row 1 font
			Helper.headerRow1FontSize, 						-- The predefined row 1 font size (see detailmonitorhelper\helper.lua
			false, 											-- Don't wrap the text
			Helper.headerRow1Offsetx, 						-- Predefined x offset
			Helper.headerRow1Offsety, 						-- Predefined y offset
			Helper.headerRow1Height, 						-- Predefined row 1 height
			Helper.headerRow1Width)							-- Predefined row 1 width
	}
	local colWidths = { Helper.standardTextHeight, 60, 100, 100, 100, 300, 75, 0 }
	local additional_rows = {}
	local cells ={}
--	local subtitle2 = "Selected Ship: " .. GetComponentData(menu.wplist.ship, "name") .. " -- Homebase Station: " .. homebase
	local subtitle2 = ReadText(150402,173) .. ": " .. GetComponentData(menu.wplist.ship, "name") .. " -- " .. ReadText(150402,174) .. ": " .. homebase
	
	-- Info row
	local function text_fmt( text )
		return Helper.createFontString( text, false, "left", 255, 255, 255, 100, Helper.standardFont, Helper.standardFontSize, 
				false, Helper.headerRow2Offsetx, Helper.headerRow2Offsety, Helper.headerRow2Height, Helper.headerRow1Width )
	end
	table.insert(cells, LibMT:Cell(text_fmt(""), nil, #colWidths))
	table.insert(additional_rows, LibMT:Row( cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell(text_fmt(""), nil, #colWidths))
	table.insert(additional_rows, LibMT:Row( cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))

	-- Fixed header column
	local cells = {}
	table.insert(cells, LibMT:Cell(text_fmt(""), nil, 1))
	table.insert(cells, LibMT:Cell(text_fmt(""), nil, 1))
	table.insert(cells, LibMT:Cell(text_fmt(ReadText(150402,163)), nil, 1))				-- "WP Type"
	table.insert(cells, LibMT:Cell(text_fmt(ReadText(150402,164)), nil, 1))				-- "Min"
	table.insert(cells, LibMT:Cell(text_fmt(ReadText(1001,19)), nil, 1))				-- "Max"
	table.insert(cells, LibMT:Cell(text_fmt(ReadText(1001,45)), nil, 1))				-- "Ware"
	table.insert(cells, LibMT:Cell(text_fmt(ReadText(1001,1302)), nil, 1))				-- "Range"
	table.insert(cells, LibMT:Cell(text_fmt(ReadText(150402,165)), nil, 1))				-- "Active?"
	table.insert(additional_rows, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))

	local infodesc, headerHeight = LibMT.create_column_header( menu, title, {subtitle2}, additional_rows, colWidths, {#colWidths} )

	-- setup the waypoints list
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local cells = {}
	for i, waypoint in ipairs(menu.wplist.waypoints) do
		local function text_fmt( text, wp_state )
			if wp_state == 0 then
				return Helper.createFontString( text, false, "left", 255, 255, 255, 100, Helper.standardFont, Helper.standardFontSize, 
														false, Helper.headerRow2Offsetx, Helper.headerRow2Offsety, Helper.headerRow2Height, Helper.headerRow1Width )
			else
				return Helper.createFontString( text, false, "left", 255, 0, 0, 100, Helper.standardFont, Helper.standardFontSize, 
														false, Helper.headerRow2Offsetx, Helper.headerRow2Offsety, Helper.headerRow2Height, Helper.headerRow1Width )
			end
		end
		local wp_state = waypoint[10]
		cells = {}
		table.insert(cells, LibMT:Cell( text_fmt("",wp_state), nil, 1))
		table.insert(cells, LibMT:Cell( text_fmt("WP: " .. tostring(i), wp_state), nil, 1))
		local station = ReadText(150402,166)										-- "No Station Selected"
		if (type(waypoint[3]) ~= "string") and IsComponentClass( waypoint[3], "station") then
			station = GetComponentData( waypoint[3], "name")
		end
		local label = menu.wplist.waypointType[waypoint[4]] or ReadText(150402,112) -- "None"
		table.insert(cells, LibMT:Cell( text_fmt(label,wp_state), nil, 1))


		local label = waypoint[6] or ReadText(150402,112) -- "None"
		table.insert(cells, LibMT:Cell( text_fmt(label,wp_state), nil, 1))
		local label = waypoint[7] or ReadText(150402,112) -- "None"
		table.insert(cells, LibMT:Cell( text_fmt(label,wp_state), nil, 1))
		local label = ReadText(150402,162) -- "None Selected"	
		if waypoint[5] ~= "None Selected" then -- TODO Check for no compare with readtext
			label = GetWareData(waypoint[5], "name") or ReadText(150402,162) -- "None Selected"
		end
		table.insert(cells, LibMT:Cell( text_fmt(label,wp_state), nil, 1))
		-- Range
		local range = { ReadText(20001,201), ReadText(20001,101), ReadText(20001,901)  }	-- local range = { "Sector", "System", "Galaxy" }
		table.insert(cells, LibMT:Cell(text_fmt(range[waypoint[9]],wp_state), nil, 1))
		-- Active?
--		local active = { "No", "Yes" }
		local active = { ReadText(1001,2618), ReadText(1001,2617) }
		if waypoint[10] == 0 then
			table.insert(cells, LibMT:Cell(   text_fmt(active[ waypoint[2] + 1 ], wp_state)    , nil, 1))
		else
--			table.insert(cells, LibMT:Cell(  Helper.createFontString(ReadText(150402,171), false, "left", 255, 0, 0, 100) , nil, 1))	-- "Locked"
			table.insert(cells, LibMT:Cell(  text_fmt(ReadText(150402,171),wp_state)  , nil, 1))	-- "Locked"
		end
		table.insert(row_collection, LibMT:Row(cells, { "exists", waypoint}, Helper.defaultHeaderBackgroundColor, false, 0))
	end
	
	local cells = {}
	table.insert(cells, LibMT:Cell( ReadText(150402,172), nil, 8))	-- "Add New Waypoint"
	table.insert(row_collection, LibMT:Row(cells, {"Add New Waypoint", { "", "","", "","", "","", "","", "","", "",}}, Helper.defaultHeaderBackgroundColor, false, 0))

	-- Build the table descriptor
	local colWidths = { Helper.standardTextHeight, 60, 100, 100, 100, 300, 75, 0 }
	if first then
		menu.toprow = menu.param[1]
		menu.selrow = menu.param[2]
	end
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight - 14, bodyHeight, menu.toprow, menu.selrow )
	menu.toprow = nil
	menu.selrow = nil

	-- Setup the button bar
	menu.buttons = {}

	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,245), Buttons.MoveUp, Availability.MoveUp,""))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,246), Buttons.MoveDown, Availability.MoveDown,""))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,247), Buttons.Cut, Availability.Cut,""))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,248), Buttons.Paste, Availability.Paste,""))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,222), Buttons.AddWaypoint, Availability.AddWaypoint,"INPUT_STATE_DETAILMONITOR_BACK"))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,221), Buttons.EditWaypoint, Availability.EditWaypoint, "INPUT_STATE_DETAILMONITOR_Y"))
	table.insert(menu.buttons, LibMT:BarButton( ReadText(150402,244), Buttons.Done, Availability.Done, "INPUT_STATE_DETAILMONITOR_X" )) -- "Save"

	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	menu.rows = row_collection

	Helper.releaseDescriptors()
	return 
end

-- standard function stub to handle changing row
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.wplist.waypoint_index = row
		menu.selectedRow.idx = row
		menu.selectedRow.data = rowdata
		local label, ware = "", ReadText(150402,162)  -- "None Selected"
		if menu.wplist.wp_paste_buffer then
			if menu.wplist.wp_paste_buffer[5] ~= ReadText(150402,162) then  -- "None Selected"
				ware = GetWareData(menu.wplist.wp_paste_buffer[5], "name")
			end
			label = ( ReadText(150402,249) .. ": " 	.. menu.wplist.wp_paste_buffer[1] .. " - " 							-- "Paste Buffer"
										.. (GetComponentData(menu.wplist.wp_paste_buffer[3], "name") or "") .. " - "   
										.. menu.wplist.waypointType[menu.wplist.wp_paste_buffer[4]] .. " - " 
										.. menu.wplist.wp_paste_buffer[6] .. " - "   
										.. menu.wplist.wp_paste_buffer[7] .. " - "   
										.. ware 
										) or ""
		else
			label = ReadText(150402,250)		-- "Paste Buffer empty"
		end
		Helper.updateCellText(menu.infotable, 3, 1, label, nil)
		local station, zone, sector, cluster = "", "", "", ""
	
		if rowdata[1] == ReadText(150402,172) then    -- "Add New Waypoint"
			station = "" 
		elseif type(rowdata[2][3]) == "string" then
			station = rowdata[2][3]
		else
			station, zone, sector, cluster = GetComponentData( rowdata[2][3], "name", "zone", "sector", "cluster")
		end
		Helper.updateCellText(menu.infotable, 4, 1, ReadText(150402,251) .. ":-  " .. station .. "  -  " .. cluster .. "/" .. sector .. "/" .. zone , nil) -- "Waypoint Station"

		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

menu.onSelectElement = function ()
	return 
end

-- standard function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuAndCancel(menu)
		menu.cleanup()
	else
		Buttons:Back()
	end
	return
end

-- Callback for move up button
Buttons.MoveUp = function ()
	local temp_wp = table.remove( menu.wplist.waypoints, menu.wplist.waypoint_index )
	table.insert( menu.wplist.waypoints, menu.wplist.waypoint_index - 1, temp_wp )

	-- resync waypoint indices
	for i, wp in ipairs(menu.wplist.waypoints) do
		wp[1] = i
	end

	menu.toprow = GetTopRow(menu.defaulttable)
	menu.selrow = menu.selectedRow.idx - 1

	if menu.toprow >= menu.selrow then
		menu.toprow = menu.selrow - 1
	end
	
	
	menu.display()
end

-- Callback for move down button
Buttons.MoveDown = function ()
	local temp_wp = table.remove( menu.wplist.waypoints, menu.wplist.waypoint_index )
	table.insert( menu.wplist.waypoints, menu.wplist.waypoint_index + 1, temp_wp )
	-- re-sync waypoint indices
	for i, wp in ipairs(menu.wplist.waypoints) do
		wp[1] = i
	end
	menu.toprow = GetTopRow(menu.defaulttable)
	menu.selrow = menu.selectedRow.idx + 1
	if menu.selrow > 8 then
		menu.toprow = menu.selrow - 8
	end
	menu.display()
end

-- Callback for the cut button
Buttons.Cut = function (menu, rowIdx, rowData)
	-- replace old buffer value with deleted waypoint
	if rowData[2][10] == 0 then
		menu.wplist.wp_paste_buffer = table.remove(menu.wplist.waypoints, menu.wplist.waypoint_index)
	else -- deal with cutting invalid waypoint
		table.remove(menu.wplist.waypoints, menu.wplist.waypoint_index)
		menu.wplist.wp_paste_buffer = nil
	end
	-- re-sync waypoint indices
	for i, wp in ipairs(menu.wplist.waypoints) do
		wp[1] = i
	end
	if menu.wplist.waypoint_index > #menu.wplist.waypoints then
		menu.wplist.waypoint_index = #menu.wplist.waypoints
	end
	menu.toprow = GetTopRow(menu.defaulttable)
	menu.selrow = menu.wplist.waypoint_index
	if menu.toprow >= menu.selrow then
		menu.toprow = menu.selrow - 1
	end
	menu.display()
end

-- Callback for the paste button
Buttons.Paste = function ()
	if menu.wplist.wp_paste_buffer then
		if menu.wplist.waypoint_index < 1 then menu.wplist.waypoint_index = 1 end
		-- need to make a proper copy of the wp buffer to cope with multiple pastes
		temp_wp = LibMT.deepcopy(menu.wplist.wp_paste_buffer)
		table.insert(menu.wplist.waypoints, menu.wplist.waypoint_index, temp_wp)
		
		-- resync waypoint indices
		for i, wp in ipairs(menu.wplist.waypoints) do
			wp[1] = i
		end
		menu.toprow = GetTopRow(menu.defaulttable)
		menu.selrow = menu.wplist.waypoint_index

		if menu.toprow >= menu.selrow then
			menu.toprow = menu.selrow - 1
		end
		menu.display()
	end
end

-- Callback function for back button
Buttons.Back = function ()
	menu.wplist.ret_arg[4] = "nochanges"
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_configreturn", { 0, 0, {}, menu.wplist.ret_arg, {}, menu.wplist.trader, {} })
	menu.cleanup()
	return
end

-- Callback function for select button
Buttons.Done = function()
	menu.wplist.trader = {}
	table.insert( menu.wplist.trader, menu.wplist.ship )
	table.insert( menu.wplist.trader, menu.wplist.homebase )
	table.insert( menu.wplist.trader, menu.wplist.cargolist )		-- Ship cargo analysis table
	table.insert( menu.wplist.trader, menu.wplist.waypoints )		-- Ship waypoint list
	table.insert( menu.wplist.trader, menu.wplist.level )			-- crew level
	table.insert( menu.wplist.trader, menu.wplist.crewscore )		-- crew score
	table.insert( menu.wplist.trader, menu.wplist.log )				-- log list
	table.insert( menu.wplist.trader, menu.wplist.activity )		-- current activity
	table.insert( menu.wplist.trader, menu.wplist.stats )			-- ship stats
	table.insert( menu.wplist.trader, menu.wplist.index )			-- trader index
	table.insert( menu.wplist.trader, #menu.wplist.waypoints )		-- number of waypoints
	table.insert( menu.wplist.trader, {} )							-- empty unless in reporting tracking menu
	table.insert( menu.wplist.trader, menu.wplist.DbgLvl )			-- debug level
	table.insert( menu.wplist.trader, menu.wplist.Track )			-- true (1) if tracking
	menu.wplist.ret_arg[4] = "updateship"
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_configreturn", { 0, 0, {}, menu.wplist.ret_arg, {}, menu.wplist.trader, {}  })
	menu.cleanup()
	return
end

-- Callback function for Add Waypoint button
Buttons.AddWaypoint = function ()
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow  -- menu.wplist.waypoint_index
--	local new_waypoint = { menu.wplist.waypoint_index, 1, "None", "No Action", "None Selected", 0, 0, 0, 0, 0 } --  { index, valid, dest, wp_type, ware, min, max amount, price, range, activity override}
	local new_waypoint = { menu.wplist.waypoint_index, 1, ReadText(150402,112), ReadText(150402,167), ReadText(150402,162), 0, 0, 0, 0, 0 } 
											--  { index, valid, dest, wp_type, ware, min, max amount, price, range, activity override}
	menu.wplist.ret_arg[4] = "addwaypoint"
	Helper.closeMenuForSection(menu, false, "gMT_WPListMenu_editwaypoint", { toprow, selrow, {}, menu.wplist.ret_arg, {}, menu.wplist.trader, new_waypoint })
	menu.cleanup()
	return
end

-- Callback function for Edit Waypoint button
Buttons.EditWaypoint = function()
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow  -- menu.wplist.waypoint_index
	local selected_waypoint = menu.wplist.waypoints[menu.wplist.waypoint_index]
	menu.wplist.ret_arg[4] = "editwaypoint"
	Helper.closeMenuForSection(menu, false, "gMT_WPListMenu_editwaypoint", { toprow, selrow, {}, menu.wplist.ret_arg, {}, menu.wplist.trader, selected_waypoint })
	menu.cleanup()
	return
end

-- Function to set move up button active or not
Availability.MoveUp = function( menu, row, rowdata)
	return (rowdata[1] ~= "Add New Waypoint") and (row > 1)	
end

-- Function to set move up button active or not
Availability.MoveDown = function( menu, row, rowdata)
	return (rowdata[1] ~= "Add New Waypoint") and (row < #menu.wplist.waypoints)	
end

-- Function to set cut button active or not
Availability.Cut = function( menu, row, rowdata)
	return (rowdata[1] ~= "Add New Waypoint") and ( #menu.wplist.waypoints > 0 )	
end

-- Function to set paste button active or not
Availability.Paste = function ( menu, row, rowdata )
	return menu.wplist.wp_paste_buffer ~= nil and #menu.wplist.waypoints < menu.wplist.maxwaypoints
end

-- Function to set add waypoint button active or not
Availability.AddWaypoint = function (menu, row, rowdata)
--	return rowdata[1] == "Add New Waypoint"
	return #menu.wplist.waypoints < menu.wplist.maxwaypoints
end

-- Function to set edit waypoint button active or not
Availability.EditWaypoint = function (menu, row, rowdata)
	return (rowdata[1] ~= "Add New Waypoint") and (#menu.wplist.waypoints > 0) and rowdata[2][10] == 0
end

-- Function to set select button active or not
Availability.Done = function(menu, row, rowdata)
	return true
end

init()

return
local menu = {
	name = "gMT_Station_Logistics_Rename",
	white = {
		g = 255,
		a = 100,
		b = 255,
		r = 255
	},
	red = {
		g = 0,
		a = 100,
		b = 0,
		r = 255
	}
}

local function init()
	Menus = Menus or {}

	table.insert(Menus, menu)

	if Helper then
		Helper.registerMenu(menu)
	end

	return 
end

menu.cleanup = function ()
	menu.title = nil
	menu.object = nil
--	menu.infotable = nil
--	menu.selecttable = nil
	menu.crewdata = nil
	menu.ret_exp = nil
	return 
end

local function editboxUpdateText(_, text, textchanged)
	if textchanged then
		SetComponentName(menu.object, text)
	end
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_rename_return", {  toprow, selrow, menu.crewdata, menu.ret_exp, {}, {} })

--	Helper.closeMenuAndReturn(menu)
	menu.cleanup()

	return 
end

local function buttonOK()
	Helper.confirmEditBoxInput(menu.selecttable, 1, 1)

	return 
end

local function buttonCancel()
	Helper.cancelEditBoxInput(menu.selecttable, 1, 1)
--	Helper.closeMenuAndReturn(menu)
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_rename_return", {  toprow, selrow, menu.crewdata, menu.ret_exp, {}, {} })
	menu.cleanup()

	return 
end

menu.onShowMenu = function ()
	menu.toprow = menu.param[1]						-- return toprow
	menu.selrow = menu.param[2]						-- return row
	menu.crewdata = menu.param[3]				-- data for selected crew member
	menu.ret_exp = menu.param[4]				-- return row and expand states

	menu.object = menu.crewdata[2]
	local container = GetContextByClass(menu.object, "container", false)
	local name, objectowner = GetComponentData(menu.object, "name", "owner")

	if container then
		menu.title = GetComponentData(container, "name") .. " - " .. ((name ~= "" and name) or ReadText(1001, 56))
	else
		menu.title = (name ~= "" and name) or ReadText(1001, 56)
	end

	local setup = Helper.createTableSetup(menu)
	local isplayer, reveal = GetComponentData(menu.object, "isplayerowned", "revealpercent")

	setup.addSimpleRow(setup, {
		Helper.createButton(nil, Helper.createButtonIcon("menu_info", nil, 255, 255, 255, 100), false),
		Helper.createFontString(menu.title .. ((isplayer and "") or " (" .. reveal .. " %)"), false, "left", 255, 255, 255, 100, Helper.headerRow1Font, Helper.headerRow1FontSize, false, Helper.headerRow1Offsetx, Helper.headerRow1Offsety, Helper.headerRow1Height, Helper.headerRow1Width)
	}, nil, {
		1,
		1
	}, false, Helper.defaultTitleBackgroundColor)
	setup.addTitleRow(setup, {
		Helper.getEmptyCellDescriptor()
	}, nil, {
		3
	})

	local infodesc = setup.createCustomWidthTable(setup, {
		Helper.scaleX(Helper.standardButtonWidth),
		0,
		Helper.scaleX(Helper.headerCharacterIconSize) + 37
	}, false, false, true, 3, 1)
	setup = Helper.createTableSetup(menu)

	setup.addSimpleRow(setup, {
		Helper.createEditBox(Helper.createButtonText(name, "left", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), false, 0, 0, 880, 24, nil, nil, true)
	})

	local selectdesc = setup.createCustomWidthTable(setup, {
		0
	}, false, false, true, 1, 0, 0, Helper.tableOffsety, nil, nil, nil, 1)
	setup = Helper.createTableSetup(menu)

	setup.addSimpleRow(setup, {
		Helper.getEmptyCellDescriptor(),
		Helper.createButton(Helper.createButtonText(ReadText(1001, 14), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, true, 0, 0, 200, 23, nil, Helper.createButtonHotkey("INPUT_STATE_DETAILMONITOR_A", true)),
		Helper.getEmptyCellDescriptor(),
		Helper.createButton(Helper.createButtonText(ReadText(1001, 64), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, true, 0, 0, 200, 23, nil, Helper.createButtonHotkey("INPUT_STATE_DETAILMONITOR_ESC", true)),
		Helper.getEmptyCellDescriptor()
	}, nil, {
		1,
		1,
		1,
		1,
		1
	}, false, menu.transparent)

	local buttondesc = setup.createCustomWidthTable(setup, {
		200,
		200,
		0,
		200,
		200
	}, false, false, false, 2, 1, 0, 150)
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false)

	Helper.setEditBoxScript(menu, nil, menu.selecttable, 1, 1, editboxUpdateText)
	Helper.setButtonScript(menu, nil, menu.buttontable, 1, 2, buttonOK)
	Helper.setButtonScript(menu, nil, menu.buttontable, 1, 4, buttonCancel)

	menu.activateEditBox = true

	Helper.releaseDescriptors()

	return 
end
menu.updateInterval = 1
menu.onUpdate = function ()
	if menu.activateEditBox then
		menu.activateEditBox = nil

		Helper.activateEditBox(menu.selecttable, 1, 1)
	end

	return 
end
menu.onSelectElement = function ()
	return 
end
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuAndCancel(menu)
		menu.cleanup()
	else
--		Helper.closeMenuAndReturn(menu)
		Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_rename_return", {  toprow, selrow, menu.crewdata, menu.ret_exp, {}, {} })
		menu.cleanup()
	end

	return 
end

init()

return 
--[[	Manages the reports screen for the MT Station Logistics mod
		Version:		1.0.0
		Last Update:	2014-12-13
		
		Ranks:
			Rank							XP
		Captain
			Admiral							500,000
			Rear Admiral					200,000
			Commander						100,000
			Colonel							75,000
			Lieutenant Colonel				50,000
			Major							20,000
			Captain					
			
		Defence Officer
			Sergeant major					500,000
			Gunnery Sergeant				200,000
			Sergeant 1st Class				100,000
			Crew Sergeant					75,000
			Corporal						50,000
			Private 1st Class				20,000
			Private
			
		Engineer
			Master Chief Petty Officer		500,000
			Chief Petty Officer				200,000
			Petty Officer 1st Class			100,000
			Petty Officer 2nd Class			75,000
			Specialist						50,000
			Crewman							20,000
			Crewman Apprentice
			
 --]]
 
local Buttons, Availability, Utility = {},{},{}
 
-- Set up the default menu table
local menu = { 	name = "gMT_Station_Logistics_Reports",
				statusWidth = 150,
				statusHeight = 24,
				transparent = {
					g = 0,
					a = 0,
					b = 0,
					r = 0
			}
}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}

	table.insert(Menus, menu)

	if Helper then
		Helper.registerMenu(menu)
	end

	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.ships = nil
--	menu.ship = nil
	menu.buttons = nil
--	menu.rows = nil
--	menu.selectedRow = nil
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.expandStates = nil
	menu.expand = nil
	menu.report = nil
	menu.exp_ret = nil
	return
end

-- hook function to handle displaying the menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.report 			= {}
	
	menu.toprow 				= menu.param[4][1] or 0
	menu.selrow 				= menu.param[4][2] or 0 
	menu.expand					= menu.param[4][3]
	
	menu.report.title 			= ReadText(150402,41)						-- menu.title = "MT Station Logistics - Reports Menu"
	menu.report.subtitle 		= ReadText(150402,42)						--	menu.title = "Get data about ships and crew"

	menu.report.assigned_ships 	= menu.param[5] or {}
	menu.report.cls_crew 		= menu.param[6] or {}
	menu.report.ship			= menu.param[7] or {}
	
	menu.selectedRow = { idx = menu.selrow, data = {} }

	menu.exp_ret = {}
	-- display our menu
	menu.display( true )
	return
end

-- Main redraw function
menu.display = function (first)	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}
	
	-- Setup the header block
	local infodesc, headerHeight = LibMT.create_standard_header( menu, menu.report.title, { menu.report.subtitle, "" })
	local range = { ReadText(20001,201), ReadText(20001,101), ReadText(20001,901)  }	-- local range = { "Sector", "System", "Galaxy" }
	-- Sort crew and get a list of anyone not currently on a cls ship but is configured as a cls crewmember
	-- Get list of cls crew already on cls ships
	local assigned_crew = {}
	for i, ship in ipairs(menu.report.assigned_ships) do
		local captain, defence, engineer = GetComponentData( ship[1], "pilot", "defencenpc", "engineer" )
		if captain and GetNPCBlackboard(captain, "$XRCLS") then
			table.insert(assigned_crew, captain)
		end	
		if defence and GetNPCBlackboard(defence, "$XRCLS") then
			table.insert(assigned_crew, defence)
		end	
		if engineer and GetNPCBlackboard(engineer, "$XRCLS") then
			table.insert(assigned_crew, engineer)
		end	
	end
	
	-- Now remove these from our list of all-time cls crew
	local unassigned_crew = LibMT.Set.Difference(menu.report.cls_crew, assigned_crew )

	-- Sort ships into a list ordered by homebase
	local sorted_ships  = {}
	local homebases = {}
	if 0 < #menu.report.assigned_ships then
		for i, ship in ipairs(menu.report.assigned_ships) do
			local homebase = ""
			if type(ship[2]) == "string" then homebase = ship[2]
			else homebase = GetComponentData( ship[2], "name") end

			if sorted_ships[homebase] == nil then	
				sorted_ships[homebase] = {}
				local ship = ship[2]
				homebases[homebase] = {}
				table.insert(homebases[homebase], ship) -- for station data
			end
			local captain, defence, engineer = GetComponentData( ship[1], "pilot", "defencenpc", "engineer" )
			local crew = {captain, defence, engineer}
			table.insert(sorted_ships[homebase], {ship, crew} )
		end
	end

	if 0 < #homebases then 
		for i, station in pairs(homebases) do
--			DebugError(  GetComponentData( station, "name" ))
		end
	end

	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {
		Helper.standardButtonWidth,			-- 
		320,								-- Ship Section
		150,								-- Homebase section
		200,								-- Crew Level
		0,									-- Crew Score
		30									-- No. of Waypoints (Fill remainder of row)
	}


	local row_index = 0			-- index var for row states
	local stationctr = 0

	if 0 < #menu.report.assigned_ships then
		for homebase_key, homebase_name in pairs(sorted_ships) do
			row_index = row_index + 1
			stationctr = stationctr + 1
			-- Homebase header row
			local nrOfChildRows = 0
			for k,v in pairs(sorted_ships[homebase_key]) do
				nrOfChildRows = nrOfChildRows + 1
			end
			local isExpanded = LibMT:IsExpanded(menu, #row_collection + 1) or (menu.expand and menu.expand[row_index] and (menu.expand[row_index] > 0) ) 
			table.insert(menu.exp_ret, row_index, (isExpanded and 1) or 0)
			table.remove(menu.exp_ret, row_index+1)
			local cells = {}
			local ExpandButtonLabel = (isExpanded and "-") or "+"
			local ExpandScript = 	function (rowIdx, colIdx) LibMT:ToggleRow(menu, rowIdx, false, true) end
			local Label = tostring(homebase_key)
			local label2, zone, sector, system = "", "", "", ""
			if Label ~= "none" then
				zone, sector, system = GetComponentData(homebases[homebase_key][1], "zone", "sector", "cluster" )
			end
			label2 = system .. " - " .. sector .. " - " .. zone
			table.insert(cells, LibMT:ButtonCell(ExpandButtonLabel, ExpandScript, 1, nrOfChildRows > 0))
			table.insert(cells, LibMT:Cell(Label, nil, 1))
			table.insert(cells, LibMT:Cell(label2, nil, 4))
			table.insert(row_collection, LibMT:Row(cells, { "station", "none" }, Helper.defaultHeaderBackgroundColor, false, nrOfChildRows))
			-- Set initial expand states
			menu.rows = row_collection
			if isExpanded and menu.expand and menu.expand[row_index] > 0 then
				LibMT:ExpandRow(menu, #row_collection, true, true)
			elseif menu.expand then
				LibMT:CollapseRow(menu, #row_collection, true, true)
			end

			-- Child entries (ships)
			if isExpanded then
				for i,ship in ipairs(sorted_ships[homebase_key]) do
					row_index = row_index + 1
					local cells = {}
					local isExpanded = LibMT:IsExpanded(menu, #row_collection + 1) or (menu.expand and menu.expand[row_index] and menu.expand[row_index] > 0)
					table.insert(menu.exp_ret, row_index, (isExpanded and 1) or 0)
					table.remove(menu.exp_ret, row_index+1)
					local crew = ship[2]
					local nrOfChildRows = #crew
					local ExpandButtonLabel = (isExpanded and "-") or "+"
					local ExpandScript = 	function (rowIdx, colIdx) LibMT:ToggleRow(menu, rowIdx, false, true) end
					table.insert(cells, LibMT:ButtonCell(ExpandButtonLabel, ExpandScript, 1, nrOfChildRows > 0))
					table.insert(cells, LibMT:Cell( "    " .. GetComponentData(ship[1][1], "name"), nil, 2))
					local activity = ReadText(150402,112)						-- "None"
					if ship[1][8] == 1 then activity = ReadText(1002,1005) end	-- "Trading"
					if ship[1][8] == 2 then activity = ReadText(150402,113) end	-- "Mining"
					table.insert(cells, LibMT:Cell(tostring(range[ship[1][5]]), nil, 1))
					table.insert(cells, LibMT:Cell(activity, nil, 1))
					table.insert(cells, LibMT:Cell(ship[1][11], nil, 1))
					table.insert(row_collection, LibMT:Row(cells, { "ship", ship }, Helper.defaultHeaderBackgroundColor, false, nrOfChildRows))
					-- Set initial expand states
					menu.rows = row_collection
					if isExpanded and menu.expand and menu.expand[row_index] > 0 then
						LibMT:ExpandRow(menu, #row_collection, true, true)
						table.insert(menu.exp_ret, row_index, 1)
					elseif menu.expand then
						LibMT:CollapseRow(menu, #row_collection, true, true)
					end
					-- Get crew and display in dropdown
					if isExpanded then
						for i, crewmember in ipairs(crew) do
							local cells = {}
							table.insert(cells, LibMT:Cell("", nil, 1))
							local crew_name = GetComponentData(crewmember, "name")
							table.insert(cells, LibMT:Cell( "        " .. crew_name, nil, 1))
							local crew_type = GetComponentData(crewmember, "typename")
							local entity_type = GetComponentData(crewmember, "typestring")
							table.insert(cells, LibMT:Cell( crew_type, nil, 1))
							local crewlog = GetNPCBlackboard(crewmember, "$XRCLS")
							-- Calculate rank from xp level
							local rank = ReadText(150402,44)  -- "No rank"
							if crewlog then
								if entity_type == "commander" then
									rank = LibMT.Ranks[1][LibMT.get_entity_rank(crewlog[4])]
								elseif entity_type == "defencecontrol" then
									rank = LibMT.Ranks[2][LibMT.get_entity_rank(crewlog[4])]
								elseif entity_type == "engineer" then
									rank = LibMT.Ranks[3][LibMT.get_entity_rank(crewlog[4])]
								else
									rank = ReadText(150402,44)   -- "No Rank"
								end
							end
							table.insert(cells, LibMT:Cell( rank, nil, 1))
							local skill = Helper.round(GetComponentData(crewmember, "combinedskill")/20, 0)
							table.insert(cells, LibMT:Cell( Utility.createStarsText(skill), nil, 2))
							table.insert(row_collection, LibMT:Row(cells, { "crew", crewmember, crewlog }, Helper.defaultHeaderBackgroundColor, false, 0))
						end
					end
				end
			end
		end
	else
		local cells = {}
		table.insert(cells, LibMT:Cell( "No Ships", nil, 6))
		table.insert(row_collection, LibMT:Row(cells, { "none" }, Helper.defaultHeaderBackgroundColor, false, 0))
	end

	menu.rows = row_collection
	-- Add our unassigned crew at the very end
	if 0 < #unassigned_crew then
		row_index = row_index + 1
		stationctr = stationctr + 1
		-- Header row
		local nrOfChildRows = 0
		for _,v in ipairs(unassigned_crew) do
			nrOfChildRows = nrOfChildRows + 1
		end
		local isExpanded = LibMT:IsExpanded(menu, #row_collection + 1) or (menu.expand and menu.expand[row_index] and (menu.expand[row_index] > 0) ) 
		table.insert(menu.exp_ret, row_index, (isExpanded and 1) or 0)
		table.remove(menu.exp_ret, row_index+1)
		local cells = {}
		local ExpandButtonLabel = (isExpanded and "-") or "+"
		local ExpandScript = 	function (rowIdx, colIdx) LibMT:ToggleRow(menu, rowIdx, false, true) end
		local Label = ReadText(150402,29) -- "Unassigned Crew Members"
		table.insert(cells, LibMT:ButtonCell(ExpandButtonLabel, ExpandScript, 1, nrOfChildRows > 0))
		table.insert(cells, LibMT:Cell(Label, nil, 5))
		table.insert(row_collection, LibMT:Row(cells, { "unusedcrew", "none" }, Helper.defaultHeaderBackgroundColor, false, nrOfChildRows))
		-- Set initial expand states
		menu.rows = row_collection
		if isExpanded and menu.expand and menu.expand[row_index] > 0 then
			LibMT:ExpandRow(menu, #row_collection, true, true)
		elseif menu.expand then
			LibMT:CollapseRow(menu, #row_collection, true, true)
		end
		-- Get crew and display in dropdown
		if isExpanded then
			for i, crewmember in ipairs(unassigned_crew) do
				local cells = {}
				table.insert(cells, LibMT:Cell("", nil, 1))
				local crew_name = GetComponentData(crewmember, "name")
				table.insert(cells, LibMT:Cell( "      " .. crew_name, nil, 1))
				local crew_type = GetComponentData(crewmember, "typename")
				local entity_type = GetComponentData(crewmember, "typestring")
				table.insert(cells, LibMT:Cell( crew_type, nil, 1))
				local crewlog = GetNPCBlackboard(crewmember, "$XRCLS")
				-- Calculate rank from xp level
				local rank = ReadText(150402,44)  -- "No rank"
				if crewlog then
					if entity_type == "commander" then
						rank = LibMT.Ranks[1][LibMT.get_entity_rank(crewlog[4])]
					elseif entity_type == "defencecontrol" then
						rank = LibMT.Ranks[2][LibMT.get_entity_rank(crewlog[4])]
					elseif entity_type == "engineer" then
						rank = LibMT.Ranks[3][LibMT.get_entity_rank(crewlog[4])]
					else
						rank = ReadText(150402,44)   -- "No Rank"
					end
				end
				table.insert(cells, LibMT:Cell( rank, nil, 1))
				local skill = Helper.round(GetComponentData(crewmember, "combinedskill")/20, 0)
				table.insert(cells, LibMT:Cell( Utility.createStarsText(skill), nil, 2))
				table.insert(row_collection, LibMT:Row(cells, { "notcrew", crewmember, crewlog }, Helper.defaultHeaderBackgroundColor, false, 0))
			end
		end
	end
	
	
	-- deal with row changes here
	menu.rows = row_collection
	menu.expand = nil

--[[
	if menu.expandStates then
		for i, state in ipairs(menu.expandStates) do
			DebugError( " Expand state = " .. tostring( state.expanded ) .. 
						"\nChild states = " .. tostring( state.childStates ) .. 
						"\nNum Child rows = " .. tostring( state.nrOfChildRows ) .. 
						"\nTotal Rows - " .. tostring( state.rowsTotal ) )
			for j, child in ipairs(state.childStates) do
				DebugError( "    Child Expand = " .. tostring( child.expanded ) .. 
					"\n    Child states = " .. tostring( child.childStates ) .. 
					"\n    Num Child rows = " .. tostring( child.nrOfChildRows ) .. 
					"\n    Total Rows - " .. tostring( child.rowsTotal ) )

			end
		end
	end
--]]
		-- create the body descriptor
	if first then
		menu.toprow = menu.param[1]
		menu.selrow = menu.param[2]
	end
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight + 9, bodyHeight - 3, menu.toprow, menu.selrow )
	menu.toprow = nil
	menu.selrow = nil

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end, "INPUT_STATE_DETAILMONITOR_B" ))
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,409), Buttons.AdminLog, function () return true end, "INPUT_STATE_DETAILMONITOR_BACK" ))
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,45), Buttons.Train, Availability.Train, "INPUT_STATE_DETAILMONITOR_Y" ))
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,46), Buttons.Select, Availability.Select, "INPUT_STATE_DETAILMONITOR_X" ))
	
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the menu view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end
	
	Helper.releaseDescriptors()
	return 
end

-- standard hook function to handle changing row
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.selectedRow.idx = row
		menu.selectedRow.data = rowdata
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
		local label = ""	
		if rowdata[1] == "crew" then
			if rowdata[3] ~= nil then
				local xp = rowdata[3][4]
				local xptospend = rowdata[3][5]
 				label = ReadText(150402,47) .. ": " .. ConvertIntegerString(xptospend, true, 4, true) -- "Crew member has a service record - eXPerience Points available to spend
			else
				label = ReadText(150402,48)  -- "Crew member does not have a service record"
			end
		end
		if rowdata[1] == "notcrew" then
			local entity = rowdata[2]
			local container = GetContextByClass(entity, "container", false)
			label = ReadText(150402,30) .. ":  " .. GetComponentData(container, "name")    --  "CLS crew currently serving on non-cls vessel"
		end
		Helper.updateCellText(menu.infotable, 3, 1, label, nil)			
	end
	return
end

-- standard hook function to called on select event (not used here)
menu.onSelectElement = function ()
	return 
end

-- standard hook function called when clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuForSection(menu, false, "gMT_Admin_close")
		menu.cleanup()
	else
		Buttons:Back()
	end
	return
end

-- Callback function for back button
Buttons.Back = function()
	-- Get our expanded state for passing back
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = {toprow, selrow, menu.exp_ret}
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_back", { 1, 2, {}, expand_state })
	menu.cleanup()
	return
end

-- Callback function for Train button
Buttons.Train = function()
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = {toprow, selrow, menu.exp_ret}
	local crew = menu.selectedRow.data
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_crewskills", { 0, 0, crew, expand_state, {}, {} })
	menu.cleanup()
	return
end

-- Callback function for Admin Log button
Buttons.AdminLog = function()
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = {toprow, selrow, menu.exp_ret}
	local ship = menu.selectedRow.data
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_adminlog", { 0, 0, {}, expand_state, {}, {}, {} })
	menu.cleanup()
	return
end

-- Callback function for Ship Log Report button
Buttons.Select = function()
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = {toprow, selrow, menu.exp_ret}
	local ship = menu.selectedRow.data[2][1]
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_shiplog", { 0, 0, {}, expand_state, {}, {}, ship })
	menu.cleanup()
	return
end

-- Availability provider for Report button
Availability.Select = function(menu, rowIdx, rowData)
	return rowData[1] == "ship"
end

-- Availability provider for Train button
Availability.Train = function(menu, rowIdx, rowData )
	return (rowData[1] == "crew" or rowData[1] == "notcrew") and rowData[3] ~= nil
end

-- Returns an array of expanded states and desired rows
Utility.GetExpandState = function()
	local expand_state_table = {}
	if menu.expandStates then
		for i, exp_state in ipairs(menu.expandStates) do
			if exp_state.expanded then
				table.insert(expand_state_table, 1)
			else
				table.insert(expand_state_table, 0)
			end	
		end
	end
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow
	return toprow, selrow, expand_state_table
end

Utility.createStarsText = function(skillvalue)
	local stars = string.rep("*", skillvalue) .. string.rep("", 5 - skillvalue)
	return Helper.createFontString(stars, false, "left", 255, 255, 0, 100, Helper.starFont, 16)
end

init()

return
--[[	Manages the select ship screen for the MT Station Logistics mod
		Version:		1.0.0
		Last Update:	2014-12-13
 --]]
 
local Buttons, Availability, Utility = {},{},{}
 
-- Set up the default menu table
local menu = { 	name = "gMT_Station_Logistics_Select_Ship",
				statusWidth = 150,
				statusHeight = 24,
				transparent = {
					g = 0,
					a = 0,
					b = 0,
					r = 0
			}
}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}

	table.insert(Menus, menu)

	if Helper then
		Helper.registerMenu(menu)
	end

	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
--	menu.selectedRow = nil
--	menu.infotable = nil
--	menu.selecttable = nil
--	menu.buttontable = nil
--	menu.expandStates = nil
--	menu.logindex = nil
--	menu.toprow = nil
--	menu.selrow = nil
	menu.buttons = nil
	menu.rows = nil
	menu.expand = nil
	menu.ship = nil
	return
end

-- hook function to handle displaying the menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.ship = {}
	menu.toprow = menu.param[4][1] or 0
	menu.selrow = menu.param[4][2] or 0 
	menu.expand = menu.param[4][3] or {0, 0}
	
	menu.ship.title = ReadText(150402,21)							-- menu.ship.title = "MT Station Logistics - Administration"
	menu.ship.subtitle = ReadText(150402,101)						-- menu.ship.subtitle = "Select a ship to add as a station trader"

	menu.ship.assigned_ships = menu.param[5] or {}

	menu.selectedRow = { idx = menu.selrow, data = {} }

	menu.display()

	return
end

-- Main redraw function
menu.display = function()	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}
	
	-- Setup the header block
	local infodesc, headerHeight = LibMT.create_standard_header( menu, menu.ship.title, { menu.ship.subtitle, "" })

	local range = { ReadText(20001,201), ReadText(20001,101), ReadText(20001,901)  }	-- local range = { "Sector", "System", "Galaxy" }
	-- get a list of player owned ships
	menu.ship.ships = GetContainedShipsByOwner("player")
	-- sanity check ship list to remove invalid entries i.e. player ship, drones, small, medium,assigned to commander ,battle, CV
	menu.ship.ships = LibMT.filter_ships( menu.ship.ships, {"commander", "playership", "ship_s", "ship_m", "ship_xs", "drone", "battleship", "cv"} )
	-- remove ships with less than 20 cargo lifter drones
	menu.ship.ships = LibMT.filter_ships_bydrones( menu.ship.ships, "cargo", 5 )
	-- Remove ships with insufficient/missing crew - filters out ships with no captain as set up
	menu.ship.ships = LibMT.remove_ships_with_no_crew( menu.ship.ships )

	-- get local copy of assigned ships tables for comparison with unused ships
	local assigned, unassigned, active, inactive = {}, {}, {}, {}
	for _,details in ipairs(menu.ship.assigned_ships) do
		table.insert(assigned, details[1])
	end
	-- Remove active ships
	if #menu.ship.assigned_ships > 0 then
		menu.ship.ships = LibMT.Set.Difference(  menu.ship.ships, assigned )
	end
	
	-- Sort assigned ships into active and inactive ships
	for i, ship in ipairs(menu.ship.assigned_ships) do
		if ship[8] > 0 then
			table.insert(active, ship)
		else
			table.insert(inactive,ship)
		end
	end

	menu.ship.assigned_ships = LibMT.Set.Union( active, inactive )
	
	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {
		Helper.standardTextHeight,			-- NB Width set using height parameter to get square button
		370,								-- Ship Section
		250,								-- Homebase section
		70,									-- Crew Level
		70,									-- Crew Score
		0									-- No. of Waypoints (Fill remainder of row)
	}

	-- List already configured and active ships
	local isExpanded = LibMT:IsExpanded(menu, #row_collection + 1) or (menu.expand and menu.expand[1] and (menu.expand[1] > 0) ) 
	local nrOfChildRows = #menu.ship.assigned_ships
	local cells = {}
	local ExpandButtonLabel = (isExpanded and "-") or "+"
	local ExpandScript = 	function (rowIdx, colIdx) LibMT:ToggleRow(menu, rowIdx, false, true) end
	local Label = ReadText(150402,102) .. " (" .. (#menu.ship.assigned_ships or 0) .. ")"		--"Configured Logistics Ships"

	table.insert(cells, LibMT:ButtonCell(ExpandButtonLabel, ExpandScript, 1, #menu.ship.assigned_ships > 0))
	table.insert(cells, LibMT:Cell(Label, nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,103), nil, 1))	-- "Homebase"
	table.insert(cells, LibMT:Cell(ReadText(1001,1302), nil, 1))	-- "Range"
	table.insert(cells, LibMT:Cell(ReadText(150402,111), nil, 1))	-- "Activity" eg None{150402,112}, trading{1002,1005}, mining{150402,113} 
	table.insert(cells, LibMT:Cell(ReadText(150402,106), nil, 1))	-- "#WP"
	table.insert(row_collection, LibMT:Row(cells, { "header", "none" }, Helper.defaultHeaderBackgroundColor, false, nrOfChildRows))

	-- Set initial expand states
	menu.rows = row_collection
	if isExpanded and menu.expand then
		LibMT:ExpandRow(menu, #row_collection, true, false)
	elseif menu.expand then
		LibMT:CollapseRow(menu, #row_collection, true, false)
	end

	-- Expandable row - Assigned ships
	local cells = {}
	if isExpanded then
		for i,ship in ipairs(menu.ship.assigned_ships or {}) do
			cells = {}
			local homebase = ""
			if type(ship[2]) == "string" then homebase = ship[2]
			else homebase = GetComponentData( ship[2], "name") end
			table.insert(cells, LibMT:Cell("", nil, 1))
			table.insert(cells, LibMT:Cell( "   " .. GetComponentData(ship[1], "name"), nil, 1))
			table.insert(cells, LibMT:Cell( homebase, nil, 1))
--			local captainscore, defencescore, engineerscore, level, crewscore = LibMT.get_crew_level( ship[1] )
			local activity = ReadText(150402,112)						-- "None"
			if ship[8] == 1 then activity = ReadText(1002,1005) end		-- "Trading"
			if ship[8] == 2 then activity = ReadText(150402,113) end	-- "Mining"
			table.insert(cells, LibMT:Cell(tostring(range[ship[5]]), nil, 1))
			table.insert(cells, LibMT:Cell(activity, nil, 1))
			table.insert(cells, LibMT:Cell(ship[11], nil, 1))
			table.insert(row_collection, LibMT:Row(cells, { "active", ship }, Helper.defaultHeaderBackgroundColor, false, 0))
		end
	end

	-- Header Row - unassigned ships
	local isExpanded = LibMT:IsExpanded(menu, #row_collection + 1) or (menu.expand and menu.expand[2] and (menu.expand[2] > 0) )
	local nrOfChildRows = #menu.ship.ships
	local cells = {}
	local ExpandButtonLabel = (isExpanded and "-") or "+"
	local ExpandScript = 	function (rowIdx, colIdx) LibMT:ToggleRow(menu, rowIdx, false) end
	local Label = ReadText(150402,107) .. " (" .. #menu.ship.ships .. ")"		-- "Un-configured ships available"

	table.insert(cells, LibMT:ButtonCell(ExpandButtonLabel, ExpandScript, 1, #menu.ship.ships > 0))
	table.insert(cells, LibMT:Cell(Label, nil, 1))
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(row_collection, LibMT:Row(cells, { "header", "none" }, Helper.defaultHeaderBackgroundColor, false, nrOfChildRows))

	-- Set initial expand states
	menu.rows = row_collection
	if isExpanded and menu.expand then
		LibMT:ExpandRow(menu, #row_collection, true)
	elseif menu.expand then
		LibMT:CollapseRow(menu, #row_collection, true)
	end


	-- Expandable row - unassigned ships
	local cells = {}
	if isExpanded then
		for i,ship in ipairs(menu.ship.ships) do
			cells = {}
			-- Calculate the crew score and return with trader stuff
			local captainscore, defencescore, engineerscore, level, crewscore = LibMT.get_crew_level( ship )
			table.insert(cells, LibMT:Cell("", nil, 1))
			table.insert(cells, LibMT:Cell( "   " .. GetComponentData(ship, "name"), nil, 1))
			table.insert(cells, LibMT:Cell("", nil, 1))
			table.insert(cells, LibMT:Cell(tostring(range[level]), nil, 1))
			local activity = ReadText(150402,112)						-- "None"
			table.insert(cells, LibMT:Cell(activity, nil, 1))
			table.insert(cells, LibMT:Cell("", nil, 1))
			table.insert(row_collection, LibMT:Row(cells, { "new", {ship} }, Helper.defaultHeaderBackgroundColor, false, 0))
		end
	end

	-- deal with row changes here
	menu.rows = row_collection
	-- and expand states
	menu.expand = nil 
	
	-- create the body descriptor
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight + 5, bodyHeight - 6, menu.toprow, menu.selrow )

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,108), Buttons.Remove, Availability.Remove, "" ))									-- "Remove"
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,109),Buttons.Stop, Availability.Stop,""))										-- "Stop"
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,103),Buttons.Homebase, Availability.Homebase,""))								-- "Homebase"
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end, "INPUT_STATE_DETAILMONITOR_B" ))	-- "Back"
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,3106), Buttons.Add, Availability.Add, "INPUT_STATE_DETAILMONITOR_BACK" ))			-- "Add"
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1009,8), Buttons.Start, Availability.Start,"INPUT_STATE_DETAILMONITOR_Y"))				-- "Start"
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,110), Buttons.Select, Availability.Select, "INPUT_STATE_DETAILMONITOR_X" ))		-- "Configure"
	
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the menu view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end
	
	Helper.releaseDescriptors()
	return 
end

-- standard hook function to handle changing row
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.selectedRow.idx = row
		menu.selectedRow.data = rowdata
		-- Show ship location in header
		if rowdata[1] ~= "header" then
			local zone, sector, system = GetComponentData(rowdata[2][1], "zone", "sector", "cluster")
			local label = ReadText(20001,301) .. ": " ..zone .. " - " .. ReadText(20001,201) .. ": " .. sector .. " - " .. ReadText(20001,101) .. ": " .. system
			Helper.updateCellText(menu.infotable, 3, 1, label, LibMT.colours.white)	
			-- check ship has a captain
			local captain = GetComponentData( rowdata[2][1], "pilot" )
			if captain == nil then
				menu.ship.hascaptain = false
				Helper.updateCellText(menu.infotable, 3, 1, "SHIP HAS NO CAPTAIN!!!", LibMT.colours.red)
			else 
				menu.ship.hascaptain = true
			end
		else
			Helper.updateCellText(menu.infotable, 3, 1, "", nil)
		end
		
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

-- standard hook function to called on select event (not used here)
menu.onSelectElement = function ()
	return 
end

-- standard hook function called when clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	if dueToClose == "close" then
		Helper.closeMenuForSection(menu, false, "gMT_Admin_close")
		menu.cleanup()
	else
		Buttons:Back()
		menu.cleanup()
	end
	return
end

-- Callback function for back button
Buttons.Back = function()
	-- Get our expanded state for passing back
	local toprow, selrow, expand_state_table = Utility:GetExpandState()
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_back", { 1, 1, {}, {toprow, selrow, expand_state_table}  })
	menu.cleanup()
	return
end

-- Callback function for Add ship button
Buttons.Add = function ()
	Utility:Trader()
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = { toprow, selrow, exp_tab, "addship" }
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_addship", { toprow, selrow, {}, expand_state, {}, menu.ship.trader, {} })
	menu.cleanup()
	return
end	

-- Callback function for select button
Buttons.Remove = function()
	Utility:Trader()
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = { toprow, selrow, exp_tab, "removeship" }
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_removeship", { toprow, selrow, {}, expand_state, {}, menu.ship.trader, {} })
	menu.cleanup()
	return
end

-- Callback function for Configure button
Buttons.Select = function()
	Utility:Trader()
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = { toprow, selrow, exp_tab, "configship" }
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_config", { toprow, selrow, {}, expand_state, {}, menu.ship.trader, {}})
	menu.cleanup()
	return
end

-- Callback function for Start button
Buttons.Start = function()
	Utility:Trader() -- note that this is just a dummy return value - values are manipulated in MD code
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = { toprow, selrow, exp_tab, "startship" }
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_startship", { toprow, selrow, {}, expand_state, {}, menu.ship.trader, {} })
	menu.cleanup()
	return
end

-- Callback function for Stop button
Buttons.Stop = function()
	Utility:Trader() -- note that this is just a dummy return value - values are manipulated in MD code
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = { toprow, selrow, exp_tab, "stopship" }
	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_stopship", { toprow, selrow, {}, expand_state, {}, menu.ship.trader, {} })

--	menu.ret_arg[5] = "stopship"
--	Helper.closeMenuForSection(menu, false, "gMT_ShipMenu_stopship", { toprow, selrow, menu.ret_arg, {}, {}, exp_tab })
	menu.cleanup()
	return
end

-- Callback function for Homebase select button
Buttons.Homebase = function()
	Utility:Trader() -- return our trader for safekeeping whilst getting our homebase
	local toprow, selrow, exp_tab = Utility:GetExpandState()
	local expand_state = { toprow, selrow, exp_tab, "map_call"}
	Helper.closeMenuForSubSection(menu, false, "gMT_ShipMenu_gethomebase", { toprow, selrow, {}, expand_state, {}, menu.ship.trader, {} })
	menu.cleanup()
	return
end

-- Availability provider function for Add button
Availability.Add = function(menu, rowIdx, rowData)
	-- Ship is not already on the active list
	return (rowData[1] == "new")
end

-- Availability provider for remove button
Availability.Remove = function(menu, rowIdx, rowData)
	-- Ship is on the active list and must not be trading/mining
	return rowData[1] == "active" and rowData[2][8] < 1
end

-- Availability provider for Configure button
Availability.Select = function(menu, rowIdx, rowData)
	-- Ship is on the active list and has a homebase assigned
	return rowData[1] == "active" and rowData[2][2] ~= "none"
end

-- Availability provider for the Start button
Availability.Start = function(menu, rowIdx, rowData)
	-- Ship must be inactive, have a captain, have a homebase and have at least 2 waypoints to start
	return rowData[1] == "active" and rowData[2][3] ~= "none" and rowData[2][11] > 1 and rowData[2][8] < 1 and menu.ship.hascaptain
end

-- Availability provider for the Stop button
Availability.Stop = function(menu, rowIdx, rowData)
	return rowData[1] == "active" and rowData[2][8] > 0
end

-- Availability provider for the Homebase button
Availability.Homebase = function(menu, rowIdx, rowData)
	-- Ship is on the active list and is not currently trading
	return rowData[1] == "active" and rowData[2][8] < 1
end


-- Returns an array of expanded states and desired rows
Utility.GetExpandState = function()
	local expand_state_table = {}
	for i, exp_state in ipairs(menu.expandStates) do
		if exp_state.expanded then
			table.insert(expand_state_table, 1)
		else
			table.insert(expand_state_table, 0)
		end	
	end
	local toprow = GetTopRow(menu.defaulttable)
	local selrow = Helper.currentDefaultTableRow
	return toprow, selrow, expand_state_table
end

-- Sets up returns values for a trader record
Utility.Trader = function()
	-- Calculate the crew score and return with trader stuff
	local data = menu.selectedRow.data[2]
	menu.ship.trader = {}													-- Holds entire trader record
	menu.ship.ship = data[1] 												-- ship
	menu.ship.homebase = data[2] or "none"									-- homebase	
	menu.ship.cargolist = data[3] or LibMT.GetCargoSpecs( menu.ship.ship ) 	-- List of cargo the ship can carry
	menu.ship.waypoints = data[4] or {}										-- List of configured waypoints for this ship
	menu.ship.level = data[5] or 1
	menu.ship.crewscore = data[6] or 0
	menu.ship.log = data[7] or {}											-- Ship's log entries
	menu.ship.activity = data[8] or 0										-- Current activity
	menu.ship.stats = data[9] or {0, 0, 0, 0}								-- Ship stats { flying time, total time, volume traded, turnover}
	menu.ship.index = data[10] or 0											-- Ship's index in global table
	menu.ship.numwp = data[11] or 0 										-- Number of waypoints
	menu.ship.tracklog = data[12] or {}										-- Tracking log - keep clear unless in use
	menu.ship.DbgLvl = data[13] or 0										-- Debug level for this ship
	menu.ship.Track = data[14] or 0											-- True if ship is being tracked

	table.insert( menu.ship.trader, menu.ship.ship )
	table.insert( menu.ship.trader, menu.ship.homebase )
	table.insert( menu.ship.trader, menu.ship.cargolist )
	table.insert( menu.ship.trader, menu.ship.waypoints )
	table.insert( menu.ship.trader, menu.ship.level )
	table.insert( menu.ship.trader, menu.ship.crewscore )
	table.insert( menu.ship.trader, menu.ship.log )
	table.insert( menu.ship.trader, menu.ship.activity )
	table.insert( menu.ship.trader, menu.ship.stats )
	table.insert( menu.ship.trader, menu.ship.index )
	table.insert( menu.ship.trader, menu.ship.numwp )
	table.insert( menu.ship.trader, menu.ship.tracklog )
	table.insert( menu.ship.trader, menu.ship.DbgLvl )
	table.insert( menu.ship.trader, menu.ship.Track )

end


init()

return
--[[	Manages the trader ship log screen for the MT Station Logistics mod
		Version:		1.0.1
		Last Update:	2015-01-23
 --]]
 
-- Set up the default menu table
local menu = 	{	name = "gMT_Station_Logistics_ShipLog",
					statusWidth = 150,
					statusHeight = 24,
					transparent = 
					{
						g = 0,
						a = 0,
						b = 0,
						r = 0
					}
				}		

local Buttons, Availability = {}, {}

-- Standard menu initialiser - initialise variables global to this menu here if needed
local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	return
end

-- Standard Menu cleanup utility - place all variables no longer needed in here and assign the value nil to them
menu.cleanup = function ()
	menu.updateInterval = nil
	menu.infotable = nil
	menu.selecttable = nil
	menu.buttontable = nil
	menu.defaulttable = nil
	menu.buttons = nil
	menu.ship = nil
	return
end

-- standard callback function that fires on first time display of menu
menu.onShowMenu = function ()
	-- setup various variables used in the menu
	menu.ship = {}
	menu.toprow = 3 -- menu.param[1]				-- return toprow
	menu.selrow = 3 -- menu.param[2]				-- return row
	menu.ship.ret_exp = menu.param[4]				-- return row and expand states
	menu.ship.trader = menu.param[7]
	menu.ship.numwaypoints = menu.ship.trader[11]
	
	menu.ship.title = ReadText(150402,401)			-- menu.title = "MT Station Logistics - Ship Log"
	menu.ship.subtitle = ReadText(150402,402) 		-- "Get data from your Logistics Trader ships"
	
	menu.ship.log = menu.ship.trader[7] or {}
	menu.ship.adminlog = menu.param[8] or {}
--	menu.ship.TrackLog = menu.ship.trader[12]
	menu.ship.debug_level = menu.ship.trader[13]
	menu.ship.tracking = menu.ship.trader[14]
	menu.ship.dbgType = { "Normal", "Verbose" }
	menu.ship.tracktype = { "Not Tracking", "Tracking" }
	
	-- Get a handle for the captain's log which is used for tracking entries
	menu.ship.captain = GetComponentData( menu.ship.trader[1], "pilot" )
	menu.ship.TrackLog = {}
	menu.ship.command = ""
	if menu.ship.captain then
		local aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(menu.ship.captain, "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		local numaicommands = #aicommandstack
		local updatetext = ""
		if 0 < numaicommands then
			aicommand = aicommandstack[1].command
			aicommandparam = aicommandstack[1].param
		end

		updatetext = updatetext .. "" .. ReadText(1001, 78) .. ReadText(1001, 120) .. " " .. string.format(aicommand, (IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name")) or nil)

		if 1 < numaicommands then
			aicommandaction = aicommandstack[numaicommands].command
			aicommandactionparam = aicommandstack[numaicommands].param
		end

		if aicommandaction ~= "" then
			updatetext = updatetext .. " - " .. string.format(aicommandaction, (IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name")) or nil)
		end
		menu.ship.command = updatetext
		menu.ship.captainlog = GetNPCBlackboard(menu.ship.captain, "$XRCLS")
		if menu.ship.captainlog then
			menu.ship.TrackLog = menu.ship.captainlog[6]
		else	
			menu.ship.TrackLog = {}
			menu.ship.command = ""
		end
	end
	
	menu.selectedRow = { idx = menu.selrow, data = {} }

	menu.display( )
	
	return
end

-- main draw/redraw function
menu.display = function ()	
	Helper.removeAllButtonScripts(menu)
	Helper.currentTableRow = {}
	Helper.currentTableRowData = nil
	menu.rowDataMap = {}

	-- Setup for display
	local name, ownericon = GetComponentData(menu.ship.trader[1], "name", "ownericon") -- , "typestring", "typeicon", "typename", "ownericon", "skills")
	local textstring = menu.ship.title .. "\n" .. name
	title = {Helper.createIcon(ownericon, false, 255, 255, 255, 100, 0, 0, Helper.headerCharacterIconSize, Helper.headerCharacterIconSize),
	Helper.createFontString(textstring, false, "left", 255, 255, 255, 100, Helper.headerRow1Font, Helper.headerRow1FontSize, true),
	Helper.createFontString("", false, "left", 255, 255, 255, 100, Helper.headerRow1Font, Helper.headerRow1FontSize),
	}
	local colwidth = {
						Helper.scaleX(Helper.headerCharacterIconSize),
						0,
						250,
						Helper.scaleX(Helper.headerCharacterIconSize) + 37
					}
	local colspan = {1,2,1}
	local additional = {}
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,303) .. ":", nil, 1))  -- "Flying Time"
	table.insert(cells, LibMT:Cell(ConvertTimeString(  menu.ship.trader[9][1] ), nil, 1))   
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,403) .. ":", nil, 1))  -- "Total Time"
	table.insert(cells, LibMT:Cell(ConvertTimeString(  menu.ship.trader[9][2] ), nil, 1))   
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,406) .. ":", nil, 1))  -- "% Time Active"
	local pc_time = 0
	if Helper.round(menu.ship.trader[9][2], 0) > 0 then
		pc_time = Helper.round(menu.ship.trader[9][1]*100/menu.ship.trader[9][2], 0)
	end
	table.insert(cells, LibMT:Cell(pc_time .. " %", nil, 1))   
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,404) .. ":", nil, 1))  -- "Turnover"
	local money = ConvertMoneyString( menu.ship.trader[9][4]/100, false, true, nil, true) .. " Cr" 
	table.insert(cells, LibMT:Cell(money, nil, 1))
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(cells, LibMT:Cell(ReadText(150402,405) .. ":", nil, 1))  -- "Volume Traded"
	local vol = ConvertIntegerString(menu.ship.trader[9][3], true, 4, true)
	table.insert(cells, LibMT:Cell(vol .. ReadText(1001,110), nil, 1))
	table.insert(cells, LibMT:Cell("", nil, 1))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	local cells = {}
	table.insert(cells, LibMT:Cell(menu.ship.command, nil, 4))
	table.insert(additional, LibMT:Row(cells, {"none"}, Helper.defaultHeaderBackgroundColor, false, 0))
	
	-- Create the menu header and get its height
	local infodesc, headerHeight = LibMT.create_column_header( menu, title, { typename }, additional, colwidth, colspan, true )

	-- setup the list view here	
	local standard_button_height = 60
	local bodyHeight = 570 - headerHeight - standard_button_height
	local row_collection = {}
	local cell_scripts = {}
	local colWidths = {			
		75,
		100,
		200,
		100,
		0
	}
	
	-- Setup main table
	-- Normal log view
	-- Header Rows
	if menu.ship.tracking == 0 then 
		local cells = {}
		table.insert(cells, LibMT:Cell( ReadText(150402,410), nil, 2) ) -- "Activity Log"
		if LibMT.DEBUG then
			if 0 < menu.ship.debug_level then
				table.insert(cells, LibMT:Cell( ReadText(150402,411) .. " - " .. menu.ship.dbgType[2], nil, 2) ) -- "Debug Level for this ship"
			else
				table.insert(cells, LibMT:Cell( ReadText(150402,411) .. " - " .. menu.ship.dbgType[1], nil, 2) ) -- "Debug Level for this ship"
			end
		else
			table.insert(cells, LibMT:Cell( "", nil, 2) ) 
		end
		table.insert(cells, LibMT:Cell( menu.ship.tracktype[menu.ship.tracking + 1], nil, 1) ) -- "Tracking for this ship"
		table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))
		if 0 < #menu.ship.log then
			local cells = {}
			table.insert(cells, LibMT:Cell( ReadText(1001,24), nil, 1) ) -- "Time"
			table.insert(cells, LibMT:Cell( ReadText(150402,163), nil, 1) ) -- "WP Type"
			table.insert(cells, LibMT:Cell( ReadText(1001,45), nil, 1) ) -- "Ware"
			table.insert(cells, LibMT:Cell( ReadText(1001,1202), nil, 1) ) -- "Amount"
			table.insert(cells, LibMT:Cell( ReadText(1001,3), nil, 1) ) -- "Station"
			table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))
		
			for i,msg in ipairs(menu.ship.log) do
				local cells = {}
				table.insert(cells, LibMT:Cell( ConvertTimeString(GetCurTime() - msg[1]), nil, 1) )
				table.insert(cells, LibMT:Cell( tostring(msg[17]) .. " - " .. LibMT.WPType[msg[6]], nil, 1) )
				table.insert(cells, LibMT:Cell( GetWareData( msg[8],"name"), nil, 1) )
				table.insert(cells, LibMT:Cell(msg[9], nil, 1) )
				table.insert(cells, LibMT:Cell( GetComponentData( msg[7], "name"), nil, 1) )
				table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, false, 0))
			end
		else
			local cells = {}
			table.insert(cells, LibMT:Cell("", nil, 5) ) -- ""
			table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))
			local cells = {}
			table.insert(cells, LibMT:Cell( ReadText(150402,412), nil, 5) ) -- "No Log Entries to show"
			table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, false, 0))
		end
	elseif menu.ship.tracking == 1 then
		local cells = {}
		table.insert(cells, LibMT:Cell( ReadText(150402,413), nil, 2) ) -- "Tracking Log"
		if 0 < menu.ship.debug_level then
			table.insert(cells, LibMT:Cell( ReadText(150402,411) .. " - " .. menu.ship.dbgType[2], nil, 2) ) -- "Debug Level for this ship"
		else
			table.insert(cells, LibMT:Cell( ReadText(150402,411) .. " - " .. menu.ship.dbgType[1], nil, 2) ) -- "Debug Level for this ship"
		end
		table.insert(cells, LibMT:Cell( menu.ship.tracktype[menu.ship.tracking + 1], nil, 1) ) -- "Tracking for this ship"
		table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))
		local cells = {}
		table.insert(cells, LibMT:Cell( ReadText(1001,24), nil, 1) ) -- "Time"
		table.insert(cells, LibMT:Cell( ReadText(150402,463), nil, 4) ) -- "Message"
		table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, true, 0))
		
		for i = 3, 33, 1 do
			local msg = menu.ship.TrackLog[i - 2]
			if msg then
				if msg[3] == "TRADE_SUCCESS" then
					local cells = {}
					local message = ReadText(150402,414) .. ": " .. tostring(msg[17]) .. " - " .. LibMT.WPType[msg[6]] .. " - " .. GetWareData( msg[8],"name") .. " - " .. msg[9] .. " - " .. GetComponentData( msg[7], "name")
					table.insert(cells, LibMT:Cell( ConvertTimeString(GetCurTime() - msg[1]), nil, 1) )
					table.insert(cells, LibMT:Cell( message, nil, 4) )
					table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, false, 0))
				else
					local cells = {}
					local message = ReadText(150402,414) .. ": " .. tostring(msg[17]) .. ": " .. tostring(LibMT.Messages[ msg[3] ])
					table.insert(cells, LibMT:Cell( ConvertTimeString(GetCurTime() - msg[1]), nil, 1) )
					table.insert(cells, LibMT:Cell( message, nil, 4) )
					table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, false, 0))
				end
			else
				local cells = {}
				local message = ""
				table.insert(cells, LibMT:Cell( "", nil, 1) )
				table.insert(cells, LibMT:Cell( message, nil, 4) )
				table.insert(row_collection, LibMT:Row(cells, {}, Helper.defaultHeaderBackgroundColor, false, 0))
			end
		end
	end
	-- create the body descriptor
	local selectdesc = LibMT.create_body( menu, row_collection, cell_scripts, colWidths, true, false, headerHeight + 14, bodyHeight + 20, menu.toprow, menu.selrow)

	-- setup the button section view
	menu.buttons = {}
	-- Setup the button bar
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton())
	table.insert(menu.buttons, LibMT:BarButton(ReadText(1001,2669), Buttons.Back, function () return true end,"INPUT_STATE_DETAILMONITOR_B"))
	table.insert(menu.buttons, LibMT:BarButton())
	if LibMT.DEBUG then
		table.insert(menu.buttons, LibMT:BarButton("(DBG) Verbose", Buttons.Verbose, function () return true end,"INPUT_STATE_DETAILMONITOR_Y"))
	else
		table.insert(menu.buttons, LibMT:BarButton())
	end
	table.insert(menu.buttons, LibMT:BarButton(ReadText(150402,407), Buttons.Track, function () return true end,"INPUT_STATE_DETAILMONITOR_X"))
	-- create the button bar
	local buttondesc = LibMT.create_standard_button_bar( menu, menu.buttons, headerHeight, bodyHeight )

	-- build and display the view
	menu.infotable, menu.selecttable, menu.buttontable = Helper.displayThreeTableView(menu, infodesc, selectdesc, buttondesc, false, "", "", 0, 0, 0,0, "both", false, false)

	-- finally, we call all the script attaching functions
	for _, func in ipairs(cell_scripts) do
		func()
	end

	Helper.releaseDescriptors()
	
	return 
end

-- standard callback function that fires on a row change
menu.onRowChanged = function (row, rowdata, rc_table)
	if rc_table == menu.defaulttable then
		menu.selectedRow.idx = row
		menu.selectedRow.data = rowdata
		LibMT:CheckButtonBarAvailability(menu, row, rowdata)
	end
	return
end

-- standard callback function that fires when an element is selected
menu.onSelectElement = function ()
	return 
end

-- standard callback function to deal with clicking the '<' or 'x' buttons in the corner of the menu
menu.onCloseElement = function (dueToClose)
	Buttons:Back()
	return
end

-- Timed update callback 
menu.updateInterval = 1
menu.onUpdate = function ()
	if menu.ship.captain then
		local zone, sector, system = GetComponentData(menu.ship.trader[1], "zone", "sector", "cluster")
		local aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(menu.ship.captain, "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		local numaicommands = #aicommandstack
		local updatetext = "Location: " .. tostring(system) .. " / " .. tostring(sector) .. " / " .. tostring(zone) .. "  "
		if 0 < numaicommands then
			aicommand = aicommandstack[1].command
			aicommandparam = aicommandstack[1].param
		end

		updatetext = tostring(updatetext .. "" .. ReadText(1001, 78) .. 
								ReadText(1001, 120) .. " " ..  
								string.format(aicommand, (IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name")) or nil))

		if 1 < numaicommands then
			aicommandaction = aicommandstack[numaicommands].command
			aicommandactionparam = aicommandstack[numaicommands].param
		end

		if aicommandaction ~= "" then
			updatetext = tostring(updatetext .. " - " .. string.format(aicommandaction, (IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name")) or nil))
		end
		menu.ship.command = updatetext
		menu.ship.captainlog = GetNPCBlackboard(menu.ship.captain, "$XRCLS")
		if menu.ship.captainlog and menu.ship.tracking == 1 then
			if 0 < #menu.ship.TrackLog then
				menu.ship.TrackLog = menu.ship.captainlog[6]
				local wpnum = menu.ship.captainlog[6][1][17]
				if wpnum == menu.ship.numwaypoints then
					wpnum = 0
				end
				Helper.updateCellText(menu.infotable, 7, 1, updatetext, LibMT.colours.white)
				Helper.updateCellText(menu.selecttable, 1, 1, ReadText(150402,413) .. " - WP " .. wpnum + 1, LibMT.colours.white)
				for i=3, 33 ,1 do
					local msg = menu.ship.TrackLog[i - 2]
					if msg then
						if msg[3] == "TRADE_SUCCESS" then
							local message = ReadText(150402,414) .. ": " .. tostring(msg[17]) .. " - " .. LibMT.WPType[msg[6]] .. " - " .. GetWareData( msg[8],"name") .. " - " .. msg[9] .. " - " .. GetComponentData( msg[7], "name")
							Helper.updateCellText(menu.selecttable, i, 1, ConvertTimeString(GetCurTime() - msg[1]), LibMT.colours.white)
							Helper.updateCellText(menu.selecttable, i, 2, message, LibMT.colours.white)
						else
							local message = ReadText(150402,414) .. ": " .. tostring(msg[17]) .. " - " .. tostring(LibMT.Messages[ msg[3] ])
							Helper.updateCellText(menu.selecttable, i, 1, ConvertTimeString(GetCurTime() - msg[1]), LibMT.colours.white)
							Helper.updateCellText(menu.selecttable, i, 2, message, LibMT.colours.white)
						end
					end
				end
			end
		end
	end
end 

-- Callback function for back button
Buttons.Back = function()
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_return", { menu.ship.ret_exp[1], menu.ship.ret_exp[2], {}, menu.ship.ret_exp, {}, {}, menu.ship.trader } )
	menu.cleanup()
	return
end

-- Callback function for ship track button
Buttons.Track = function()
	-- toggle the value
	if menu.ship.tracking == 0 then
		menu.ship.tracking = 1
	else
		menu.ship.tracking = 0
	end
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_toggleTracking", { 3, 3, menu.ship.tracking, menu.ship.ret_exp, {}, {}, menu.ship.trader} )
	menu.cleanup()
	return
end

-- Callback function for toggle verbose debug button
Buttons.Verbose = function()
	if menu.ship.debug_level == 0 then
		menu.ship.debug_level = 4
	else
		menu.ship.debug_level = 0
	end
	Helper.closeMenuForSection(menu, false, "gMT_ReportMenu_toggleDbg", { menu.ship.ret_exp[1], menu.ship.ret_exp[2], menu.ship.debug_level, menu.ship.ret_exp, {}, {}, menu.ship.trader} )
	menu.cleanup()
	return
end

-- Availability provider for the train button
Availability.Select = function(menu, rowIdx, rowData )
end

init()

return
